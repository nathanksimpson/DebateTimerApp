<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>AP Debate Timer — HTML</title>
<style>
:root{
--bg-green:#d1fae5; --fg-green:#064e3b; --bd-green:#34d399;
--bg-yellow:#fef3c7; --fg-yellow:#92400e; --bd-yellow:#f59e0b;
--bg-red:#fecaca; --fg-red:#7f1d1d; --bd-red:#f87171;
--bg-card:#ffffff; --bd:#e5e7eb; --fg:#111827; --muted:#6b7280;
--track:#e5e7eb; --fill:#111827;
}
html,body{height:100%}
body{margin:0;font:16px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";}
.wrap{min-height:100%;display:flex;flex-direction:column;align-items:center;gap:24px;padding:24px;transition:background-color .25s,color .25s; box-sizing: border-box;} /* Added box-sizing */
.container{width:100%;max-width:1000px;display:flex;flex-direction:column;gap:16px}
header{display:flex;justify-content:space-between;align-items:center;gap:12px; flex-wrap: wrap;} /* Added flex-wrap */
h1{font-size:24px;margin:0}
.row{display:flex;gap:8px;flex-wrap:wrap}
.btn{appearance:none;border:1px solid var(--bd);background:#fff;border-radius:12px;padding:10px 14px;cursor:pointer;display:inline-flex;align-items:center;gap:8px;font-weight:600}
.btn:active{transform:translateY(1px)}
.card{background:var(--bg-card);border:1px solid var(--bd);border-radius:16px;padding:16px}
.title{font-weight:700}
.muted{color:var(--muted)}
.clock{font-size:76px;font-weight:900;text-align:center; line-height: 1.1;} /* Added line-height */
.progress{height:12px;background:var(--track);border-radius:999px;position:relative;overflow:hidden}
.fill{position:absolute;left:0;top:0;bottom:0;background:var(--fill)}
.seg{outline:1px solid rgba(0,0,0,0.12);height:100%}
.grid{display:grid;gap:12px}
.grid-3{grid-template-columns:repeat(3,minmax(0,1fr))}
.grid-4{grid-template-columns:repeat(4,minmax(0,1fr))}
.input{padding:8px 10px;border:1px solid var(--bd);border-radius:10px;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
.label{display:flex;flex-direction:column;gap:6px}
.bar{height:8px;background:rgba(17,24,39,.12);border-radius:8px;overflow:hidden}
.bar>.bfill{height:100%;background:#111827}
.caps{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:6px;margin-top:6px;color:#475569;font-size:12px}
.tests li{margin:2px 0}
.note{font-size:12px;color:#6b7280;margin-top:6px;text-align:center}

/* Speaker Progress Bar Styles */
.speaker-progress-bar {
display: flex; /* Changed from grid to flex */
flex-wrap: wrap; /* Added wrap */
gap: 4px;
border-radius: 8px;
background-color: var(--track);
padding: 4px;
}
.speaker-box {
font-size: 12px; /* Increased from 11px */
font-weight: 700;
padding: 8px 4px;
border-radius: 6px;
text-align: center;
background-color: #fff;
border: 1px solid var(--bd);
cursor: grab;
user-select: none;
-webkit-user-select: none; /* Added prefix for iOS */
transition: background-color 0.2s, box-shadow 0.2s, opacity 0.2s;
flex: 1 1 50px; /* Added flex-basis for responsiveness */
min-width: 50px; /* Ensures a minimum tap target size */
}
.speaker-box:active { cursor: grabbing; }
.speaker-box.team-prop, .speaker-box.team-gov, .speaker-box.team-aff { color: #15803d; border-color: #86efac; } /* Added Aff */
.speaker-box.team-opp, .speaker-box.team-neg { color: #b91c1c; border-color: #fca5a5; } /* Added Neg */
.speaker-box.team-none { color: #374151; border-color: #d1d5db; }
.speaker-box.active-speaker {
box-shadow: 0 0 0 3px var(--fg, #111827);
font-weight: 900;
}

/* New styles for drag/drop and inactive */
.speaker-box.dragging {
opacity: 0.5;
background: #e0f2fe;
}
.speaker-box.drag-over {
background: #fef9c3;
border-style: dashed;
}
.speaker-box.inactive {
opacity: 0.4;
background: #f3f4f6;
text-decoration: line-through;
cursor: not-allowed;
}

/* Responsive Media Queries */
@media (max-width:800px){
.grid-3, .grid-4 { grid-template-columns:repeat(2,minmax(0,1fr)) } /* 2 cols */
}

@media (max-width: 600px) {
.grid-3, .grid-4 { grid-template-columns: 1fr } /* 1 col */
.clock { font-size: 60px; } /* Scale down large clock */
.caps { grid-template-columns: 1fr; } /* Stack bell time caps */
}

@media (max-width: 400px) {
.clock { font-size: 48px; } /* Scale down large clock further */
.btn { padding: 8px 10px; font-size: 14px; } /* Make buttons slightly smaller */
}
</style>
</head>
<body>
  <!-- 
    NEW: Added a persistent, silent <audio> tag.
    This is the key to unlocking audio on iOS, as per your suggestion.
  -->
  <audio id="silentUnlockAudio" src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=" loop muted playsinline></audio>

<div id="app" class="wrap">
<div class="container">
<header>
@@ -309,8 +315,10 @@
{ role: "Prop Whip", initials: "PW", team: "Prop", timers: ["main"], active: true },
{ role: "OW Prep", initials: "R", team: "Opp", timers: ["cross-ex"], active: true },
{ role: "Opp Whip", initials: "OW", team: "Opp", timers: ["main"], active: true },
    { role: "Opp Reply", initials: "OR", team: "Opp", timers: ["rebuttal"], active: true },
    { role: "Prop Reply", initials: "PR", team: "Prop", timers: ["rebuttal"], active: true },
    { role: "Prop Reply Prep", initials: "R", team: "Prop", timers: ["cross-ex"], active: true }, // New
    { role: "Prop Reply", initials: "PR", team: "Prop", timers: ["rebuttal"], active: true }, // Swapped
    { role: "Opp Reply Prep", initials: "R", team: "Opp", timers: ["cross-ex"], active: true }, // New
    { role: "Opp Reply", initials: "OR", team: "Opp", timers: ["rebuttal"], active: true }, // Swapped
];

const createAPSpeakerOrder = () => [
@@ -697,24 +705,66 @@
let unlocked = false;
let uploadedSounds = []; // { name: string, url: string }

  const getOrCreateContext = async()=>{
    if(state.muted) { setStatus('muted'); return null; }
    const Ctx = window.AudioContext || window.webkitAudioContext; if(!Ctx){ setStatus('no-audiocontext'); return null; }
    if(!audioCtx){ try{ audioCtx = new Ctx(); }catch{ setStatus('no-audiocontext'); return null; } }
    if(audioCtx && audioCtx.state==='suspended'){ try{ await audioCtx.resume(); }catch{} }
    return audioCtx;
  };

  const playSilent = async()=>{ try{ const a=new Audio(SILENT_WAV); a.muted=true; await a.play(); a.pause(); a.currentTime=0; return true; }catch{ return false; } };
  // DELETING the getOrCreateContext and playSilent functions,
  // as they will be inlined into the new 'unlock' function.

const setStatus = (s)=>{ statusNote.textContent = 'Status: '+s + (state.mode==='mp3' && !state.mp3Url ? ' · Tip: set a public MP3 URL or upload below' : ''); };

  const unlock = async()=>{
    const ctx = await getOrCreateContext();
    const tagOk = await playSilent();
    const ctxOk = !!ctx && ctx.state==='running';
    if(ctxOk || tagOk){ unlocked=true; setStatus(state.mode==='mp3' && !state.mp3Url ? 'armed':'ready'); return true; }
    setStatus('blocked'); return false;
  const unlock = ()=>{
    // This function is now "bulletproof" and based on your suggestion.
    // It will ALWAYS hide the button, even if audio fails.
    
    let synthUnlocked = false;
    let audioTagUnlocked = false;

    // 1. Try to unlock Web Audio (for Synth bell)
    try {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (Ctx) {
        if (!audioCtx) {
          audioCtx = new Ctx(); 
        }
        if (audioCtx && audioCtx.state === 'suspended') {
          // Fire-and-forget resume.
          audioCtx.resume().catch(()=>{ setStatus('resume-fail'); });
        }
        synthUnlocked = true;
      }
    } catch (e) {
      setStatus('synth-unlock-err');
    }

    // 2. Try to unlock <audio> tag (for WAV/MP3 bells)
    //    This uses your suggested method of playing an *existing* element.
    try {
      const silentAudio = $('#silentUnlockAudio'); // Get the new element
      if (silentAudio) {
        const p = silentAudio.play(); // Play the existing element
        if (p && p.catch) {
          p.catch(() => { setStatus('audio-play-fail'); });
        }
        audioTagUnlocked = true;
      }
    } catch (e) {
      setStatus('audio-unlock-err');
    }

    // 3. THIS IS THE CRITICAL PART
    // This code will now run no matter what.
    unlocked = true; 
    enableBtn.style.display = 'none';
    
    if (synthUnlocked && audioTagUnlocked) {
      setStatus('Sound ready.');
    } else if (synthUnlocked) {
      setStatus('Synth ready (MP3/WAV may fail)');
    } else if (audioTagUnlocked) {
      setStatus('MP3/WAV ready (Synth may fail)');
    } else {
      setStatus('Sound failed. Please refresh.');
    }
    
    return true; // Return value doesn't matter, but good practice.
};

const playBell = async(count)=>{
@@ -847,12 +897,15 @@

// Wire up stop button
stopBellBtn.onclick = stopContinuousBell;
  testContBellBtn.onclick = async ()=>{ // Make async
  testContBellBtn.onclick = ()=>{ // No longer async
if(contBellInterval){
stopContinuousBell();
} else {
      await unlock(); // Add await
      if (!unlocked) return; // Check if unlock succeeded
      // await unlock(); // REMOVED
      if (!unlocked) { // Check if unlock succeeded
        setStatus('Please click "Enable Sound" first');
        return; 
      }
contBellInterval = setInterval(()=>playBell(1), 500);
testContBellBtn.textContent = 'Stop';
}
@@ -959,8 +1012,8 @@
};

// Buttons
  startBtn.onclick = async ()=>{ // Make async
    await unlock(); // Add await
  startBtn.onclick = ()=>{ // No longer async
    // await unlock(); // REMOVED
if(raf) { 
pause(); 
startBtn.textContent = 'Start'; 
@@ -970,8 +1023,8 @@
} 
};
resetBtn.onclick = ()=>{ pause(); reset(); startBtn.textContent='Start'; };
  singleBtn.onclick = async ()=>{ await unlock(); playBell(1); }; // Make async and await
  doubleBtn.onclick = async ()=>{ await unlock(); playBell(2); }; // Make async and await
  singleBtn.onclick = ()=>{ playBell(1); }; // No longer async, removed await
  doubleBtn.onclick = ()=>{ playBell(2); }; // No longer async, removed await

// Inputs handlers
const syncFromInputs = ()=>{
@@ -1187,15 +1240,15 @@
const reb = miniTimer(rebInput, rebClock, rebFill, 'rebTime', 2);

// Prep timer buttons
  prepStart.onclick = async ()=>{ await unlock(); if(prepStart.textContent==='Start'){ prep.start(); prepStart.textContent='Pause'; } else { prep.pause(); prepStart.textContent='Start'; } }; // Make async and await
  prepStart.onclick = ()=>{ if(prepStart.textContent==='Start'){ prep.start(); prepStart.textContent='Pause'; } else { prep.pause(); prepStart.textContent='Start'; } }; // No longer async, removed await
prepReset.onclick = ()=>{ prep.reset(); prepStart.textContent='Start'; };

// Rebuttal prep buttons
  cexStart.onclick = async ()=>{ await unlock(); if(cexStart.textContent==='Start'){ cex.start(); cexStart.textContent='Pause'; } else { cex.pause(); cexStart.textContent='Start'; } }; // Make async and await
  cexStart.onclick = ()=>{ if(cexStart.textContent==='Start'){ cex.start(); cexStart.textContent='Pause'; } else { cex.pause(); cexStart.textContent='Start'; } }; // No longer async, removed await
cexReset.onclick = ()=>{ cex.reset(); cexStart.textContent='Start'; };

// Reply timer buttons
  rebStart.onclick = async ()=>{ await unlock(); if(rebStart.textContent==='Start'){ reb.start(); rebStart.textContent='Pause'; } else { reb.pause(); rebStart.textContent='Start'; } }; // Make async and await
  rebStart.onclick = ()=>{ if(rebStart.textContent==='Start'){ reb.start(); rebStart.textContent='Pause'; } else { prep.pause(); prepStart.textContent='Start'; } }; // No longer async, removed await
rebReset.onclick = ()=>{ reb.reset(); rebStart.textContent='Start'; };

// Render main
@@ -1470,3 +1523,11 @@










