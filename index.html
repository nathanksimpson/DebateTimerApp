<!DOCTYPE html>
<!-- saved from url=(0077)file:///Users/nathankellysimpson/Desktop/ChatGPT_Debate_Timer_Final_Base.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Debate Timer — SimsonTimer Final</title>
<style>
  /* ---------- THEME ---------- */
  :root{
    --bg:#f9fafb; --fg:#111827; --card:#ffffff; --bd:#e5e7eb;
    --track:#e5e7eb; --fill:#111827; --muted:#6b7280;
    --ok-bg:#d1fae5; --ok-fg:#065f46; --warn-bg:#fef3c7; --warn-fg:#92400e; --bad-bg:#fee2e2; --bad-fg:#7f1d1d;
    --prop-bg:#dbeafe; --prop-border:#93c5fd; --prop-fg:#1e3a8a;
    --opp-bg:#fee2e2; --opp-border:#fca5a5; --opp-fg:#7f1d1d;
    --prep-bg:#f3f4f6; --prep-border:#d1d5db; --prep-fg:#374151;
    --grace-fg: #7f1d1d; /* Color for grace text in presenter */
    /* NEW: Active/Inverted State Colors */
    --btn-active-bg: #111827;
    --btn-active-fg: #ffffff;
  }
  :root.dark{
    --bg:#1f2937; --fg:#f9fafb; --card:#111827; --bd:#374151;
    --track:#374151; --fill:#f9fafb; --muted:#9ca3af;
    --warn-bg:#78350f; --warn-fg:#fbbf24; --bad-bg:#7f1d1d; --bad-fg:#fca5a5;
    --grace-fg: #f9fafb;
    /* NEW: Active/Inverted State Colors (Dark) */
    --btn-active-bg: #f9fafb;
    --btn-active-fg: #1f2937;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--fg);font:16px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  
  /* --- FIX: App/Presenter Mode Toggle (prevents FOUC) --- */
  /* Hide both roots by default */
  #mainAppRoot, #presenterRoot {
    display: none;
  }
  /* Show main app when in main mode */
  body.main-mode #mainAppRoot {
    display: block;
  }
  /* Hide main app in presenter mode (explicit) */
  body.presenter-mode #mainAppRoot {
    display: none !important;
  }
  /* Show presenter root when in presenter mode */
  body.presenter-mode #presenterRoot {
    display: flex; /* Use flex to center it */
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    text-align: center;
  }
  /* --- End App/Presenter Mode Toggle --- */

  .wrap{min-height:100%;display:flex;flex-direction:column;gap:24px;align-items:center;padding:24px}
  .container{width:100%;max-width:1100px;display:flex;flex-direction:column;gap:16px}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
  h1{font-size:24px;margin:0}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .btn{appearance:none;border:1px solid var(--bd);background:var(--card);color:var(--fg);border-radius:12px;padding:10px 14px;cursor:pointer;font-weight:700}
  .btn:active{transform:translateY(1px)}
  .card{background:var(--card);border:1px solid var(--bd);border-radius:16px;padding:16px}
  .muted{color:var(--muted)}
  .clock{font-family: "Rubik", ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; font-size:76px; font-weight:900; text-align:center; line-height:1.08; letter-spacing:1px}
  .progress{height:14px;background:var(--track);border-radius:999px;position:relative;overflow:hidden;touch-action:none}
  .fill{position:absolute;inset:0;transform-origin:left center;background:var(--fill);transform:scaleX(0)}
  .grid{display:grid;gap:12px}
  .grid-4{grid-template-columns:repeat(4,minmax(0,1fr))}
  .grid-3{grid-template-columns:repeat(3,minmax(0,1fr))}
  .label{display:flex;flex-direction:column;gap:6px}
  input.input, select.input, textarea.input{padding:10px 12px;border-radius:10px;border:1px solid var(--bd);background:var(--card);color:var(--fg)}
  .note{font-size:14px;color:var(--muted)}
  .speaker-progress{display:grid;gap:9px;padding:6px 4px;grid-template-columns:repeat(auto-fit,minmax(140px,1fr))}
  .spk{font-size:13px;font-weight:800;padding:10px 10px;border-radius:10px;background:var(--card);border:2px solid var(--bd);cursor:grab;user-select:none;min-width:0;text-align:center;display:flex;align-items:center;justify-content:center}
  .spk.inactive{opacity:.4;text-decoration:line-through}
  
  /* --- NEW: Inverted Active Speaker --- */
  .spk.prop{background:var(--prop-bg);border-color:var(--prop-border);color:var(--prop-fg)}
  .spk.prop.active { background: var(--prop-fg); color: var(--prop-bg); }
  
  .spk.opp{background:var(--opp-bg);border-color:var(--opp-border);color:var(--opp-fg)}
  .spk.opp.active { background: var(--opp-fg); color: var(--opp-bg); }
  
  .spk.prep{background:var(--prep-bg);border-color:var(--prep-border);color:var(--prep-fg)}
  .spk.prep.active { background: var(--prep-fg); color: var(--prep-bg); }
  /* --- End Inverted Active Speaker --- */
  
  /* Modals */
  #helpModal, #confirmModal {position:fixed;inset:0;background:rgba(0,0,0,.5);display:none;align-items:center;justify-content:center;padding:16px;z-index:100}
  #helpModal .card, #confirmModal .card {max-width:760px;max-height:90vh;overflow:auto}
  #confirmModal .card { max-width: 400px; }
  
  @media (max-width:800px){.grid-3{grid-template-columns:repeat(2,minmax(0,1fr))}.grid-4{grid-template-columns:repeat(2,minmax(0,1fr))}}
  @media (max-width:540px){.grid-3{grid-template-columns:1fr}.grid-4{grid-template-columns:1fr}.clock{font-size:56px}}
  
  /* Hideable settings/timers/notes panel */
  #settingsPanel, #quickTimersPanel {
    overflow: hidden;
    max-height: 1000px; /* Default open height for transition */
    transition: max-height 0.35s ease;
  }
  /* Fix: Notes panel transition (was getting cut off) */
  #notesPanel {
    overflow: hidden;
    transition: max-height 0.35s ease, padding-top 0.35s ease, padding-bottom 0.35s ease, border-width 0.35s ease;
    max-height: 500px; /* Default open height */
    padding: 16px;
    border-width: 1px;
  }

  /* STATE COLORS VIA BODY CLASSES */
  body.state-warn{background:var(--warn-bg); color:var(--warn-fg)}
  body.state-bad{background:var(--bad-bg); color:var(--bad-fg)}
  body.state-warn .card, body.state-bad .card{border-color: currentColor}
  body.state-grace{animation:pulseGrace 2.4s ease-in-out infinite}
  @keyframes pulseGrace{0%{background:var(--bg)}50%{background:var(--bad-bg)}100%{background:var(--bg)}}
  
  /* Icon Buttons Base */
  .btn-icon {
    width: 46px; /* 10px*2 padding + 24px icon + 2px border */
    height: 46px;
    padding: 10px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
    flex-shrink: 0;
  }
  .btn-icon svg {
    width: 24px;
    height: 24px;
  }
  
  /* NEW: Active/Inverted State for *any* button */
  .btn.active {
    background: var(--btn-active-bg);
    color: var(--btn-active-fg);
  }
  /* Make active inverted icons readable */
  .btn.active svg {
    stroke: var(--btn-active-fg);
  }
  
  /* Help modal styling */
  .help-card {
    max-width: 820px;
    width: min(100%, 820px);
  }
  .help-content {
    display: flex;
    flex-direction: column;
    gap: 24px;
  }
  .help-section {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .help-section h3 {
    margin: 0;
    font-size: 1rem;
    color: var(--fg);
  }
  .help-list {
    list-style: none;
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  .help-entry {
    display: flex;
    gap: 12px;
    align-items: flex-start;
  }
  .help-entry .help-copy {
    font-size: 0.95rem;
    line-height: 1.5;
  }
  .help-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    border: 1px solid var(--bd);
    border-radius: 12px;
    background: var(--card);
    width: 46px;
    height: 46px;
    color: var(--fg);
  }
  .help-icon svg {
    width: 24px;
    height: 24px;
  }
  .help-icon-chip {
    font-weight: 700;
    font-size: 0.75rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
  }
  .help-icon-slider {
    width: 46px;
    height: 46px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    border: 1px solid var(--bd);
    border-radius: 12px;
    background: var(--card);
    pointer-events: none;
  }
  .help-icon-slider .slider-track {
    width: 26px;
    height: 4px;
    border-radius: 999px;
    background: var(--bd);
    position: relative;
  }
  .help-icon-slider .slider-thumb {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: var(--fg);
    position: absolute;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
  }
  .help-icon-group {
    display: inline-flex;
    gap: 6px;
    min-width: 46px;
    flex-wrap: wrap;
  }
  .help-icon-group .btn,
  .help-icon-group .help-chip {
    pointer-events: none;
  }
  .help-chip {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 6px 12px;
    border: 1px solid var(--bd);
    border-radius: 999px;
    background: var(--card);
    font-size: 0.78rem;
    font-weight: 600;
    letter-spacing: 0.02em;
    pointer-events: none;
    color: var(--fg);
  }
  @media (max-width: 640px) {
    .help-entry {
      gap: 10px;
    }
    .help-icon,
    .help-icon-slider {
      width: 40px;
      height: 40px;
    }
    .help-card {
      padding: 20px;
    }
  }
  
  /* FIX: Readability for Header Icons */
  /* Default header icons to be outlines */
  #helpBtn svg, #themeBtn svg, #presenterBtn svg, #mirrorBtn svg, #toggleQuickTimers svg, #toggleNotesBtn svg {
    fill: none;
    stroke: currentColor;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  /* Specific icons that *should* be filled */
  /* FIX: Swapped moon/sun */
  .dark #themeBtn .icon-light, /* Sun in dark mode */
  #themeBtn .icon-dark, /* Moon in light mode */
  #muteBtn svg { /* Mute button icons */
    fill: currentColor;
    stroke: none;
  }
  
  /* Theme button logic */
  #themeBtn .icon-light { display: none; } /* Hide sun in light mode */
  .dark #themeBtn .icon-light { display: inline-block; } /* Show sun in dark mode */
  .dark #themeBtn .icon-dark { display: none; } /* Hide moon in dark mode */
  
  /* Mute button logic - standard icon switch, no color inversion */
  #muteBtn .icon-muted { display: none; }
  #muteBtn.muted .icon-unmuted { display: none; }
  #muteBtn.muted .icon-muted { display: inline-block; }
  /* Prevent active class from causing color inversion on mute button */
  #muteBtn.active {
    background: var(--card);
    color: var(--fg);
  }
  
  /* NEW: Slash-through icons for toggles */
  #toggleQuickTimers .icon-no-slash { display: none; }
  #toggleQuickTimers.active .icon-slash { display: none; }
  #toggleQuickTimers.active .icon-no-slash { display: inline-block; }
  
  /* Notes icon states */
  #toggleNotesBtn .icon-slash { display: none; }
  #toggleNotesBtn .icon-empty { display: inline-block; }
  /* Corner indicator hidden by default */
  #toggleNotesBtn .corner-indicator {
    display: none;
  }
  /* Hide note lines when there are no notes */
  #toggleNotesBtn:not(.has-notes) .note-line {
    display: none;
  }
  
  /* When panel is OPEN, show icon with corner indicator */
  #toggleNotesBtn:not(.panel-hidden) .icon-empty { display: none; }
  #toggleNotesBtn:not(.panel-hidden) .icon-slash { 
    display: inline-block !important;
    visibility: visible !important;
  }
  
  /* Closed and no notes: White BG, 50% Grey Note Icon */
  #toggleNotesBtn.panel-hidden:not(.has-notes) svg {
    stroke: #6b7280;
    opacity: 1;
  }
  #toggleNotesBtn.panel-hidden:not(.has-notes) .corner-indicator {
    display: none;
  }
  /* Dark mode: use lighter grey */
  .dark #toggleNotesBtn.panel-hidden:not(.has-notes) svg {
    stroke: #9ca3af;
    opacity: 1;
  }
  
  /* Open and no notes: Darkened BG, 50% Grey Note Icon with corner indicator */
  #toggleNotesBtn:not(.panel-hidden):not(.has-notes) {
    background: var(--bd) !important;
  }
  /* Use darker grey/black for visibility against grey background */
  #toggleNotesBtn:not(.panel-hidden):not(.has-notes) svg {
    stroke: #374151 !important;
    opacity: 1 !important;
  }
  /* Corner indicator: dark in light mode */
  #toggleNotesBtn:not(.panel-hidden):not(.has-notes) .corner-indicator {
    fill: #1f2937 !important;
    stroke: none !important;
    display: block !important;
  }
  /* Dark mode: use lighter color for visibility against darker grey background */
  .dark #toggleNotesBtn:not(.panel-hidden):not(.has-notes) svg {
    stroke: #d1d5db !important;
    opacity: 1 !important;
  }
  /* Corner indicator: light in dark mode */
  .dark #toggleNotesBtn:not(.panel-hidden):not(.has-notes) .corner-indicator {
    fill: #f3f4f6 !important;
    stroke: none !important;
    display: block !important;
  }
  
  /* Closed and has notes: White BG with black note icon */
  #toggleNotesBtn.panel-hidden.has-notes svg {
    stroke: var(--fg);
    opacity: 1;
  }
  #toggleNotesBtn.panel-hidden.has-notes .corner-indicator {
    display: none;
  }
  
  /* Open with notes: Darkened BG with black notes icon and corner indicator */
  #toggleNotesBtn:not(.panel-hidden).has-notes {
    background: var(--bd) !important;
  }
  #toggleNotesBtn:not(.panel-hidden).has-notes svg {
    stroke: var(--fg);
    opacity: 1;
  }
  /* Corner indicator: dark in light mode */
  #toggleNotesBtn:not(.panel-hidden).has-notes .corner-indicator {
    fill: #1f2937 !important;
    stroke: none !important;
    display: block !important;
  }
  /* Corner indicator: light in dark mode */
  .dark #toggleNotesBtn:not(.panel-hidden).has-notes .corner-indicator {
    fill: #f3f4f6 !important;
    stroke: none !important;
    display: block !important;
  }
  
  /* Note: var(--fg) automatically inverts in dark mode (black->white), opacity stays consistent */

  /* Main Timer Button Logic */
  /* This holds the Start/Pause text */
  .btn-main-timer {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    padding-top: 12px;
    padding-bottom: 12px;
    width: 72px; /* Fixed width */
    height: auto;
  }
  .btn-main-timer .label-text {
    font-size: 11px;
    font-weight: 700;
  }
  #startBtn.running .icon-play { display: none; }
  #startBtn.running .icon-pause { display: block; }
  #startBtn .icon-pause { display: none; }
  #startBtn .icon-play { display: block; }
  /* Main timer icons should be fill */
  #startBtn svg, #singleBtn svg, #doubleBtn svg, #stopBellBtn svg {
    fill: currentColor;
    stroke: none;
  }
  /* Fix for reset/cont bell which are outlines */
  #resetBtn svg, #testContBtn svg {
    fill: none;
    stroke: currentColor;
    stroke-width: 2.5;
  }
  /* Fix: Thinner stroke for continuous bell inner icon */
  #testContBtn svg:last-child {
    stroke-width: 2.8;
  }


  /* Presenter grace mode */
  .presenter-grace #pClock { color: var(--grace-fg); }
  .presenter-grace { animation: gracePulse 1.6s ease-in-out infinite !important; }
  @keyframes gracePulse {
    0% { background: var(--bg); color: var(--fg); }
    50% { background: var(--bad-bg); color: var(--bad-fg); }
    100% { background: var(--bg); color: var(--fg); }
  }
  .presenter-grace.state-grace #pClock {
    color: var(--bad-fg);
  }
  
  /* --- Presenter Mode Root Styles --- */
  #pClock {
    font-family: "Rubik", ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    font-weight: 900;
    font-size: 22vw;
    line-height: 1;
    letter-spacing: 2px;
  }
  #pMeta {
    margin-top: 12px;
    color: var(--muted);
    font-weight: 700;
    font-size: 2vw; /* Make meta text responsive */
  }
  
  /* --- Mirror Mode Styles --- */
  body.mirror-mode .wrap {
    padding: 24px; /* Keep some padding */
  }
  body.mirror-mode .container {
    max-width: 100%; /* Allow main card to be centered */
  }
  /* Hide everything except the main timer card */
  body.mirror-mode #mainAppRoot header,
  body.mirror-mode #notesPanel, /* HIDE NOTES IN MIRROR MODE */
  body.mirror-mode #quickTimersPanel,
  body.mirror-mode #mainAppRoot .card:last-child { /* Settings card */
    display: none;
  }
  body.mirror-mode.mirror-show-speakers #mainAppRoot .card:first-child {
    margin-top: 96px;
  }
  /* --- Bigger Mirror Mode Timer --- */
  body.mirror-mode #mainCard { /* Target main card specifically */
    border: none;
    box-shadow: none;
    background: transparent;
    padding: 0;
  }
  body.mirror-mode #exitMirrorBtn {
    display: block !important;
    position: fixed;
    top: 24px;
    right: 24px;
    z-index: 100;
  }
  #toggleMirrorSpeakers {
    display: none;
    position: fixed;
    top: 24px;
    right: 80px;
    left: auto;
    z-index: 100;
  }
  body.mirror-mode #toggleMirrorSpeakers {
    display: block !important;
  }
  body.mirror-mode #toggleMirrorSpeakers.active {
    background: var(--btn-active-bg);
    color: var(--btn-active-fg);
  }
  body.mirror-mode #clock {
    font-size: 20vw; /* Make it huge like presenter mode */
    font-size: clamp(76px, 20vw, 220px); /* Add clamp for usability */
    line-height: 1;
    margin-top: 24px; /* Add some space */
  }
  
</style>
<link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin="">
<link href="./Debate Timer — SimsonTimer Cursor Version_files/css2" rel="stylesheet">
</head>
<body class="main-mode">

  <!-- 
    FIX: This root is for the main application. 
    It will be hidden if `?presenter=true` is in the URL.
  -->
  <div id="mainAppRoot">
    <div class="wrap">
      <div class="container">
        <header>
          <!-- Title removed for space -->
          <div class="row">
            <label class="label">
              <span style="font-weight:700" data-lang-key="debateStyle">Debate Style</span>
              <select id="formatSelect" class="input">
                <option value="AP">AP</option>
                <option value="BP">BP</option>
                <option value="WSDC">WSDC</option>
                <option value="PF">PF</option>
                <option value="CX">Policy / CX</option>
                <option value="LD">Lincoln–Douglas</option>
                <option value="SIMSON">Simson</option>
                <option value="CUSTOM">Custom</option>
              </select>
            </label>
            <label class="label" style="flex-direction:row;align-items:center;gap:8px; margin-top: 18px;">
              <span style="font-weight:700" data-lang-key="volume">Volume</span>
              <input id="volume" type="range" min="0" max="1" step="0.05" value="0.6" style="min-width: 80px;">
            </label>
            <label class="label" style="flex-direction:row;align-items:center;gap:8px; margin-top: 18px;">
              <span style="font-weight:700" data-lang-key="lang">Lang</span>
              <select id="langSelect" class="input" style="padding-top:10px; padding-bottom:10px;">
                <option value="en">English</option>
                <option value="ko">한국어</option>
              </select>
            </label>
          </div>
          <div class="row" style="margin-top: 18px;">
            <button id="helpBtn" class="btn btn-icon" title="Help (H)">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
            </button>
            <button id="themeBtn" class="btn btn-icon" title="Toggle Dark Mode (D)">
              <!-- FIX: Swapped moon/sun -->
              <svg class="icon-dark" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
              <svg class="icon-light" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke="none">
                <circle cx="12" cy="12" r="4"></circle>
                <polygon points="12,0 13,4 11,4"></polygon>
                <polygon points="12,24 13,20 11,20"></polygon>
                <polygon points="0,12 4,13 4,11"></polygon>
                <polygon points="24,12 20,13 20,11"></polygon>
                <polygon points="3.5,3.5 5.5,5.5 4.5,6.5 2.5,4.5"></polygon>
                <polygon points="20.5,20.5 22.5,22.5 21.5,23.5 19.5,21.5"></polygon>
                <polygon points="3.5,20.5 5.5,18.5 4.5,17.5 2.5,19.5"></polygon>
                <polygon points="20.5,3.5 22.5,5.5 21.5,6.5 19.5,4.5"></polygon>
              </svg>
            </button>
            <button id="presenterBtn" class="btn btn-icon" title="Presenter Mode (P)">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>
            </button>
            <button id="mirrorBtn" class="btn btn-icon" title="Mirror Mode">
              <!-- Mirror/Display Icon (OS-style: two overlapping displays) -->
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 100%; height: 100%;">
                <g transform="translate(12, 12) scale(0.85) translate(-12, -12)">
                  <rect x="1" y="2" width="11" height="9" rx="1" opacity="0.5"></rect>
                  <rect x="11" y="5.5" width="11" height="9" rx="1"></rect>
                  <line x1="3" y1="11" x2="3" y2="13"></line>
                  <line x1="5" y1="11" x2="5" y2="13"></line>
                  <line x1="13" y1="14.5" x2="13" y2="16.5"></line>
                  <line x1="15" y1="14.5" x2="15" y2="16.5"></line>
                  <line x1="17" y1="14.5" x2="17" y2="16.5"></line>
                  <line x1="19" y1="14.5" x2="19" y2="16.5"></line>
                </g>
              </svg>
            </button>
            <button id="toggleQuickTimers" class="btn btn-icon" title="Show Quick Timers">
              <!-- NEW: Slash icon logic -->
              <svg class="icon-slash" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 4v6h6"></path><path d="M3.4 14A9 9 0 1 0 3.4 6V4"></path><path d="M12 7v6l4 2"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>
              <svg class="icon-no-slash" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 4v6h6"></path><path d="M3.4 14A9 9 0 1 0 3.4 6V4"></path><path d="M12 7v6l4 2"></path></svg>
            </button>
            <button id="toggleNotesBtn" class="btn btn-icon panel-hidden has-notes" title="Show Speaker Notes">
              <!-- Notes icon: outline version -->
              <svg class="icon-empty" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line class="note-line" x1="16" y1="13" x2="8" y2="13"></line>
                <line class="note-line" x1="16" y1="17" x2="8" y2="17"></line>
                <polyline class="note-line" points="10 9 9 9 8 9"></polyline>
              </svg>
              <svg class="icon-slash" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line class="note-line" x1="16" y1="13" x2="8" y2="13"></line>
                <line class="note-line" x1="16" y1="17" x2="8" y2="17"></line>
                <polyline class="note-line" points="10 9 9 9 8 9"></polyline>
                <!-- Corner indicator: dark in light mode, light in dark mode -->
                <rect class="corner-indicator" x="18" y="2" width="4" height="4" rx="1"></rect>
              </svg>
            </button>
            <button id="muteBtn" class="btn btn-icon" title="Mute (M)">
              <svg class="icon-unmuted" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M11 5L6 9H2v6h4l5 4V5z"></path><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
              <svg class="icon-muted" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke="none"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path><path d="M1 1l22 22" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" fill="none"></path></svg>
            </button>
          </div>
        </header>
  
        <!-- Speaker Progress --><div class="card">
          <div style="font-weight:800;margin-bottom:8px" data-lang-key="spkProgress">Speaker Progress</div>
          <div id="spkBar" class="speaker-progress"><div class="spk prep active" draggable="true" data-idx="0">Round Prep</div><div class="spk prop" draggable="true" data-idx="1">PM</div><div class="spk prep" draggable="true" data-idx="2">Prep</div><div class="spk opp" draggable="true" data-idx="3">LO</div><div class="spk prep" draggable="true" data-idx="4">Prep</div><div class="spk prop" draggable="true" data-idx="5">DPM</div><div class="spk prep" draggable="true" data-idx="6">Prep</div><div class="spk opp" draggable="true" data-idx="7">DLO</div><div class="spk prep" draggable="true" data-idx="8">Prep</div><div class="spk prop" draggable="true" data-idx="9">GW</div><div class="spk prep" draggable="true" data-idx="10">Prep</div><div class="spk opp" draggable="true" data-idx="11">OW</div><div class="spk prep" draggable="true" data-idx="12">Prep</div><div class="spk prop" draggable="true" data-idx="13">GR</div><div class="spk prep" draggable="true" data-idx="14">Prep</div><div class="spk opp" draggable="true" data-idx="15">OR</div></div>
          <div class="row" style="justify-content:space-between;margin-top:8px">
            <div class="row">
              <button id="prevBtn" class="btn" data-lang-key="prev">Previous</button>
              <button id="nextBtn" class="btn" data-lang-key="next">Next</button>
            </div>
            <button id="resetOrder" class="btn" data-lang-key="resetOrder">Reset Order</button>
          </div>
          <div class="note" data-lang-key="spkNote">Click = select • Double-click = toggle active • Drag = reorder</div>
        </div>
  
        <!-- Main Timer Card --><div class="card" id="mainCard">
          <div class="row" style="justify-content:space-between"><div id="mainTitle" style="font-weight:800">Round Prep</div><div id="meta" class="muted">Prep</div></div>
          <button id="toggleMirrorSpeakers" class="btn btn-icon" title="Show Speaker Progress" aria-pressed="false">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <rect x="3" y="4" width="18" height="16" rx="2" ry="2"></rect>
              <line x1="3" y1="10" x2="21" y2="10"></line>
              <line x1="9" y1="2" x2="9" y2="6"></line>
              <line x1="15" y1="2" x2="15" y2="6"></line>
            </svg>
          </button>
          <button id="exitMirrorBtn" class="btn btn-icon" style="display:none;position:fixed;top:24px;right:24px;z-index:100" title="Exit Mirror Mode">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
          <div id="clock" class="clock">20:00</div>
          <div id="mainProgress" class="progress"><div id="fill" class="fill" style="transform: scaleX(0);"></div></div>
          <div class="row" style="justify-content:center;margin-top:10px">
            <button id="startBtn" class="btn btn-main-timer" title="Start/Pause (Space)">
              <svg class="icon-play" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 4l12 8-12 8V4z"></path></svg>
              <svg class="icon-pause" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"></path></svg>
              <span class="label-text" data-lang-key="start">Start</span>
            </button>
            <button id="resetBtn" class="btn btn-main-timer" title="Reset (R)">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path d="M1 4v6h6"></path>
                <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
              </svg>
              <span class="label-text" data-lang-key="reset">Reset</span>
            </button>
            <button id="singleBtn" class="btn btn-main-timer" title="Single Bell (1)">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path></svg>
              <span class="label-text" data-lang-key="single">Single</span>
            </button>
            <button id="doubleBtn" class="btn btn-main-timer" title="Double Bell (2)">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path></svg>
              <span class="label-text" data-lang-key="double">Double</span>
            </button>
            <button id="testContBtn" class="btn btn-main-timer" title="Start continuous bell test">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path d="M1 4v6h6"></path>
                <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
              </svg>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="width: 19px; height: 19px; margin-left: -6px; margin-top: -2px;">
                <path d="M10 10C6 10 6 14 10 14c4 0 4-4 8-4 4 0 4 4 0 4s-4-4-8-4z"></path>
              </svg>
              <span class="label-text" data-lang-key="continuous">Continuous</span>
            </button>
            <button id="stopBellBtn" class="btn btn-main-timer" title="Stop continuous bell">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13.73 21a2 2 0 0 1-3.46 0"></path><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="m1 1 22 22"></path></svg>
              <span class="label-text" data-lang-key="stopBell">Stop Bell</span>
            </button>
          </div>
          <div class="note"><strong data-lang-key="status">Status:</strong> <span id="status">Successfully purged 2 custom format(s)</span></div>
        </div>
        
        <!-- NEW Notes Card (Hideable) -->
        <div id="notesPanel" class="card" style="max-height: 0px; padding-top: 0px; padding-bottom: 0px; border-width: 0px;">
          <div class="row" style="justify-content:space-between; align-items:flex-start; margin-bottom:12px">
            <div style="font-weight:800" data-lang-key="speakerNotes">Speaker Notes</div>
            <div class="row" style="gap:8px">
              <button id="exportNotesBtn" class="btn" style="padding:6px 10px;font-size:14px" data-lang-key="exportNotes">Export Notes</button>
              <button id="importNotesBtn" class="btn" style="padding:6px 10px;font-size:14px" data-lang-key="importNotes">Import Notes</button>
              <button id="clearNotesBtn" class="btn" style="padding:6px 10px;font-size:14px" data-lang-key="clearAllNotes">Clear All Notes</button>
            </div>
          </div>
          <textarea id="notesArea" class="input" style="width:100%;min-height:110px;font:inherit" data-lang-key="notesPlaceholder" placeholder="" disabled="">Type notes for the current speaker...</textarea>
          <input id="importNotesFile" type="file" accept="application/json" style="display:none">
        </div>
  
        <!-- Quick Timers --><div id="quickTimersPanel" class="grid grid-4" style="max-height: 0px;">
          <div class="card">
            <div style="font-weight:800;margin-bottom:6px" data-lang-key="crossEx">Cross-Ex / Shared</div>
            <div id="cexClock" class="clock" style="font-size:32px">1:00</div>
            <div class="progress" style="margin-top:8px"><div id="cexFill" class="fill" style="transform: scaleX(0);"></div></div>
            <div class="row" style="justify-content:center;margin-top:8px"><button id="cexStart" class="btn" data-lang-key="start">Start</button><button id="cexReset" class="btn" data-lang-key="reset">Reset</button></div>
          </div>
          <div class="card">
            <div style="font-weight:800;margin-bottom:6px" data-lang-key="rebuttal">Rebuttal / Reply</div>
            <div id="rebClock" class="clock" style="font-size:32px">3:00</div>
            <div class="progress" style="margin-top:8px"><div id="rebFill" class="fill" style="transform: scaleX(0);"></div></div>
            <div class="row" style="justify-content:center;margin-top:8px"><button id="rebStart" class="btn" data-lang-key="start">Start</button><button id="rebReset" class="btn" data-lang-key="reset">Reset</button></div>
          </div>
          <div class="card">
            <div style="font-weight:800;margin-bottom:6px" data-lang-key="prep">Prep</div>
            <div id="prepClock" class="clock" style="font-size:32px">1:00</div>
            <div class="progress" style="margin-top:8px"><div id="prepFill" class="fill" style="transform: scaleX(0);"></div></div>
            <div class="row" style="justify-content:center;margin-top:8px"><button id="prepStart" class="btn" data-lang-key="start">Start</button><button id="prepReset" class="btn" data-lang-key="reset">Reset</button></div>
          </div>
          <div class="card">
            <div style="font-weight:800;margin-bottom:6px" data-lang-key="poi">POI</div>
            <div id="poiClock" class="clock" style="font-size:32px">0:15</div>
            <div class="progress" style="margin-top:8px"><div id="poiFill" class="fill" style="transform: scaleX(0);"></div></div>
            <div class="row" style="justify-content:center;margin-top:8px"><button id="poiStart" class="btn" data-lang-key="start">Start</button><button id="poiReset" class="btn" data-lang-key="reset">Reset</button></div>
          </div>
        </div>
  
        <!-- Settings (hideable) --><div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px"><span style="font-weight:800;" data-lang-key="settingsTitle">Timer Settings</span><button id="toggleSettings" class="btn" style="padding:6px 10px;font-size:14px" data-lang-key="hide">Show</button></div>
          <div id="settingsPanel" style="max-height: 0px;">
            <div class="grid grid-4">
              <label class="label"><span data-lang-key="mainTime">Main (m:ss)</span><input id="mainInput" class="input" value="3:00"></label>
              <label class="label"><span data-lang-key="firstBell">1st Bell from start (m:ss)</span><input id="firstInput" class="input" value="1:00"></label>
              <label class="label"><span data-lang-key="secondBell">2nd Bell from start (m:ss)</span><input id="secondInput" class="input" value="2:00"></label>
              <label class="label"><span data-lang-key="gracePeriod">Grace Period (m:ss)</span><input id="graceInput" class="input" value="0:30"></label>
              <label class="label"><span data-lang-key="yellowAt">Yellow at remaining (m:ss)</span><input id="yellowInput" class="input" value="1:00"></label>
              <label class="label"><span data-lang-key="redAt">Red at remaining (m:ss)</span><input id="redInput" class="input" value="0:30"></label>
              <label class="label"><span data-lang-key="prepTime">Prep Time (m:ss)</span><input id="prepInput" class="input" value="1:00"></label>
              <label class="label"><span data-lang-key="crossExTime">Cross-Ex (m:ss)</span><input id="cexInput" class="input" value="1:00"></label>
              <label class="label"><span data-lang-key="rebuttalTime">Rebuttal (m:ss)</span><input id="rebInput" class="input" value="3:00"></label>
              <label class="label"><span data-lang-key="poiTime">POI Time (m:ss)</span><input id="poiInput" class="input" value="0:15"></label>
              <label class="label"><span data-lang-key="bellSpacing">Bell spacing (ms)</span><input id="spaceInput" class="input" value="250"></label>
            </div>
            <div class="row" style="margin-top:12px;gap:8px;flex-wrap:wrap">
              <button id="exportBtn" class="btn" data-lang-key="exportSettings">Export Settings</button>
              <button id="importBtn" class="btn" data-lang-key="importSettings">Import Settings</button>
              <button id="purgeCustomFormatsBtn" class="btn" style="background: #dc2626; color: white;">Purge Custom Formats</button>
              <input id="importFile" type="file" accept="application/json" style="display:none">
            </div>
            <div class="row" style="margin-top:8px;gap:8px;flex-wrap:wrap">
              <button id="enableBtn" class="btn" data-lang-key="initSound" style="padding: 8px 12px; font-size: 0.85em; opacity: 0.7;">Initialize Sound</button>
            </div>
          </div>
        </div>
  
      </div>
    </div>
  </div><!-- End #mainAppRoot -->

  <!-- 
    FIX: This root is for the PRESENTER view. 
    It is hidden by default and will be shown if `?presenter=true` is in the URL.
  -->
  <div id="presenterRoot">
    <div class="presenter-wrap">
      <div id="pClock">00:00</div>
      <div id="pMeta">Presenter</div>
    </div>
  </div>

  <!-- Help Modal (lives outside main app root) --><div id="helpModal">
    <div class="card help-card">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
        <h2 style="margin:0" data-lang-key="helpTitle">Help &amp; Features</h2>
        <button id="closeHelp" class="btn btn-icon" title="Close" style="padding: 8px;">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 20px; height: 20px;">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <hr style="border:0;border-top:1px solid var(--bd);margin:12px 0">

      <div class="help-content">
        <div class="help-section">
          <h3 data-lang-key="helpHeaderButtons">Header Buttons</h3>
          <ul class="help-list">
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                  <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpInitSound"><strong>Sound:</strong> Audio initializes automatically on any interaction (click, touch, or key press). If sound doesn't work, use the failsafe button in Settings panel.</div>
            </li>
            <li class="help-entry">
              <span class="help-icon help-icon-chip" aria-hidden="true">AP</span>
              <div class="help-copy" data-lang-key="helpDebateStyle"><strong>Debate Style:</strong> Select your format (AP, BP, etc.). This loads all speakers and default times.</div>
            </li>
            <li class="help-entry">
              <span class="help-icon-slider" aria-hidden="true">
                <span class="slider-track"><span class="slider-thumb"></span></span>
              </span>
              <div class="help-copy" data-lang-key="helpVolume"><strong>Volume:</strong> Controls the bell sound level.</div>
            </li>
            <li class="help-entry">
              <span class="help-icon help-icon-chip" aria-hidden="true">EN</span>
              <div class="help-copy" data-lang-key="helpLang"><strong>Lang:</strong> Switches between English and Korean.</div>
            </li>
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="12" cy="12" r="10"></circle>
                  <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                  <line x1="12" y1="17" x2="12.01" y2="17"></line>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpHelp"><strong>Help:</strong> Opens this help window. (Shortcut: H)</div>
            </li>
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpTheme"><strong>Theme:</strong> Toggles Dark/Light mode. (Shortcut: D)</div>
            </li>
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
                  <line x1="8" y1="21" x2="16" y2="21"></line>
                  <line x1="12" y1="17" x2="12" y2="21"></line>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpPresenter"><strong>Presenter:</strong> Opens a large, clean timer in a new window for an external display. (Shortcut: P)</div>
            </li>
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <g transform="translate(12, 12) scale(0.85) translate(-12, -12)">
                    <rect x="1" y="2" width="11" height="9" rx="1" opacity="0.5"></rect>
                    <rect x="11" y="5.5" width="11" height="9" rx="1"></rect>
                    <line x1="3" y1="11" x2="3" y2="13"></line>
                    <line x1="5" y1="11" x2="5" y2="13"></line>
                    <line x1="13" y1="14.5" x2="13" y2="16.5"></line>
                    <line x1="15" y1="14.5" x2="15" y2="16.5"></line>
                    <line x1="17" y1="14.5" x2="17" y2="16.5"></line>
                    <line x1="19" y1="14.5" x2="19" y2="16.5"></line>
                  </g>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpMirror"><strong>Mirror:</strong> Hides all controls on the main screen. Use this when *mirroring* your device to a display. <strong>Click the X button to exit.</strong></div>
            </li>
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M3 4v6h6"></path>
                  <path d="M3.4 14A9 9 0 1 0 3.4 6V4"></path>
                  <path d="M12 7v6l4 2"></path>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpQuickTimers"><strong>Quick Timers:</strong> Shows/hides the extra timers (Cross-Ex, Prep, etc.). Icon has a slash when hidden.</div>
            </li>
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                  <polyline points="14 2 14 8 20 8"></polyline>
                  <line x1="16" y1="13" x2="8" y2="13"></line>
                  <line x1="16" y1="17" x2="8" y2="17"></line>
                  <polyline points="10 9 9 9 8 9"></polyline>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpNotes"><strong>Notes:</strong> Shows/hides the speaker notes panel. Icon has a slash when hidden. Lights up if the current speaker has notes.</div>
            </li>
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                  <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                  <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                  <path d="M1 1l22 22" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" fill="none"></path>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpMute"><strong>Mute:</strong> Toggles all bell sounds on/off. (Shortcut: M)</div>
            </li>
          </ul>
        </div>

        <div class="help-section">
          <h3 data-lang-key="helpSpeakerProgress">Speaker Progress</h3>
          <ul class="help-list">
            <li class="help-entry">
              <span class="help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M3 2.5l7.4 18.5 1.9-6.5 6.7-1.8L3 2.5z"></path>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpSpkClick"><strong>Click:</strong> Selects a speaker without changing the order.</div>
            </li>
            <li class="help-entry">
              <span class="help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M4 3l6.8 17 1.7-6 6.2-1.6L4 3z" opacity="0.6"></path>
                  <path d="M7 4.2l6.8 17 1.7-6 6.2-1.6L7 4.2z"></path>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpSpkDoubleClick"><strong>Double-click:</strong> Toggles a speaker active/inactive (greys them out and skips them).</div>
            </li>
            <li class="help-entry">
              <span class="help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                  <circle cx="8" cy="8" r="1.6"></circle>
                  <circle cx="8" cy="12" r="1.6"></circle>
                  <circle cx="8" cy="16" r="1.6"></circle>
                  <circle cx="12" cy="8" r="1.6"></circle>
                  <circle cx="12" cy="12" r="1.6"></circle>
                  <circle cx="12" cy="16" r="1.6"></circle>
                  <circle cx="16" cy="8" r="1.6"></circle>
                  <circle cx="16" cy="12" r="1.6"></circle>
                  <circle cx="16" cy="16" r="1.6"></circle>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpSpkDrag"><strong>Drag &amp; Drop:</strong> Re-order the entire speaker flow.</div>
            </li>
            <li class="help-entry">
              <span class="help-icon-group" aria-hidden="true">
                <span class="help-chip">Prev</span>
                <span class="help-chip">Next</span>
              </span>
              <div class="help-copy" data-lang-key="helpSpkNextPrev"><strong>Next/Previous:</strong> Moves to the next/previous speaker. (Shortcut: → / ←)</div>
            </li>
          </ul>
        </div>

        <div class="help-section">
          <h3 data-lang-key="helpMainTimer">Main Timer Controls</h3>
          <ul class="help-list">
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M7 4l10 8-10 8V4z"></path>
                  <rect x="14" y="4" width="3" height="16" rx="0.8" opacity="0.35"></rect>
                  <rect x="18" y="4" width="3" height="16" rx="0.8" opacity="0.35"></rect>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpMainStart"><strong>Start/Pause (Play/Pause):</strong> Toggles the main timer. (Shortcut: Space)</div>
            </li>
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M4 4v6h6"></path>
                  <path d="M5.5 15.5a9 9 0 1 0 2-9.5L4 10"></path>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpMainReset"><strong>Reset (Circular Arrow):</strong> Resets the current timer. (Shortcut: R)</div>
            </li>
            <li class="help-entry">
              <span class="help-icon-slider" aria-hidden="true">
                <span class="slider-track"><span class="slider-thumb" style="right: 30%;"></span></span>
              </span>
              <div class="help-copy" data-lang-key="helpMainScrub"><strong>Progress Bar:</strong> Click or drag on the progress bar to "scrub" the timer to any point.</div>
            </li>
            <li class="help-entry">
              <span class="help-icon-group" aria-hidden="true">
                <span class="btn btn-icon help-icon">
                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
                    <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
                  </svg>
                </span>
                <span class="btn btn-icon help-icon">
                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
                    <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
                    <path d="M7 8l10 10" opacity="0.35"></path>
                  </svg>
                </span>
                <span class="btn btn-icon help-icon">
                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
                    <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
                    <path d="M1 1l22 22"></path>
                  </svg>
                </span>
              </span>
              <div class="help-copy" data-lang-key="helpMainBells"><strong>Bell Icons (1, 2, Loop, Mute):</strong> Play bells manually or stop a continuous bell. (Shortcut: 1, 2)</div>
            </li>
          </ul>
        </div>

        <div class="help-section">
          <h3 data-lang-key="helpTimerLogic">Timer Logic</h3>
          <ul class="help-list">
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="12" cy="12" r="9"></circle>
                  <polyline points="12 7 12 12 16 14"></polyline>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpTimerLogicSub"><strong>Substantive Speeches:</strong> Use Main, 1st Bell, 2nd Bell, Yellow/Red, and Grace times.</div>
            </li>
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="12" cy="12" r="9"></circle>
                  <polyline points="12 7 12 12 16 14"></polyline>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpTimerLogicBells">Bells ring at 1st Bell, 2nd Bell, and a double-bell rings at the end (0:00).</div>
            </li>
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="12" cy="12" r="9"></circle>
                  <polyline points="12 7 12 12 16 14"></polyline>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpTimerLogicGrace">After 0:00, the <strong>Grace Period</strong> counts up, and the screen flashes.</div>
            </li>
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="12" cy="12" r="9"></circle>
                  <polyline points="12 7 12 12 16 14"></polyline>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpTimerLogicCont">After the grace period, a <strong>continuous bell</strong> rings until you press "Stop Bell" or "Reset".</div>
            </li>
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="12" cy="12" r="9"></circle>
                  <polyline points="12 7 12 12 16 14"></polyline>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpTimerLogicReply"><strong>Reply Speeches:</strong> Use the "Rebuttal" time and end with a double-bell.</div>
            </li>
          </ul>
        </div>

        <div class="help-section">
          <h3 data-lang-key="helpNotesData">Notes &amp; Data</h3>
          <ul class="help-list">
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M4 4h12l4 4v12H4z"></path>
                  <path d="M14 4v5h6"></path>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpNotesPerSpeaker">Notes are saved per-speaker, per-format (e.g., "AP - Prime Minister").</div>
            </li>
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M4 4h12l4 4v12H4z"></path>
                  <path d="M14 4v5h6"></path>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpNotesExportTxt"><strong>Export Notes:</strong> Saves a ".txt" file of all your notes, organized by format.</div>
            </li>
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M4 4h12l4 4v12H4z"></path>
                  <path d="M14 4v5h6"></path>
                  <path d="M12 12v6"></path>
                  <path d="M9 15h6"></path>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpNotesImport"><strong>Import Notes:</strong> Merges notes from a `.json` file.</div>
            </li>
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M4 4h12l4 4v12H4z"></path>
                  <path d="M14 4v5h6"></path>
                  <path d="M9 15l6 6"></path>
                  <path d="M15 15l-6 6"></path>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpNotesClear"><strong>Clear All Notes:</strong> Deletes all saved notes (with confirmation).</div>
            </li>
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M4 4h12l4 4v12H4z"></path>
                  <path d="M14 4v5h6"></path>
                  <path d="M9 17l3 3 3-3"></path>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpSettingsExport"><strong>Export Settings:</strong> Saves your "Custom" preset and all timer settings to a `.json` file.</div>
            </li>
            <li class="help-entry">
              <span class="btn btn-icon help-icon" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M4 4h12l4 4v12H4z"></path>
                  <path d="M14 4v5h6"></path>
                  <path d="M12 21v-6"></path>
                  <path d="M9 15h6"></path>
                </svg>
              </span>
              <div class="help-copy" data-lang-key="helpSettingsImport"><strong>Import Settings:</strong> Loads a `.json` file as your new "Custom" preset.</div>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Confirmation Modal -->
  <div id="confirmModal">
    <div class="card">
      <h3 id="confirmTitle" style="margin-top:0">Are you sure?</h3>
      <p id="confirmText">This action cannot be undone.</p>
      <div class="row" style="justify-content:flex-end; gap: 12px;">
        <button id="confirmCancel" class="btn" data-lang-key="cancel">Cancel</button>
        <button id="confirmOK" class="btn" style="background:var(--bad-bg);color:var(--bad-fg);border-color:var(--bad-fg)" data-lang-key="ok">OK</button>
      </div>
    </div>
  </div>

<script>
// ---------- GLOBAL Utilities (for main + presenter) ----------
const $ = (s,o=document)=>o.querySelector(s);
const fmt=(ms)=>{ms=Math.max(0,Math.round(ms/1000));const m=Math.floor(ms/60),s=ms%60;return m+":"+(s<10?"0":"")+s};
function setDarkGlobal(on) { document.documentElement.classList.toggle('dark', on); }
function applyBodyState(state){
  document.body.classList.remove('state-warn','state-bad','state-grace');
  if(state) document.body.classList.add(state);
}

(function(){
  // --- FIX: Check for presenter mode *immediately* ---
  const isPresenter = new URLSearchParams(location.search).get('presenter')==='true';

  // --- NEW CSS-based mode toggle ---
  // This runs *before* any content is rendered, preventing FOUC
  if (isPresenter) {
    document.body.classList.add('presenter-mode');
  } else {
    document.body.classList.add('main-mode');
  }
  // --- End new toggle ---

  if(isPresenter){
    // Wait for DOM to be fully ready before setting up sync
    const initPresenter = () => {
      const pc = $('#pClock');
      const pm = $('#pMeta');
      
      if (!pc || !pm) {
        // Elements not ready yet, try again
        setTimeout(initPresenter, 50);
        return;
      }
      
      // Listen for sync messages
      const channel = new BroadcastChannel('debate_timer_sync_v1');
      
      // Signal that presenter window is ready
      channel.postMessage({ type: 'presenter-ready' });
      
      channel.onmessage = (e) => {
        if (!e || !e.data) return;
        const m = e.data;
        
        if (m.type === 'state') {
          try {
            // Apply theme
            if (m.theme) {
              setDarkGlobal(m.theme === 'dark');
            }
            
            // Apply time and meta
            if (pc && m.main && typeof m.main.remain === 'number') {
              pc.textContent = fmt(m.main.remain);
            }
            if (pm) {
              pm.textContent = m.meta || 'Presenter';
            }
            
            // Apply grace pulse
            if (typeof m.inGrace === 'boolean') {
              document.body.classList.toggle('presenter-grace', m.inGrace);
            }
            
            // Apply visual state (always call to clear old states, even if m.state is null)
            applyBodyState(m.state || null);
          } catch (err) {
            console.error('Presenter sync error:', err);
          }
        }
      };
      
      // Request initial sync if main window is already running
      setTimeout(() => {
        channel.postMessage({ type: 'request-sync' });
      }, 200);
      
      // Periodically request sync to ensure we stay updated (every 2 seconds)
      const syncInterval = setInterval(() => {
        if (!document.hidden) {
          channel.postMessage({ type: 'request-sync' });
        }
      }, 2000);
      
      // Clean up interval when window closes
      window.addEventListener('beforeunload', () => {
        clearInterval(syncInterval);
      });
    };
    
    // Start initialization when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initPresenter);
    } else {
      initPresenter();
    }
    
    return; // STOP script execution for presenter window
  }
  
  // ---------- DOM Elements: Header ----------
  const formatSelect = $('#formatSelect');
  const volume = $('#volume');
  const langSelect = $('#langSelect');
  const helpBtn = $('#helpBtn');
  const themeBtn = $('#themeBtn');
  const presenterBtn = $('#presenterBtn');
  const mirrorBtn = $('#mirrorBtn');
  const toggleQuickTimers = $('#toggleQuickTimers');
  const toggleNotesBtn = $('#toggleNotesBtn');
  const enableBtn = $('#enableBtn');
  const muteBtn = $('#muteBtn');
  
  // ---------- DOM Elements: Speaker Progress ----------
  const spkBar = $('#spkBar');
  const prevBtn = $('#prevBtn');
  const nextBtn = $('#nextBtn');
  const resetOrder = $('#resetOrder');
  const speakerCard = spkBar ? spkBar.closest('.card') : null;
  
  // ---------- DOM Elements: Main Timer ----------
  const mainCard = $('#mainCard');
  const mainTitle = $('#mainTitle');
  const metaEl = $('#meta');
  const clock = $('#clock');
  const mainProgress = $('#mainProgress');
  const fill = $('#fill');
  const startBtn = $('#startBtn');
  const resetBtn = $('#resetBtn');
  const singleBtn = $('#singleBtn');
  const doubleBtn = $('#doubleBtn');
  const testContBtn = $('#testContBtn');
  const stopBellBtn = $('#stopBellBtn');
  const status = $('#status');
  const exitMirrorBtn = $('#exitMirrorBtn');
const mirrorSpeakersBtn = $('#toggleMirrorSpeakers');
  let isScrubbing = false;

  // FIX: Define the setStatus function
  function setStatus(msg) {
    if (status) {
      status.textContent = msg;
    }
  }

  // ---------- DOM Elements: Notes Panel ----------
  const notesPanel = $('#notesPanel');
  const notesArea = $('#notesArea');
  const exportNotesBtn = $('#exportNotesBtn');
  const importNotesBtn = $('#importNotesBtn');
  const clearNotesBtn = $('#clearNotesBtn');
  const importNotesFile = $('#importNotesFile');
  
  // ---------- DOM Elements: Quick Timers ----------
  const quickTimersPanel = $('#quickTimersPanel');
  const cexClock = $('#cexClock'), cexFill = $('#cexFill'), cexStart = $('#cexStart'), cexReset = $('#cexReset');
  const rebClock = $('#rebClock'), rebFill = $('#rebFill'), rebStart = $('#rebStart'), rebReset = $('#rebReset');
  const prepClock = $('#prepClock'), prepFill = $('#prepFill'), prepStart = $('#prepStart'), prepReset = $('#prepReset');
  const poiClock = $('#poiClock'), poiFill = $('#poiFill'), poiStart = $('#poiStart'), poiReset = $('#poiReset');

  // ---------- DOM Elements: Settings Panel ----------
  const settingsPanel = $('#settingsPanel');
  const toggleSettings = $('#toggleSettings');
  const mainInput = $('#mainInput'), firstInput = $('#firstInput'), secondInput = $('#secondInput');
  const yellowInput = $('#yellowInput'), redInput = $('#redInput'), graceInput = $('#graceInput');
  const prepInput = $('#prepInput'), cexInput = $('#cexInput'), rebInput = $('#rebInput'), poiInput = $('#poiInput');
  const spaceInput = $('#spaceInput');
  const exportBtn = $('#exportBtn'), importBtn = $('#importBtn'), importFile = $('#importFile');
  const purgeCustomFormatsBtn = $('#purgeCustomFormatsBtn');
  
  // ---------- DOM Elements: Modals ----------
  const helpModal = $('#helpModal');
  const closeHelp = $('#closeHelp');
  const confirmModal = $('#confirmModal');
  const confirmTitle = $('#confirmTitle');
  const confirmText = $('#confirmText');
  const confirmCancel = $('#confirmCancel');
  const confirmOK = $('#confirmOK');
  
  // ---------- Audio ----------
  let audioCtx=null, unlocked=false, masterGain=null, muted=false; let contBellInterval=null;

  // ---------- Runtime state ----------
  let speakers = [];       // full sequence including prep tokens
  let activeIdx = 0;       // index into speakers array
  let mainRemain = 0, mainTotal = 0, firstBell = 0, secondBell = 0;
  let yellow = 0, red = 0, grace = 0, graceRemain = 0;
  let mainRunning = false, inGrace = false, mode = 'main';
  let lastFrame = 0, tick=0;
  let currentFormat = 'SIMSON';
  let allNotes = {}; // Separate from settings
  let mainLoopId = null; // Track animation frame for cleanup

  // ---------- Utilities ----------
  const $$ = (s,o=document)=>Array.from(o.querySelectorAll(s));
  const clamp=(n,a,b)=>Math.min(Math.max(n,a),b);
  const parseTime = t=>{const p=(t||'').trim().split(':'); if(p.length===1) return (+p[0]||0)*1000; const m=+p[0]||0,s=+p[1]||0; return (m*60+s)*1000};
  
  // ---------- Translations ----------
  const translations = {
    en: {
      // Header
      debateTimerTitle: 'Debate Timer', debateStyle: 'Debate Style', help: 'Help',
      lightMode: 'Light Mode', darkMode: 'Dark Mode',
      presenterMode: 'Presenter Mode', mirrorMode: 'Mirror Mode',
      showQuickTimers: 'Show Quick Timers', hideQuickTimers: 'Hide Quick Timers',
      showNotes: 'Show Notes', hideNotes: 'Hide Notes',
      initSound: 'Initialize Sound', volume: 'Volume', lang: 'Lang',
      // Speaker Progress
      spkProgress: 'Speaker Progress', prev: 'Previous', next: 'Next', resetOrder: 'Reset Order',
      spkNote: 'Click = select • Double-click = toggle active • Drag = reorder',
      // Main Timer
      substantive: 'Substantive Speech', replyRebuttal: 'Reply/Rebuttal', grace: 'Grace',
      status: 'Status:', statusIdle: 'idle', statusRunning: 'running', statusPaused: 'paused',
      statusSoundReady: 'Sound ready.', statusSoundFail: 'Sound failed. Please refresh.',
      start: 'Start', pause: 'Pause', reset: 'Reset', single: 'Single', double: 'Double',
      continuous: 'Continuous', stopBell: 'Stop Bell',
      // Notes
      speakerNotes: 'Speaker Notes', notesPlaceholder: 'Type notes for the current speaker...',
      exportNotes: 'Export Notes', importNotes: 'Import Notes', clearAllNotes: 'Clear All Notes',
      // Quick TimTers
      crossEx: 'Cross-Ex / Shared', rebuttal: 'Rebuttal / Reply', prep: 'Prep', poi: 'POI',
      // Settings
      settingsTitle: 'Timer Settings', hide: 'Hide', show: 'Show',
      mainTime: 'Main (m:ss)', firstBell: '1st Bell from start (m:ss)', secondBell: '2nd Bell from start (m:ss)',
      yellowAt: 'Yellow at remaining (m:ss)', redAt: 'Red at remaining (m:ss)', gracePeriod: 'Grace Period (m:ss)',
      prepTime: 'Prep Time (m:ss)', crossExTime: 'Cross-Ex (m:ss)', rebuttalTime: 'Rebuttal (m:ss)',
      poiTime: 'POI Time (m:ss)', bellSpacing: 'Bell spacing (ms)',
      exportSettings: 'Export Settings', importSettings: 'Import Settings',
      // Help Modal
      helpTitle: 'Help & Features', close: 'Close',
      helpHeaderButtons: 'Header Buttons',
      // ***** THIS IS THE FIX *****
      helpInitSound: '<strong>Sound:</strong> Audio initializes automatically on any interaction (click, touch, or key press). If sound doesn\'t work, use the failsafe button in Settings panel.',
      helpDebateStyle: '<strong>Debate Style:</strong> Select your format (AP, BP, etc.). This loads all speakers and default times.',
      helpVolume: '<strong>Volume:</strong> Controls the bell sound level.',
      helpLang: '<strong>Lang:</strong> Switches between English and Korean.',
      helpHelp: '<strong>Help:</strong> Opens this help window. (Shortcut: H)',
      helpTheme: '<strong>Theme:</strong> Toggles Dark/Light mode. (Shortcut: D)',
      helpPresenter: '<strong>Presenter:</strong> Opens a large, clean timer in a new window for an external display. (Shortcut: P)',
      helpMirror: '<strong>Mirror:</strong> Hides all controls on the main screen. Use this when *mirroring* your device to a display. <strong>Click the X button to exit.</strong>',
      helpQuickTimers: '<strong>Quick Timers:</strong> Shows/hides the extra timers (Cross-Ex, Prep, etc.). Icon has a slash when hidden.',
      helpNotes: '<strong>Notes:</strong> Shows/hides the speaker notes panel. Icon has a slash when hidden. Lights up if the current speaker has notes.',
      helpMute: '<strong>Mute:</strong> Toggles all bell sounds on/off. (Shortcut: M)',
      
      helpSpeakerProgress: 'Speaker Progress',
      helpSpkClick: '<strong>Click:</strong> Selects a speaker without changing the order.',
      helpSpkDoubleClick: '<strong>Double-click:</strong> Toggles a speaker active/inactive (greys them out and skips them).',
      helpSpkDrag: '<strong>Drag & Drop:</strong> Re-order the entire speaker flow.',
      helpSpkNextPrev: '<strong>Next/Previous:</strong> Moves to the next/previous speaker. (Shortcut: → / ←)',

      helpMainTimer: 'Main Timer Controls',
      helpMainStart: '<strong>Start/Pause (Play/Pause):</strong> Toggles the main timer. (Shortcut: Space)',
      helpMainReset: '<strong>Reset (Circular Arrow):</strong> Resets the current timer. (Shortcut: R)',
      helpMainScrub: '<strong>Progress Bar:</strong> Click or drag on the progress bar to "scrub" the timer to any point.',
      helpMainBells: '<strong>Bell Icons (1, 2, Loop, Mute):</strong> Play bells manually or stop a continuous bell. (Shortcut: 1, 2)',
      
      helpTimerLogic: 'Timer Logic',
      helpTimerLogicSub: '<strong>Substantive Speeches:</strong> Use Main, 1st Bell, 2nd Bell, Yellow/Red, and Grace times.',
      helpTimerLogicBells: 'Bells ring at 1st Bell, 2nd Bell, and a double-bell rings at the end (0:00).',
      helpTimerLogicGrace: 'After 0:00, the <strong>Grace Period</strong> counts up, and the screen flashes.',
      helpTimerLogicCont: 'After the grace period, a <strong>continuous bell</strong> rings until you press "Stop Bell" or "Reset".',
      helpTimerLogicReply: '<strong>Reply Speeches:</strong> Use the "Rebuttal" time and end with a double-bell.',

      helpNotesData: 'Notes & Data',
      helpNotesPerSpeaker: 'Notes are saved per-speaker, per-format (e.g., "AP - Prime Minister").',
      helpNotesExportTxt: '<strong>Export Notes:</strong> Saves a ".txt" file of all your notes, organized by format.',
      helpNotesImport: '<strong>Import Notes:</strong> Merges notes from a `.json` file.',
      helpNotesClear: '<strong>Clear All Notes:</strong> Deletes all saved notes (with confirmation).',
      helpSettingsExport: '<strong>Export Settings:</strong> Saves your "Custom" preset and all timer settings to a `.json` file.',
      helpSettingsImport: '<strong>Import Settings:</strong> Loads a `.json` file as your new "Custom" preset.',

      // Dynamic Roles (will be handled by PRESETS)
      roundPrep: 'Round Prep', prepFor: 'Prep for',
      // Button Titles
      titleMute: 'Mute (M)',
      titleStart: 'Start/Pause (Space)',
      titleReset: 'Reset (R)',
      titleSingle: 'Single Bell (1)',
      titleDouble: 'Double Bell (2)',
      titleTestCont: 'Start continuous bell test',
      titleStopBell: 'Stop continuous bell',
      titleThemeLight: 'Toggle Light Mode (D)',
      titleThemeDark: 'Toggle Dark Mode (D)',
      titleHelp: 'Help (H)',
      titlePresenter: 'Presenter Mode (P)',
      titleMirror: 'Mirror Mode',
      titleMirrorShowSpeakers: 'Show Speaker Progress',
      titleMirrorHideSpeakers: 'Hide Speaker Progress',
      titleQuickTimersShow: 'Show Quick Timers',
      titleQuickTimersHide: 'Hide Quick Timers',
      titleNotesShow: 'Show Speaker Notes',
      titleNotesHide: 'Hide Speaker Notes',
      // Confirmation Modal
      confirmClearNotesTitle: 'Clear All Notes?',
      confirmClearNotesText: 'Are you sure you want to delete all saved speaker notes? This cannot be undone.',
      cancel: 'Cancel',
      ok: 'OK',
    },
    ko: {
      // Header
      debateTimerTitle: '토론 타이머', debateStyle: '토론 방식', help: '도움말',
      lightMode: '라이트 모드', darkMode: '다크 모드',
      presenterMode: '발표자 모드', mirrorMode: '미러 모드',
      showQuickTimers: '빠른 타이머 표시', hideQuickTimers: '빠른 타이머 숨기기',
      showNotes: '메모 보이기', hideNotes: '메모 숨기기',
      initSound: '소리 초기화', volume: '볼륨', lang: '언어',
      // Speaker Progress
      spkProgress: '발표자 진행', prev: '이전', next: '다음', resetOrder: '순서 초기화',
      spkNote: '클릭 = 선택 • 더블 클릭 = 활성/비활성 • 드래그 = 순서 변경',
      // Main Timer
      substantive: '입론', replyRebuttal: '답변/반박', grace: '유예',
      status: '상태:', statusIdle: '대기 중', statusRunning: '실행 중', statusPaused: '일시정지',
      statusSoundReady: '소리 준비 완료.', statusSoundFail: '소리 초기화 실패. 새로고침하세요.',
      start: '시작', pause: '일시정지', reset: '초기화', single: '싱글', double: '더블',
      continuous: '연속', stopBell: '벨 멈춤',
      // Notes
      speakerNotes: '발표자 메모', notesPlaceholder: '현재 발표자/다음 준비를 위한 메모 입력...',
      exportNotes: '메모 내보내기', importNotes: '메모 가져오기', clearAllNotes: '모든 메모 지우기',
      // Quick Timers
      crossEx: '교차조사 / 공유', rebuttal: '반박 / 답변', prep: '준비', poi: 'POI',
      // Settings
      settingsTitle: '타이머 설정', hide: '숨기기', show: '보이기',
      mainTime: '주요 (m:ss)', firstBell: '첫 번째 벨 (시작부터 m:ss)', secondBell: '두 번째 벨 (시작부터 m:ss)',
      yellowAt: '노란색 (남은 시간 m:ss)', redAt: '빨간색 (남은 시간 m:ss)', gracePeriod: '유예 시간 (m:ss)',
      prepTime: '준비 시간 (m:ss)', crossExTime: '교차조사 (m:ss)', rebuttalTime: '반박 (m:ss)',
      poiTime: 'POI 시간 (m:ss)', bellSpacing: '벨 간격 (ms)',
      exportSettings: '설정 내보내기', importSettings: '설정 가져오기',
      // Help Modal
      helpTitle: '도움말 & 기능', close: '닫기',
      helpHeaderButtons: '헤더 버튼',
      // ***** THIS IS THE FIX *****
      helpInitSound: '<strong>소리:</strong> 오디오는 모든 상호작용(클릭, 터치 또는 키 입력)에서 자동으로 초기화됩니다. 소리가 작동하지 않으면 설정 패널의 안전 버튼을 사용하세요.',
      helpDebateStyle: '<strong>토론 방식:</strong> 포맷(AP, BP 등)을 선택합니다. 모든 발표자와 기본 시간을 로드합니다.',
      helpVolume: '<strong>볼륨:</strong> 벨소리 크기를 조절합니다.',
      helpLang: '<strong>언어:</strong> 한국어와 영어 간을 전환합니다.',
      helpHelp: '<strong>도움말:</strong> 이 도움말 창을 엽니다. (단축키: H)',
      helpTheme: '<strong>테마:</strong> 다크/라이트 모드를 전환합니다. (단축키: D)',
      helpPresenter: '<strong>발표자:</strong> 외부 디스플레이를 위해 새 창에 크고 깔끔한 타이머를 엽니다. (단축키: P)',
      helpMirror: '<strong>미러:</strong> 메인 화면의 모든 컨트롤을 숨깁니다. 기기를 디스플레이에 *미러링*할 때 사용하세요. <strong>종료하려면 X 버튼을 클릭하세요.</strong>',
      helpQuickTimers: '<strong>빠른 타이머:</strong> 추가 타이머(교차조사, 준비 등)를 표시하거나 숨깁니다. 숨겨져 있을 때는 아이콘에 슬래시가 표시됩니다.',
      helpNotes: '<strong>메모:</strong> 발표자 메모 패널을 표시하거나 숨깁니다. 숨겨져 있을 때는 아이콘에 슬래시가 표시됩니다. 현재 발표자에게 메모가 있으면 불이 들어옵니다.',
      helpMute: '<strong>음소거:</strong> 모든 벨소리를 켜거나 끕니다. (단축키: M)',

      helpSpeakerProgress: '발표자 진행',
      helpSpkClick: '<strong>클릭:</strong> 순서 변경 없이 발표자를 선택합니다.',
      helpSpkDoubleClick: '<strong>더블 클릭:</strong> 발표자를 활성/비활성으로 전환합니다 (회색으로 변하며 건너뜀).',
      helpSpkDrag: '<strong>드래그 & 드롭:</strong> 전체 발표자 순서를 변경합니다.',
      helpSpkNextPrev: '<strong>다음/이전:</strong> 다음/이전 발표자로 이동합니다. (단축키: → / ←)',
      
      helpMainTimer: '메인 타이머 컨트롤',
      helpMainStart: '<strong>시작/일시정지 (재생/일시정지):</strong> 메인 타이머를 토글합니다. (단축키: Space)',
      helpMainReset: '<strong>초기화 (원형 화살표):</strong> 현재 타이머를 초기화합니다. (단축키: R)',
      helpMainScrub: '<strong>진행 표시줄:</strong> 진행 표시줄을 클릭하거나 드래그하여 타이머를 원하는 시점으로 "스크럽"할 수 있습니다.',
      helpMainBells: '<strong>벨 아이콘 (1, 2, 루프, 음소거):</strong> 벨을 수동으로 울리거나 연속 벨을 멈춥니다. (단축키: 1, 2)',
      
      helpTimerLogic: '타이머 로직',
      helpTimerLogicSub: '<strong>입론:</strong> 주요, 1차 벨, 2차 벨, 노란색/빨간색, 유예 시간을 사용합니다.',
      helpTimerLogicBells: '1차 벨, 2차 벨 시점에 벨이 울리고, 종료 시점(0:00)에 더블 벨이 울립니다.',
      helpTimerLogicGrace: '0:00 이후, <strong>유예 시간</strong>이 카운트 업되며 화면이 깜박입니다.',
      helpTimerLogicCont: '유예 시간이 끝나면, "벨 멈춤" 또는 "초기화"를 누를 때까지 <strong>연속 벨</strong>이 울립니다.',
      helpTimerLogicReply: '<strong>답변:</strong> "반박" 시간을 사용하며 더블 벨로 종료됩니다.',

      helpNotesData: '메모 & 데이터',
      helpNotesPerSpeaker: '메모는 포맷별, 발표자별로 저장됩니다 (예: "AP - Prime Minister").',
      helpNotesExportTxt: '<strong>메모 내보내기:</strong> 모든 메모를 포맷별로 정리된 ".txt" 파일로 저장합니다.',
      helpNotesImport: '<strong>메모 가져오기:</strong> `.json` 파일에서 메모를 병합합니다.',
      helpNotesClear: '<strong>모든 메모 지우기:</strong> 저장된 모든 메모를 삭제합니다 (확인 창 표시).',
      helpSettingsExport: '<strong>설정 내보내기:</strong> "Custom" preset과 모든 타이머 설정을 `.json` 파일로 저장합니다.',
      helpSettingsImport: '<strong>설정 가져오기:</strong> `.json` 파일을 새 "Custom" preset으로 로드합니다.',

      // Dynamic Roles
      roundPrep: '라운드 준비', prepFor: '준비 (다음)',
      // Button Titles
      titleMute: '음소거 (M)',
      titleStart: '시작/일시정지 (Space)',
      titleReset: '초기화 (R)',
      titleSingle: '싱글 벨 (1)',
      titleDouble: '더블 벨 (2)',
      titleTestCont: '연속 벨 테스트',
      titleStopBell: '벨 멈춤',
      titleThemeLight: '라이트 모드 (D)',
      titleThemeDark: '다크 모드 (D)',
      titleHelp: '도움말 (H)',
      titlePresenter: '발표자 모드 (P)',
      titleMirror: '미러 모드',
      titleMirrorShowSpeakers: '발언 순서 표시',
      titleMirrorHideSpeakers: '발언 순서 숨기기',
      titleQuickTimersShow: '빠른 타이머 표시',
      titleQuickTimersHide: '빠른 타이머 숨기기',
      titleNotesShow: '발표자 메모 표시',
      titleNotesHide: '발표자 메모 숨기기',
      // Confirmation Modal
      confirmClearNotesTitle: '모든 메모를 지우시겠습니까?',
      confirmClearNotesText: '저장된 모든 발표자 메모를 삭제합니다. 이 작업은 되돌릴 수 없습니다.',
      cancel: '취소',
      ok: '확인',
    }
  };
  let currentLang = translations.en;
  
  // ---------- Language ----------
  function setLanguage(lang) {
    currentLang = translations[lang] || translations.en;
    document.documentElement.lang = lang;
    try {
    localStorage.setItem('debateLang', lang);
    } catch(e) {
      console.warn('Failed to save language preference:', e);
    }
    
    // Update all static text
    $$('[data-lang-key]').forEach(el => {
      const key = el.dataset.langKey;
      if (currentLang[key]) {
        el.innerHTML = currentLang[key];
      }
    });
    
    // Update dynamic text
    updateButtonStates();
    renderSpeakerProgress(); // Re-render speaker names
    loadSpeakerNotes(); // Re-load placeholder
  }
  
  function updateButtonStates() {
    // Update theme button title
    const isDark = document.documentElement.classList.contains('dark');
    themeBtn.title = isDark ? currentLang.titleThemeLight : currentLang.titleThemeDark;
    
    // Update main timer start/pause button text
    const startLabel = startBtn.querySelector('.label-text');
    if (startLabel) {
      startLabel.textContent = mainRunning ? currentLang.pause : currentLang.start;
    }
    
    // Update toggle button titles
    toggleQuickTimers.title = quickTimersPanel.style.maxHeight === '0px' ? currentLang.titleQuickTimersShow : currentLang.titleQuickTimersHide;
    toggleNotesBtn.title = notesPanel.style.maxHeight === '0px' ? currentLang.titleNotesShow : currentLang.titleNotesHide;
    
    // Update other titles
    muteBtn.title = currentLang.titleMute;
    startBtn.title = currentLang.titleStart;
    resetBtn.title = currentLang.titleReset;
    singleBtn.title = currentLang.titleSingle;
    doubleBtn.title = currentLang.titleDouble;
    testContBtn.title = currentLang.titleTestCont;
    stopBellBtn.title = currentLang.titleStopBell;
    helpBtn.title = currentLang.titleHelp;
    presenterBtn.title = currentLang.titlePresenter;
    mirrorBtn.title = currentLang.titleMirror;
    if (mirrorSpeakersBtn) {
      const showSpeakers = document.body.classList.contains('mirror-show-speakers');
      mirrorSpeakersBtn.title = showSpeakers ? currentLang.titleMirrorHideSpeakers : currentLang.titleMirrorShowSpeakers;
      mirrorSpeakersBtn.setAttribute('aria-pressed', showSpeakers ? 'true' : 'false');
      mirrorSpeakersBtn.classList.toggle('active', showSpeakers);
    }
    updateMirrorSpeakerVisibility();
    
    // Update settings toggle
    toggleSettings.textContent = settingsPanel.style.maxHeight === '0px' ? currentLang.show : currentLang.hide;
  }

  function updateMirrorSpeakerVisibility() {
    if (!speakerCard) return;
    if (document.body.classList.contains('mirror-mode')) {
      const show = document.body.classList.contains('mirror-show-speakers');
      speakerCard.style.display = show ? '' : 'none';
    } else {
      speakerCard.style.display = '';
    }
  }

  // ---------- Audio ----------
  const isIOS = /iP(ad|hone|od)/i.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  let iosAudioPrimed = false;
  function primeIOSSilentModeBypass(){
    if(!isIOS || !audioCtx || iosAudioPrimed) return;
    try{
      const buffer = audioCtx.createBuffer(1,1,22050);
      const source = audioCtx.createBufferSource();
      const gainNode = audioCtx.createGain();
      gainNode.gain.value = 0;
      source.buffer = buffer;
      source.connect(gainNode);
      const target = masterGain || audioCtx.destination;
      if(target) gainNode.connect(target);
      source.start(0);
      iosAudioPrimed = true;
    }catch(err){
      console.warn('iOS silent-mode warmup failed:', err);
    }
  }
  async function initAudio(){
    if(unlocked && audioCtx) return; // Already initialized
    try{
      audioCtx = new (window.AudioContext||window.webkitAudioContext)({ latencyHint: 'interactive' });
      iosAudioPrimed = false;
      masterGain = audioCtx.createGain(); masterGain.gain.value = +volume.value; masterGain.connect(audioCtx.destination);
      primeIOSSilentModeBypass();
      unlocked=true; setStatus(currentLang.statusSoundReady);
    }catch(e){ setStatus(currentLang.statusSoundFail); }
  }
  // Auto-initialize audio on first user interaction
  let audioInitAttempted = false;
  async function autoInitAudio(){
    if(audioInitAttempted && unlocked && audioCtx) return; // Already initialized
    audioInitAttempted = true;
    if(!unlocked || !audioCtx) {
      await initAudio();
    }
    primeIOSSilentModeBypass();
    // Resume audio context if suspended (common in mobile browsers)
    if(audioCtx && audioCtx.state === 'suspended') {
      try {
        await audioCtx.resume();
        primeIOSSilentModeBypass();
      } catch(e) {
        console.warn('Could not resume audio context:', e);
      }
    }
  }
  enableBtn.onclick = initAudio; // Keep as failsafe
  volume.oninput=()=>{ if(masterGain) masterGain.gain.value = +volume.value };
  
  function ding({type='single'}={}){
    // Auto-initialize if needed
    if(!unlocked || !audioCtx) {
      autoInitAudio().then(() => {
        if(unlocked && audioCtx) playDing();
      });
      return;
    }
    playDing();
  }
  function playDing(){
    if(!unlocked||!audioCtx) return;
    primeIOSSilentModeBypass();
    const now=audioCtx.currentTime;
    const osc=audioCtx.createOscillator();
    const osc2=audioCtx.createOscillator();
    const gain=audioCtx.createGain();
    const base=880; // A5
    osc.type='sine'; osc.frequency.setValueAtTime(base,now);
    osc2.type='sine'; osc2.frequency.setValueAtTime(base*1.5,now);
    gain.gain.setValueAtTime(muted?0:0.4,now);
    gain.gain.exponentialRampToValueAtTime(muted?0:0.0001, now+0.8);
    osc.connect(gain); osc2.connect(gain); gain.connect(masterGain);
    osc.start(now); osc2.start(now); osc.stop(now+0.9); osc2.stop(now+0.9);
  }
  function stopContinuous(){ if(contBellInterval){ clearInterval(contBellInterval); contBellInterval=null } }

  muteBtn.onclick=()=>{ 
    autoInitAudio(); // Auto-initialize audio on mute button click
    muted=!muted; 
    muteBtn.classList.toggle('muted', muted); // Use 'muted' class for icon switching
  };
  
  // Global listeners for auto-initialization on any user interaction
  // Only listen once, then remove listeners after first initialization
  const initOnInteraction = async () => {
    await autoInitAudio();
    // Remove listeners after first successful initialization (check after a brief delay)
    setTimeout(() => {
      if(unlocked && audioCtx) {
        document.removeEventListener('click', initOnInteraction, true);
        document.removeEventListener('touchstart', initOnInteraction, true);
        document.removeEventListener('keydown', initOnInteraction, true);
      }
    }, 100);
  };
  // Add listeners for clicks, touches, and key presses
  document.addEventListener('click', initOnInteraction, true);
  document.addEventListener('touchstart', initOnInteraction, true);
  document.addEventListener('keydown', initOnInteraction, true);
  document.addEventListener('pointerdown', initOnInteraction, true);
  document.addEventListener('visibilitychange', () => {
    if(document.visibilityState === 'visible' && audioCtx){
      if(audioCtx.state === 'suspended'){
        audioCtx.resume().then(primeIOSSilentModeBypass).catch((err) => console.warn('Could not resume audio context on visibility change:', err));
      } else {
        primeIOSSilentModeBypass();
      }
    }
  });
  const resumeAudioPipeline = () => {
    if(!audioCtx) return;
    if(audioCtx.state === 'suspended'){
      audioCtx.resume().then(() => {
        iosAudioPrimed = false;
        primeIOSSilentModeBypass();
      }).catch((err) => console.warn('Could not resume audio context on focus/pageshow:', err));
    } else {
      primeIOSSilentModeBypass();
    }
  };
  window.addEventListener('focus', resumeAudioPipeline);
  window.addEventListener('pageshow', resumeAudioPipeline);
  window.addEventListener('blur', () => {
    iosAudioPrimed = false;
  });

  // ---------- Theme ----------
  const setDark = (on)=>{
    setDarkGlobal(on); // Use global function
    try {
    localStorage.setItem('debateTheme', on? 'dark':'light'); 
    } catch(e) {
      console.warn('Failed to save theme preference:', e);
    }
    themeBtn.classList.toggle('active', on);
    updateButtonStates();
  };
  themeBtn.onclick = ()=> setDark(!document.documentElement.classList.contains('dark'));

  // ---------- Presenter Mode ----------
  const presenterChannel = new BroadcastChannel('debate_timer_sync_v1');
  let presenterWin = null;
  let presenterReady = false;

  // Listen for presenter window ready signal and sync requests
  presenterChannel.onmessage = (e) => {
    if (e.data && e.data.type === 'presenter-ready') {
      presenterReady = true;
      syncOut(true); // Send initial sync when presenter is ready
    } else if (e.data && e.data.type === 'request-sync') {
      syncOut(true); // Respond to sync requests
    }
  };

  presenterBtn.onclick = () => {
    if (!presenterWin || presenterWin.closed) {
      // Use full URL to preserve protocol and handle file:// correctly
      const baseUrl = window.location.href.split('?')[0];
      const presenterUrl = baseUrl + '?presenter=true';
      presenterWin = window.open(presenterUrl, 'presenter', 'width=1000,height=700');
      
      if (presenterWin) {
        presenterReady = false;
        presenterWin.focus();
        
        // Send initial sync immediately, then again when ready
        syncOut(true);
        
        // Wait for presenter window to signal it's ready
        const checkReady = setInterval(() => {
          if (presenterReady || presenterWin.closed) {
            clearInterval(checkReady);
            // Send sync again when ready signal received
            if (presenterReady && !presenterWin.closed) {
              syncOut(true);
            }
          }
        }, 100);
        
        // Fallback: send sync after delay if ready signal not received
        setTimeout(() => {
          if (!presenterReady && !presenterWin.closed) {
            syncOut(true);
          }
        }, 1000);
      }
    } else {
      presenterWin.focus();
      // Send sync when refocusing existing window
      syncOut(true);
    }
  };
  
  // ---------- NEW: Mirror Mode ----------
  mirrorBtn.onclick = () => {
    const isMirror = document.body.classList.toggle('mirror-mode');
    if (!isMirror) {
      document.body.classList.remove('mirror-show-speakers');
    }
    mirrorBtn.classList.toggle('active', isMirror);
    updateMirrorSpeakerVisibility();
    updateButtonStates();
  };
  if (mirrorSpeakersBtn) {
    mirrorSpeakersBtn.addEventListener('click', () => {
      if (!document.body.classList.contains('mirror-mode')) return;
      const show = document.body.classList.toggle('mirror-show-speakers');
      mirrorSpeakersBtn.classList.toggle('active', show);
      mirrorSpeakersBtn.setAttribute('aria-pressed', show ? 'true' : 'false');
      updateMirrorSpeakerVisibility();
      updateButtonStates();
    });
  }
  // Exit mirror mode button
  exitMirrorBtn.onclick = () => {
    document.body.classList.remove('mirror-mode');
    document.body.classList.remove('mirror-show-speakers');
    mirrorBtn.classList.remove('active');
    updateMirrorSpeakerVisibility();
    updateButtonStates();
  };

  // ---------- Sync Function ----------
  function syncOut(full=false){
    // Calculate state here, just for the message
    const left = mainRemain || 0;
    const warn = left <= yellow && left > red && mode==='main' && !inGrace;
    const bad = left <= red && left > 0 && mode==='main' && !inGrace;
    let bodyState = null;
    
    // Get meta text safely
    let metaText = '';
    if (mainTitle && mainTitle.textContent) {
      metaText = mainTitle.textContent;
      if (metaEl && metaEl.textContent) {
        metaText += ' — ' + metaEl.textContent;
      }
    } else if (speakers && speakers.length > 0 && activeIdx >= 0 && activeIdx < speakers.length) {
      // Fallback: use speaker data if mainTitle not available
      const s = speakers[activeIdx];
      const lang = langSelect ? (langSelect.value || 'en') : 'en';
      const roleKey = `role_${lang}`;
      metaText = s[roleKey] || s.role_en || '';
    }
    
    let remainTime = mainRemain || 0;

    if(inGrace) {
      bodyState = 'state-grace';
      remainTime = graceRemain || 0; 
      
      const s = speakers && speakers[activeIdx] ? speakers[activeIdx] : null;
      if (s) {
        const roleKey = `role_${currentLang.lang || 'en'}`;
        const role = s[roleKey] || s.role_en || '';
        metaText = `${role} — ${currentLang.grace || 'Grace'}`; 
      }
    }
    else if(bad) bodyState = 'state-bad';
    else if(warn) bodyState = 'state-warn';

    // Prepare speaker progress data for presenter mode
    const lang = langSelect ? (langSelect.value || 'en') : 'en';
    const roleKey = `role_${lang}`;
    const speakerData = (speakers && Array.isArray(speakers)) ? speakers.map((s, i) => ({
      role: s[roleKey] || s.role_en || '',
      side: s.side || 'neutral',
      active: s.active !== false,
      isActive: i === activeIdx
    })) : [];

    const payload={
      type:'state', 
      full, 
      main:{remain: remainTime, total:mainTotal || 0, running:mainRunning || false}, 
      meta: metaText || 'Presenter', 
      inGrace: inGrace || false,
      state: bodyState,
      theme: document.documentElement.classList.contains('dark') ? 'dark' : 'light',
      speakers: speakerData,
      activeIdx: activeIdx || 0
    };
    presenterChannel.postMessage(payload);
  }
  
  // ---------- Presets (base) ----------
  const PRESETS = {
    SIMSON: {
      label: 'Simson',
      base: [
        {role_en:'PM', role_ko:'총리 (PM)', side:'prop', initials:'PM'},
        {role_en:'LO', role_ko:'야당대표 (LO)', side:'opp', initials:'LO'},
        {role_en:'DPM', role_ko:'부총리 (DPM)', side:'prop', initials:'DPM'},
        {role_en:'DLO', role_ko:'야당부대표 (DLO)', side:'opp', initials:'DLO'},
        {role_en:'GW', role_ko:'여당 원내총무 (GW)', side:'prop', initials:'GW'},
        {role_en:'OW', role_ko:'야당 원내총무 (OW)', side:'opp', initials:'OW'},
        {role_en:'GR', role_ko:'여당 답변 (GR)', side:'prop', initials:'GR'},
        {role_en:'OR', role_ko:'야당 답변 (OR)', side:'opp', initials:'OR'}
      ],
      // NOTE: Simson between-speech prep is 1:00. Add a 20:00 round prep at the very beginning via sequence builder.
      settings: { main:'3:00', first:'1:00', second:'2:00', yellow:'1:00', red:'0:30', grace:'0:30', prep:'1:00', cex:'1:00', reb:'3:00', poi:'0:15', spacing:'250', roundPrep:'20:00' }
    },
    AP: {
      label: 'Asian Parliamentary',
      base: [
        {role_en:'Prime Minister', role_ko:'총리', side:'prop', initials:'PM'},
        {role_en:'Leader of Opposition', role_ko:'야당대표', side:'opp', initials:'LO'},
        {role_en:'Deputy Prime Minister', role_ko:'부총리', side:'prop', initials:'DPM'},
        {role_en:'Deputy Leader of Opposition', role_ko:'야당부대표', side:'opp', initials:'DLO'},
        {role_en:'Government Whip', role_ko:'여당 원내총무', side:'prop', initials:'GW'},
        {role_en:'Opposition Whip', role_ko:'야당 원내총무', side:'opp', initials:'OW'},
        {role_en:'Opposition Reply', role_ko:'야당 답변', side:'opp', initials:'OR'},
        {role_en:'Government Reply', role_ko:'여당 답변', side:'prop', initials:'GR'}
      ],
      settings: { main:'7:00', first:'1:00', second:'6:00', yellow:'1:00', red:'0:30', grace:'0:30', prep:'30:00', cex:'1:00', reb:'4:00', poi:'0:15', spacing:'250', roundPrep:'00:00' }
    },
    BP: {
      label: 'British Parliamentary',
      base: [
        {role_en:'Prime Minister', role_ko:'총리', side:'prop', initials:'PM'},
        {role_en:'Leader of Opposition', role_ko:'야당대표', side:'opp', initials:'LO'},
        {role_en:'Deputy Prime Minister', role_ko:'부총리', side:'prop', initials:'DPM'},
        {role_en:'Deputy Leader of Opposition', role_ko:'야당부대표', side:'opp', initials:'DLO'},
        {role_en:'Member of Government', role_ko:'여당 의원', side:'prop', initials:'MG'},
        {role_en:'Member of Opposition', role_ko:'야당 의원', side:'opp', initials:'MO'},
        {role_en:'Government Whip', role_ko:'여당 원내총무', side:'prop', initials:'GW'},
        {role_en:'Opposition Whip', role_ko:'야당 원내총무', side:'opp', initials:'OW'},
        {role_en:'Opposition Reply', role_ko:'야당 답변', side:'opp', initials:'OR'},
        {role_en:'Government Reply', role_ko:'여당 답변', side:'prop', initials:'GR'}
      ],
      settings: { main:'7:00', first:'1:00', second:'6:00', yellow:'1:00', red:'0:30', grace:'0:30', prep:'0:00', cex:'1:00', reb:'4:00', poi:'0:15', spacing:'250', roundPrep:'15:00' }
    },
    WSDC: {
      label: 'WSDC',
      base: [
        {role_en:'1st Prop', role_ko:'1번 찬성', side:'prop', initials:'P1'},
        {role_en:'1st Opp', role_ko:'1번 반대', side:'opp', initials:'O1'},
        {role_en:'2nd Prop', role_ko:'2번 찬성', side:'prop', initials:'P2'},
        {role_en:'2nd Opp', role_ko:'2번 반대', side:'opp', initials:'O2'},
        {role_en:'3rd Prop', role_ko:'3번 찬성', side:'prop', initials:'P3'},
        {role_en:'3rd Opp', role_ko:'3번 반대', side:'opp', initials:'O3'},
        {role_en:'Opp Reply', role_ko:'반대 답변', side:'opp', initials:'OR'},
        {role_en:'Prop Reply', role_ko:'찬성 답변', side:'prop', initials:'PR'}
      ],
      settings: { main:'8:00', first:'1:00', second:'7:00', yellow:'1:00', red:'0:30', grace:'0:30', prep:'0:00', cex:'1:00', reb:'4:00', poi:'0:15', spacing:'250', roundPrep:'00:00' }
    },
    PF: {
      label: 'Public Forum',
      base: [
        {role_en:'Speaker 1 (Team A)', role_ko:'발표자 1 (A팀)', side:'prop', initials:'A1'},
        {role_en:'Speaker 2 (Team B)', role_ko:'발표자 2 (B팀)', side:'opp', initials:'B1'},
        {role_en:'Crossfire (1 & 2)', role_ko:'교차조사 (1 & 2)', side:'neutral', initials:'C1-2'},
        {role_en:'Speaker 3 (Team A)', role_ko:'발표자 3 (A팀)', side:'prop', initials:'A2'},
        {role_en:'Speaker 4 (Team B)', role_ko:'발표자 4 (B팀)', side:'opp', initials:'B2'},
        {role_en:'Crossfire (3 & 4)', role_ko:'교차조사 (3 & 4)', side:'neutral', initials:'C3-4'},
        {role_en:'Summary 1 (Team A)', role_ko:'요약 1 (A팀)', side:'prop', initials:'AS'},
        {role_en:'Summary 2 (Team B)', role_ko:'요약 2 (B팀)', side:'opp', initials:'BS'},
        {role_en:'Grand Crossfire', role_ko:'전체 교차조사', side:'neutral', initials:'GC'},
        {role_en:'Final Focus 1 (A)', role_ko:'최종 1 (A팀)', side:'prop', initials:'AFF'},
        {role_en:'Final Focus 2 (B)', role_ko:'최종 2 (B팀)', side:'opp', initials:'BFF'}
      ],
      settings: { main:'4:00', first:'1:00', second:'3:00', yellow:'1:00', red:'0:30', grace:'0:30', prep:'0:00', cex:'3:00', reb:'2:00', poi:'0:15', spacing:'250', roundPrep:'00:00' }
    },
    CX: {
      label: 'Policy / CX',
      base: [
        {role_en:'1st Aff Constructive', role_ko:'1차 긍정 입론', side:'prop', initials:'1AC'},
        {role_en:'Cross-Ex (by 2NC)', role_ko:'교차조사 (2NC)', side:'opp', initials:'CX'},
        {role_en:'1st Neg Constructive', role_ko:'1차 부정 입론', side:'opp', initials:'1NC'},
        {role_en:'Cross-Ex (by 1AC)', role_ko:'교차조사 (1AC)', side:'prop', initials:'CX'},
        {role_en:'2nd Aff Constructive', role_ko:'2차 긍정 입론', side:'prop', initials:'2AC'},
        {role_en:'Cross-Ex (by 1NC)', role_ko:'교차조사 (1NC)', side:'opp', initials:'CX'},
        {role_en:'2nd Neg Constructive', role_ko:'2차 부정 입론', side:'opp', initials:'2NC'},
        {role_en:'Cross-Ex (by 2AC)', role_ko:'교차조사 (2AC)', side:'prop', initials:'CX'},
        {role_en:'1st Neg Rebuttal', role_ko:'1차 부정 반박', side:'opp', initials:'1NR'},
        {role_en:'1st Aff Rebuttal', role_ko:'1차 긍정 반박', side:'prop', initials:'1AR'},
        {role_en:'2nd Neg Rebuttal', role_ko:'2차 부정 반박', side:'opp', initials:'2NR'},
        {role_en:'2nd Aff Rebuttal', role_ko:'2차 긍정 반박', side:'prop', initials:'2AR'}
      ],
      settings: { main:'8:00', first:'1:00', second:'7:00', yellow:'1:00', red:'0:30', grace:'0:30', prep:'0:00', cex:'3:00', reb:'5:00', poi:'0:15', spacing:'250', roundPrep:'00:00' }
    },
    LD: {
      label: 'Lincoln–Douglas',
      base: [
        {role_en:'Aff Constructive', role_ko:'긍정 입론', side:'prop', initials:'AC'},
        {role_en:'Cross-Ex', role_ko:'교차조사', side:'opp', initials:'CX'},
        {role_en:'Neg Constructive', role_ko:'부정 입론', side:'opp', initials:'NC'},
        {role_en:'Cross-Ex', role_ko:'교차조사', side:'prop', initials:'CX'},
        {role_en:'1st Aff Rebuttal', role_ko:'1차 긍정 반박', side:'prop', initials:'1AR'},
        {role_en:'Neg Rebuttal', role_ko:'부정 반박', side:'opp', initials:'NR'},
        {role_en:'2nd Aff Rebuttal', role_ko:'2차 긍정 반박', side:'prop', initials:'2AR'}
      ],
      settings: { main:'6:00', first:'1:00', second:'5:00', yellow:'1:00', red:'0:30', grace:'0:30', prep:'0:00', cex:'3:00', reb:'4:00', poi:'0:15', spacing:'250', roundPrep:'00:00' }
    },
    CUSTOM: {
      label: 'Custom',
      base: [],
      settings: {}
    }
  };

  // ---------- Timers: Main ----------
  function startMain(e){
    if(e) e.preventDefault();
    // Auto-initialize audio on first user interaction
    autoInitAudio();
    if(mainRunning) return pauseMain(true);
    if(mainRemain <= 0 && !inGrace) return; // Don't start a finished timer
    mainRunning=true; 
    lastFrame=performance.now();
    if(mainLoopId) cancelAnimationFrame(mainLoopId);
    mainLoopId = requestAnimationFrame(mainLoop);
    setStatus(currentLang.statusRunning);
    updateButtonStates();
    startBtn.classList.add('running');
  }
  function pauseMain(fromUser=false){
    mainRunning=false;
    if(mainLoopId) {
      cancelAnimationFrame(mainLoopId);
      mainLoopId = null;
    }
    if(fromUser) setStatus(currentLang.statusPaused);
    updateButtonStates();
    startBtn.classList.remove('running');
  }
  function resetMain(){
    pauseMain(); inGrace=false; stopContinuous();
    mainRemain = mainTotal; graceRemain = 0;
    updateMainDisplay(); setStatus(currentLang.statusIdle);
    applyBodyState(null); // <-- FIX: Reset body color
    syncOut();
  }
  function mainLoop(now){
    if(!mainRunning) return;
    const delta = now - lastFrame; lastFrame = now;
    if(inGrace){
      graceRemain += delta;
      if(graceRemain >= grace && !contBellInterval){
        ding(); contBellInterval=setInterval(ding, (+spaceInput.value || 250));
      }
      // Apply grace state animation during grace period
      if(++tick % 2 === 1) {
        applyBodyState('state-grace');
      }
    }else{
      mainRemain -= delta;
      // Bell checks (only on odd ticks, ~10fps)
      if(++tick % 2 === 1){
        if(firstBell > 0 && mainRemain <= (mainTotal - firstBell) && mainRemain+delta > (mainTotal - firstBell)) ding();
        if(secondBell > 0 && mainRemain <= (mainTotal - secondBell) && mainRemain+delta > (mainTotal - secondBell)) ding();
        
        // FIX: Check visual state *before* end of speech
        if(mainRemain <= 0) {
          triggerEndOfSpeech();
        } else {
          const warn = mainRemain <= yellow && mainRemain > red;
          const bad = mainRemain <= red;
          applyBodyState(bad ? 'state-bad' : (warn ? 'state-warn' : null));
        }
      }
    }
    updateMainDisplay();
    if(++tick % 5 === 1) syncOut(); // Sync ~2x/sec
    if(mainRunning) {
      mainLoopId = requestAnimationFrame(mainLoop);
    } else {
      mainLoopId = null;
    }
  }
  
  function triggerEndOfSpeech() {
    mainRemain = 0;
    inGrace = true;
    graceRemain = 0;
    // Apply grace state animation immediately
    applyBodyState('state-grace');
    // Play double bell
    ding();
    setTimeout(ding, (+spaceInput.value || 250));
  }
  
  function updateMainDisplay(){
    if(!clock || !fill) return;
    const r = inGrace ? graceRemain : mainRemain;
    clock.textContent = fmt(r);
    // FIX: Progress bar fills left-to-right
    const pct = inGrace ? 1 : (mainTotal > 0 ? clamp((mainTotal - mainRemain) / mainTotal, 0, 1) : 0);
    fill.style.transform = `scaleX(${pct})`;
  }
  
  // FIX: Scrubbing logic
  function scrubTo(e) {
    if (!mainProgress || mainTotal <= 0) return;
    if (e.preventDefault) e.preventDefault();
    const rect = mainProgress.getBoundingClientRect();
    if (!rect || rect.width <= 0) return;
    let clientX = e.clientX;
    if (e.touches && e.touches[0]) {
      clientX = e.touches[0].clientX; // Support touch
    }
    const pct = clamp((clientX - rect.left) / rect.width, 0, 1);
    // FIX: Scrubbing is based on pct (left-to-right)
    mainRemain = mainTotal * (1 - pct);
    
    if(inGrace) { inGrace = false; stopContinuous(); }
    
    // FIX: Update visual state immediately on scrub
    const warn = mainRemain <= yellow && mainRemain > red && mode === 'main' && !inGrace;
    const bad = mainRemain <= red && mainRemain > 0 && mode === 'main' && !inGrace;
    applyBodyState(bad ? 'state-bad' : (warn ? 'state-warn' : null));
    
    updateMainDisplay();
    // Force full sync after scrubbing to ensure presenter window gets updated state
    syncOut(true);
  }
  
  mainProgress.onpointerdown = e => {
    if (mainTotal <= 0) return;
    isScrubbing = true;
    if (mainRunning) pauseMain(true);
    mainProgress.setPointerCapture(e.pointerId);
    scrubTo(e);
  };
  
  mainProgress.onpointermove = e => {
    if (isScrubbing) scrubTo(e);
  };
  
  mainProgress.onpointerup = e => {
    if (!isScrubbing) return;
    mainProgress.releasePointerCapture(e.pointerId);
    isScrubbing = false;
    // Manually trigger one last scrubTo ensure sync
    scrubTo(e);
    // Force full sync after drag ends to ensure presenter window is updated
    syncOut(true);
  };
  
  // Add touch equivalents
  mainProgress.addEventListener('touchstart', (e) => {
     if (mainTotal <= 0) return;
     isScrubbing = true;
     if(mainRunning) pauseMain(true);
     scrubTo(e);
  }, { passive: false });
  
  mainProgress.addEventListener('touchmove', (e) => {
    if (isScrubbing) scrubTo(e);
  }, { passive: false });
  
  mainProgress.addEventListener('touchend', (e) => {
    isScrubbing = false;
    // Force full sync after touch drag ends
    syncOut(true);
  });

  // ---------- Timers: Quick ----------
  // Refactored to be cleaner
  function createQuickTimer(totalMs, clockEl, fillEl) {
    let remain = totalMs, running = false, last = 0, reqId = null;
    
    const update = () => {
      clockEl.textContent = fmt(remain);
      // FIX: Progress bar fills left-to-right
      fillEl.style.transform = `scaleX(${totalMs > 0 ? (totalMs - remain) / totalMs : 0})`;
    };

    const loop = (now) => {
      if (!running) return;
      remain -= (now - last);
      last = now;
      if (remain <= 0) {
        remain = 0;
        running = false;
        ding();
      }
      update();
      if (running) reqId = requestAnimationFrame(loop);
    };

    const start = () => {
      if (running || remain <= 0) return;
      running = true;
      last = performance.now();
      reqId = requestAnimationFrame(loop);
    };

    const reset = () => {
      if (reqId) cancelAnimationFrame(reqId);
      reqId = null;
      running = false;
      remain = totalMs;
      update();
    };
    
    reset(); // Initial render
    return { start, reset };
  }
  
  let cexTimer, rebTimer, prepTimer, poiTimer;

  // ---------- Speaker Progress & State ----------
  function buildSequence(base, settings){
    const seq = [];
    const prepTime = parseTime(settings.prep);
    const roundPrepTime = parseTime(settings.roundPrep);
    
    // Add initial round prep
    if(roundPrepTime > 0){
      seq.push({ role_en: 'Round Prep', role_ko: '라운드 준비', side: 'prep', initials: 'Prep', time: roundPrepTime });
    }
    
    // Add speeches
    base.forEach((spk,i)=>{
      // Add speech
      const isReply = spk.isReply || spk.role_en.toLowerCase().includes('reply');
      const time = parseTime(isReply ? settings.reb : settings.main);
      // Preserve active state from base array if it exists, otherwise default to true
      seq.push({ ...spk, time, type: isReply ? 'reply' : 'main', active: spk.active !== undefined ? spk.active : true });
      
      // Add prep time (if not last speaker and prep > 0)
      // FIX: Check for 'AP' (no prep)
      if(prepTime > 0 && i < base.length - 1 && currentFormat !== 'AP' && currentFormat !== 'WSDC' && currentFormat !== 'BP' && currentFormat !== 'PF' && currentFormat !== 'LD' && currentFormat !== 'CX') {
        seq.push({ role_en: 'Prep', role_ko: '준비 (다음)', side: 'prep', initials: 'Prep', time: prepTime, for: base[i+1].role_en });
      }
    });
    
    // Return sequence - active state is already preserved from base array
    return seq;
  }

  function renderSpeakerProgress(){
    spkBar.innerHTML = '';
    const lang = langSelect.value || 'en';
    const roleKey = `role_${lang}`;
    
    speakers.forEach((s,i)=>{
      const el=document.createElement('div');
      el.className = 'spk ' + (s.side || 'neutral');
      el.textContent = s[roleKey] || s.role_en;
      if(!s.active) el.classList.add('inactive');
      if(i === activeIdx) el.classList.add('active');
      el.onclick = ()=> selectSpeaker(i);
      el.ondblclick = ()=> toggleSpeaker(i);
      el.draggable = true;
      el.dataset.idx = i;
      spkBar.appendChild(el);
    });
  }
  
  // Drag & Drop
  spkBar.ondragstart = e => e.dataTransfer.setData('text/plain', e.target.dataset.idx);
  spkBar.ondragover = e => e.preventDefault();
  spkBar.ondrop = e => {
    e.preventDefault();
    const oldIdx = +e.dataTransfer.getData('text/plain');
    const target = e.target.closest('.spk');
    if(!target) return;
    const newIdx = +target.dataset.idx;
    if(oldIdx === newIdx) return;
    
    // Re-order array
    const [moved] = speakers.splice(oldIdx, 1);
    speakers.splice(newIdx, 0, moved);
    
    // Re-set active index
    activeIdx = speakers.findIndex(s => s.active && s.time === mainTotal);
    if(activeIdx < 0) activeIdx = newIdx;
    
    saveCustomPreset();
    renderSpeakerProgress();
    selectSpeaker(activeIdx);
  };
  
  function selectSpeaker(idx, fromBtn=false){
    if(idx < 0 || idx >= speakers.length) return;
    if(fromBtn && !speakers[idx].active) { // Skip inactive
      return selectSpeaker(idx + (fromBtn==='next'?1:-1), fromBtn);
    }
    
    activeIdx = idx;
    const s = speakers[activeIdx];
    if(!s) return;
    
    // Set timer type
    mode = (s.type === 'reply' || s.role_en.toLowerCase().includes('reply')) ? 'reply' : (s.side === 'prep' ? 'prep' : 'main');
    
    // Load times
    mainTotal = s.time;
    if(mode === 'main'){
      firstBell = parseTime(firstInput.value);
      secondBell = parseTime(secondInput.value);
      yellow = parseTime(yellowInput.value);
      red = parseTime(redInput.value);
      grace = parseTime(graceInput.value);
    } else {
      firstBell=0; secondBell=0; yellow=0; red=0; grace=0;
    }
    
    // Set UI
    const lang = langSelect.value || 'en';
    const roleKey = `role_${lang}`;
    mainTitle.textContent = s[roleKey] || s.role_en;
    metaEl.textContent = s.initials || '';
    if(s.side === 'prep' && s.for) {
      metaEl.textContent = `${currentLang.prepFor} ${s.for}`;
    }
    
    resetMain();
    renderSpeakerProgress();
    loadSpeakerNotes(); // Load notes for this speaker
    // Force full sync to presenter window to ensure state is cleared
    syncOut(true);
  }
  
  function toggleSpeaker(idx){
    speakers[idx].active = !speakers[idx].active;
    saveCustomPreset();
    renderSpeakerProgress();
  }
  
  nextBtn.onclick = ()=> selectSpeaker(activeIdx + 1, 'next');
  prevBtn.onclick = ()=> selectSpeaker(activeIdx - 1, 'prev');
  resetOrder.onclick = ()=> loadFormat(currentFormat, true);
  
  // ---------- Settings & Presets ----------
  function loadFormat(format, force=false){
    // Track previous format before switching
    const previousFormat = currentFormat;
    
    if(format === 'CUSTOM' && !force) {
      // Just load from storage, don't overwrite
      loadCustomPreset();
      return;
    }
    
    // If switching to CUSTOM, copy current format's settings and speakers BEFORE changing format
    if(format === 'CUSTOM' && previousFormat && previousFormat !== 'CUSTOM') {
      // Capture current settings from input fields
      const currentSettings = {
        main: mainInput.value, first: firstInput.value, second: secondInput.value,
        yellow: yellowInput.value, red: redInput.value, grace: graceInput.value,
        prep: prepInput.value, cex: cexInput.value, reb: rebInput.value, poi: poiInput.value,
        spacing: spaceInput.value, roundPrep: PRESETS[previousFormat]?.settings?.roundPrep || '0:00'
      };
      
      // Get current base speakers (no prep tokens) - capture BEFORE format changes
      let currentBaseSpeakers = speakers.filter(s => s.side !== 'prep').map(s => ({
        role_en: s.role_en,
        role_ko: s.role_ko,
        side: s.side,
        initials: s.initials,
        active: s.active !== undefined ? s.active : true,
        isReply: s.isReply || s.role_en?.toLowerCase().includes('reply') || false
      }));
      
      // If no speakers in current array, try to get them from the previous format's preset
      if(currentBaseSpeakers.length === 0 && PRESETS[previousFormat]) {
        const prevPreset = PRESETS[previousFormat];
        if(prevPreset.base && Array.isArray(prevPreset.base)) {
          currentBaseSpeakers = prevPreset.base.map(s => ({
            role_en: s.role_en,
            role_ko: s.role_ko,
            side: s.side,
            initials: s.initials,
            active: s.active !== undefined ? s.active : true,
            isReply: s.isReply || s.role_en?.toLowerCase().includes('reply') || false
          }));
        }
      }
      
      // Always save as custom preset when switching to CUSTOM (overwrites existing)
      if(currentBaseSpeakers.length > 0) {
        try {
          localStorage.setItem('debateCustomPreset', JSON.stringify({
            base: currentBaseSpeakers,
            settings: currentSettings
          }));
        } catch(e) {
          console.warn('Failed to save custom preset from previous format:', e);
        }
      } else {
        console.warn('No speakers found to copy when switching to CUSTOM format');
      }
    }
    
    // Load new preset
    currentFormat = format;
    
    // If it's CUSTOM, load the custom preset (which we just saved above)
    if(format === 'CUSTOM') {
      loadCustomPreset();
      
      // Ensure UI is updated
      renderSpeakerProgress();
      updateButtonStates();
      saveState();
      return; // Exit early for CUSTOM format
    }
    
    // Check if it's a custom format (stored in localStorage)
    const customFormat = getCustomFormat(format);
    if(customFormat) {
      // Load custom format
      const p = {
        base: customFormat.base,
        settings: customFormat.settings
      };
      
      // Apply settings
      Object.entries(p.settings).forEach(([key, val])=>{
        const input = $(`#${key}Input`);
        if(input) input.value = val;
      });
      
      // Build speaker sequence
      speakers = buildSequence(p.base, p.settings);
      speakers.forEach(s => s.active = true);
      
      // Re-init timers and UI
      initQuickTimers();
      selectSpeaker(0);
      saveState();
      return; // Exit early for custom format
    }
    
    // For built-in formats, load from PRESETS
    const p = PRESETS[format];
    if(!p) return;
    
    // Apply settings
    Object.entries(p.settings).forEach(([key, val])=>{
      const input = $(`#${key}Input`);
      if(input) input.value = val;
    });
    
    // Build speaker sequence
    // FIX: Force all speakers to be active on new preset load
    speakers = buildSequence(p.base, p.settings);
    speakers.forEach(s => s.active = true); // <-- HERE
    
    // Re-init timers and UI
    initQuickTimers();
    selectSpeaker(0);
    saveState();
  }
  
  function saveState(){
    const settings = {
      main: mainInput.value, first: firstInput.value, second: secondInput.value,
      yellow: yellowInput.value, red: redInput.value, grace: graceInput.value,
      prep: prepInput.value, cex: cexInput.value, reb: rebInput.value, poi: poiInput.value, spacing: spaceInput.value
    };
    try {
    localStorage.setItem('debateSettings', JSON.stringify(settings));
    localStorage.setItem('debateFormat', currentFormat);
    } catch(e) {
      console.warn('Failed to save state:', e);
    }
    
    // If custom, save speaker order
    if(currentFormat === 'CUSTOM'){
      saveCustomPreset();
    }
  }
  
  function loadState(){
    let fmt = 'SIMSON';
    try {
      fmt = localStorage.getItem('debateFormat') || 'SIMSON';
    formatSelect.value = fmt;
    
      const settingsStr = localStorage.getItem('debateSettings');
      if(settingsStr){
        const settings = JSON.parse(settingsStr);
    if(settings){
      Object.entries(settings).forEach(([key, val])=>{
        const input = $(`#${key}Input`);
        if(input) input.value = val;
      });
        }
      }
    } catch(e) {
      console.warn('Failed to load state:', e);
    }
    
    // Load format (this will load custom preset if fmt is CUSTOM)
    loadFormat(fmt);
    
    // Load language
    let lang = 'en';
    try {
      lang = localStorage.getItem('debateLang') || 'en';
    } catch(e) {
      console.warn('Failed to load language:', e);
    }
    langSelect.value = lang;
    setLanguage(lang);
  }
  
  function saveCustomPreset() {
    // Save only if on CUSTOM format
    if (currentFormat !== 'CUSTOM') return;
    
    const settings = {
      main: mainInput.value, first: firstInput.value, second: secondInput.value,
      yellow: yellowInput.value, red: redInput.value, grace: graceInput.value,
      prep: prepInput.value, cex: cexInput.value, reb: rebInput.value, poi: poiInput.value,
      spacing: spaceInput.value, roundPrep: '0:00' // Base custom doesn't have round prep
    };
    
    // Save the *current* speaker list (which may have been re-ordered)
    // Filter out prep tokens - only save actual speakers to preserve order
    const baseSpeakers = speakers.filter(s => s.side !== 'prep').map(s => ({
      role_en: s.role_en,
      role_ko: s.role_ko,
      side: s.side,
      initials: s.initials,
      active: s.active, // Save active state
      isReply: s.isReply || false
      // Don't save time, it's dynamic
    }));
    
    const customData = { base: baseSpeakers, settings: settings };
    try {
    localStorage.setItem('debateCustomPreset', JSON.stringify(customData));
    } catch(e) {
      console.warn('Failed to save custom preset:', e);
    }
  }
  
  function loadCustomPreset() {
    try {
      const customDataStr = localStorage.getItem('debateCustomPreset');
      if (!customDataStr) {
      // No custom data, just use default empty custom
      speakers = [];
      renderSpeakerProgress();
      return;
    }
      
      const customData = JSON.parse(customDataStr);
      if (!customData) {
      speakers = [];
      renderSpeakerProgress();
      return;
    }
    
    // Apply settings
      if(customData.settings) {
    Object.entries(customData.settings).forEach(([key, val])=>{
      const input = $(`#${key}Input`);
      if(input) input.value = val;
    });
      }
    
    // Build speaker sequence from *saved* base speakers
      if(customData.base) {
        speakers = buildSequence(customData.base, customData.settings || {});
    initQuickTimers();
    selectSpeaker(0);
      } else {
        speakers = [];
        renderSpeakerProgress();
      }
    } catch(e) {
      console.warn('Failed to load custom preset:', e);
      speakers = [];
      renderSpeakerProgress();
    }
  }
  
  formatSelect.onchange = () => loadFormat(formatSelect.value, true);
  $$('#settingsPanel input').forEach(el => el.onchange = saveState);
  
  // ---------- Custom Format Management ----------
  // Store custom formats in localStorage with unique IDs
  function getCustomFormats() {
    try {
      const stored = localStorage.getItem('debateCustomFormats');
      return stored ? JSON.parse(stored) : {};
    } catch(e) {
      console.warn('Failed to load custom formats:', e);
      return {};
    }
  }
  
  function saveCustomFormats(formats) {
    try {
      localStorage.setItem('debateCustomFormats', JSON.stringify(formats));
    } catch(e) {
      console.warn('Failed to save custom formats:', e);
    }
  }
  
  function addCustomFormat(formatId, formatLabel, base, settings) {
    const formats = getCustomFormats();
    formats[formatId] = {
      label: formatLabel,
      base: base,
      settings: settings,
      created: new Date().toISOString()
    };
    saveCustomFormats(formats);
    updateFormatDropdown();
  }
  
  function getCustomFormat(formatId) {
    const formats = getCustomFormats();
    return formats[formatId] || null;
  }
  
  function formatIdExists(formatId) {
    const formats = getCustomFormats();
    return formatId in formats;
  }
  
  function generateFormatId(label) {
    // Create a safe ID from label: lowercase, replace spaces with underscores, remove special chars
    let id = label.toLowerCase()
      .replace(/\s+/g, '_')
      .replace(/[^a-z0-9_]/g, '')
      .substring(0, 20);
    
    // Ensure it doesn't conflict with built-in formats
    const builtInFormats = ['SIMSON', 'AP', 'BP', 'WSDC', 'PF', 'CX', 'LD', 'CUSTOM'];
    if (builtInFormats.includes(id.toUpperCase())) {
      id = 'custom_' + id;
    }
    
    // Check for duplicates and append number if needed
    let finalId = id;
    let counter = 1;
    while (formatIdExists(finalId)) {
      finalId = id + '_' + counter;
      counter++;
    }
    
    return finalId;
  }
  
  function updateFormatDropdown() {
    const customFormats = getCustomFormats();
    const formatSelect = $('#formatSelect');
    
    // Remove existing custom format options (keep built-in ones)
    const builtInValues = ['AP', 'BP', 'WSDC', 'PF', 'CX', 'LD', 'SIMSON', 'CUSTOM'];
    Array.from(formatSelect.options).forEach(opt => {
      if (!builtInValues.includes(opt.value)) {
        opt.remove();
      }
    });
    
    // Add custom formats before CUSTOM option (Simson is above Custom)
    const customOption = formatSelect.querySelector('option[value="CUSTOM"]');
    Object.entries(customFormats).forEach(([id, format]) => {
      const option = document.createElement('option');
      option.value = id;
      option.textContent = format.label || id;
      formatSelect.insertBefore(option, customOption);
    });
  }
  
  function purgeAllCustomFormats() {
    const customFormats = getCustomFormats();
    const formatCount = Object.keys(customFormats).length;
    
    if (formatCount === 0) {
      setStatus('No custom formats to purge');
      return;
    }
    
    const confirmed = confirm(
      `Are you sure you want to delete all ${formatCount} custom format(s)?\n\n` +
      `This action cannot be undone.`
    );
    
    if (confirmed) {
      try {
        localStorage.removeItem('debateCustomFormats');
        updateFormatDropdown();
        
        // If current format is a custom format, switch to default
        const customFormat = getCustomFormat(currentFormat);
        if (customFormat) {
          formatSelect.value = 'AP';
          loadFormat('AP');
        }
        
        setStatus(`Successfully purged ${formatCount} custom format(s)`);
      } catch(e) {
        console.error('Failed to purge custom formats:', e);
        setStatus('Failed to purge custom formats');
      }
    }
  }
  
  // ---------- Settings Import/Export ----------
  exportBtn.onclick = async () => {
    // Export works for ALL formats - exports current state including any modifications
    if (!currentFormat) {
      setStatus('Error: No format selected');
      return;
    }
    
    // Get roundPrep value - check custom preset if CUSTOM, otherwise use format default
    let roundPrep = '0:00';
    if (currentFormat === 'CUSTOM') {
      try {
        const customPreset = localStorage.getItem('debateCustomPreset');
        if (customPreset) {
          const parsed = JSON.parse(customPreset);
          roundPrep = parsed.settings?.roundPrep || '0:00';
        }
      } catch(e) {
        // Use default
      }
    } else {
      // Check if it's a custom format
      const customFormat = getCustomFormat(currentFormat);
      if (customFormat) {
        roundPrep = customFormat.settings?.roundPrep || '0:00';
      } else {
        // For built-in formats, use the format's default roundPrep
        roundPrep = PRESETS[currentFormat]?.settings?.roundPrep || '0:00';
      }
    }
    
    // Export *current* settings from input fields (captures any user modifications)
    const settings = {
      main: mainInput.value, first: firstInput.value, second: secondInput.value,
      yellow: yellowInput.value, red: redInput.value, grace: graceInput.value,
      prep: prepInput.value, cex: cexInput.value, reb: rebInput.value, poi: poiInput.value,
      spacing: spaceInput.value, roundPrep: roundPrep
    };
    
    // Get base speakers from current speakers array (no prep tokens)
    // This captures the current state, including any reordering or modifications
    const baseSpeakers = speakers.filter(s => s.side !== 'prep').map(s => ({
      role_en: s.role_en,
      role_ko: s.role_ko,
      side: s.side,
      initials: s.initials,
      active: s.active,
      isReply: s.role_en?.toLowerCase().includes('reply') || false
    }));
    
    // Validate we have data to export
    if (baseSpeakers.length === 0) {
      setStatus('Error: No speakers to export');
      return;
    }
    
    // Create format object compatible with format builder
    let formatLabel;
    if (currentFormat === 'CUSTOM') {
      formatLabel = 'Custom';
    } else {
      // Check if it's a custom format
      const customFormat = getCustomFormat(currentFormat);
      if (customFormat) {
        formatLabel = customFormat.label || currentFormat + ' Format';
      } else {
        // Built-in format
        formatLabel = PRESETS[currentFormat]?.label || currentFormat + ' Format';
      }
    }
    
    const format = {
      label: formatLabel,
      base: baseSpeakers,
      settings: settings
    };
    
    // Enhanced export with metadata (compatible with format builder)
    const data = {
      format: format,
      formatId: currentFormat,
      metadata: {
        created: new Date().toISOString(),
        version: '1.0',
        exportedFrom: 'Debate Timer App'
      },
      // Legacy format for backward compatibility
      base: baseSpeakers,
      settings: settings
    };
    
    const jsonString = JSON.stringify(data, null, 2);
    const blob = new Blob([jsonString], {type: 'application/json'});
    
    // Generate filename based on format
    let filename;
    if (currentFormat === 'CUSTOM') {
      filename = 'custom_format.json';
    } else {
      const customFormat = getCustomFormat(currentFormat);
      if (customFormat) {
        // Use format label for custom formats (sanitized for filename)
        const sanitized = formatLabel.toLowerCase()
          .replace(/\s+/g, '_')
          .replace(/[^a-z0-9_]/g, '')
          .substring(0, 30);
        filename = `${sanitized}.json`;
      } else {
        filename = `${currentFormat.toLowerCase()}_format.json`;
      }
    }
    
    try {
      // Try using File System Access API if available (modern browsers)
      if ('showSaveFilePicker' in window) {
        const fileHandle = await window.showSaveFilePicker({
          suggestedName: filename,
          types: [{
            description: 'JSON files',
            accept: { 'application/json': ['.json'] }
          }]
        });
        const writable = await fileHandle.createWritable();
        await writable.write(blob);
        await writable.close();
        setStatus('Format exported successfully! File: ' + filename);
        return;
      }
    } catch (err) {
      // User cancelled or API not available, fall through to download method
      if (err.name !== 'AbortError') {
        console.log('File System Access API not available, using download method');
      }
    }
    
    // Fallback: Create download link and trigger download
    try {
    const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = filename;
      a.style.display = 'none';
      
      // Add to DOM, click, then remove (required for some browsers)
      document.body.appendChild(a);
    a.click();
      
      // Clean up after a short delay
      setTimeout(() => {
        if (document.body.contains(a)) {
          document.body.removeChild(a);
        }
        URL.revokeObjectURL(url);
      }, 100);
      
      setStatus('Format exported successfully! File: ' + filename);
    } catch (err) {
      console.error('Export failed:', err);
      // Last resort: show JSON in alert/console for manual copy
      setStatus('Export failed. Check console for JSON data.');
      console.log('Export Data:', jsonString);
      alert('Download failed. The JSON data has been logged to the console. Press F12 to view it.');
    }
  };
  
  importBtn.onclick = () => importFile.click();
  importFile.onchange = e => {
    const file = e.target.files[0];
    if(!file) return;
    
    // Extract filename without extension as default name
    const fileName = file.name;
    const defaultName = fileName.replace(/\.[^/.]+$/, ''); // Remove extension
    
    const reader = new FileReader();
    reader.onerror = () => {
      console.error('Failed to read file');
      setStatus('Failed to read file');
    };
    reader.onload = e => {
      try {
        const data = JSON.parse(e.target.result);
        
        // Handle new format builder format (with format object and metadata)
        let importData, suggestedLabel, originalFormatId;
        if (data.format) {
          // New format builder format
          importData = {
            base: data.format.base || [],
            settings: data.format.settings || {}
          };
          suggestedLabel = data.format.label || defaultName;
          originalFormatId = data.formatId;
        } else if (data.base && data.settings) {
          // Legacy format (backward compatible)
          importData = data;
          suggestedLabel = defaultName;
          originalFormatId = null;
        } else {
          throw new Error('Invalid format: Missing base or settings');
        }
        
        // Validate required fields
        if (!importData.base || !Array.isArray(importData.base)) {
          throw new Error('Invalid format: base must be an array');
        }
        if (!importData.settings || typeof importData.settings !== 'object') {
          throw new Error('Invalid format: settings must be an object');
        }
        
        // Always prompt for format name
        let formatLabel = prompt(
          `Enter a name for this format:`,
          suggestedLabel
        );
        
        if (!formatLabel || formatLabel.trim() === '') {
          setStatus('Import cancelled');
          e.target.value = null;
          return;
        }
        
        formatLabel = formatLabel.trim();
        
        // Check for duplicate format name
        const customFormats = getCustomFormats();
        let formatId = generateFormatId(formatLabel);
        let existingFormat = null;
        
        // Check if a format with the same label already exists
        for (const [id, format] of Object.entries(customFormats)) {
          if (format.label === formatLabel) {
            existingFormat = { id, format };
            break;
          }
        }
        
        // If duplicate found, prompt user
        if (existingFormat) {
          const userChoice = confirm(
            `A format named "${formatLabel}" already exists.\n\n` +
            `Click OK to overwrite it, or Cancel to cancel the import.`
          );
          
          if (userChoice) {
            // Overwrite existing format
            formatId = existingFormat.id;
            addCustomFormat(formatId, formatLabel, importData.base, importData.settings);
            setStatus(`Format "${formatLabel}" overwritten successfully!`);
          } else {
            setStatus('Import cancelled');
            e.target.value = null;
            return;
          }
        } else {
          // No duplicate, add as new format
          addCustomFormat(formatId, formatLabel, importData.base, importData.settings);
          setStatus(`Format "${formatLabel}" imported successfully!`);
        }
        
        // Switch to the imported format and load it
        formatSelect.value = formatId;
        loadFormat(formatId);
        
      } catch (err) {
        console.error('Failed to import settings:', err);
        setStatus('Invalid file format: ' + err.message);
      }
    };
    reader.readAsText(file);
    e.target.value = null; // Clear input
  };
  
  purgeCustomFormatsBtn.onclick = () => purgeAllCustomFormats();
  
  // ---------- Notes Import/Export/Clear ----------
  function getNoteKey(format, speaker) {
    if (!speaker) return null;
    return `${format}_${speaker.role_en}`;
  }
  
  function saveSpeakerNotes() {
    const s = speakers[activeIdx];
    if (!s || s.side === 'prep') return; // Don't save for prep
    
    const key = getNoteKey(currentFormat, s);
    if (!key) return;
    
    allNotes[key] = notesArea.value;
    try {
    localStorage.setItem('debateNotes', JSON.stringify(allNotes));
    } catch(e) {
      console.warn('Failed to save notes:', e);
    }
    // Update button state to show if notes exist (colors controlled by CSS)
    const hasNotes = !!notesArea.value;
    toggleNotesBtn.classList.toggle('has-notes', hasNotes);
  }
  
  function loadSpeakerNotes() {
    let s = speakers[activeIdx];
    let isPrep = false;
    
    if (s && s.side === 'prep') {
      // If prep, show notes for *next* speaker
      const nextSpeaker = speakers.find((spk, i) => i > activeIdx && spk.active && spk.side !== 'prep');
      if (nextSpeaker) {
        s = nextSpeaker;
        isPrep = true;
      } else {
        s = null; // No next speaker
      }
    }
    
    if (!s) {
      notesArea.value = '';
      notesArea.disabled = true;
      toggleNotesBtn.classList.remove('has-notes'); // Remove cue if no speaker
      return;
    }
    
    const key = getNoteKey(currentFormat, s);
    const note = allNotes[key] || '';
    notesArea.value = note;
    
    // Disable if in prep mode
    notesArea.disabled = isPrep;
    notesArea.placeholder = isPrep ? '' : currentLang.notesPlaceholder;
    
    // Update button state to show if notes exist (colors controlled by CSS)
    const hasNotes = !!note;
    toggleNotesBtn.classList.toggle('has-notes', hasNotes);
  }
  
  notesArea.oninput = saveSpeakerNotes;
  
  exportNotesBtn.onclick = () => {
    let txt = `Debate Timer Notes\n====================\n\n`;
    const formats = {};
    
    // Group by format
    Object.keys(allNotes).forEach(key => {
      const [format, ...speakerParts] = key.split('_');
      const speaker = speakerParts.join('_');
      if (!formats[format]) formats[format] = [];
      formats[format].push({ speaker, note: allNotes[key] });
    });
    
    // Build text file
    Object.keys(formats).sort().forEach(format => {
      txt += `== ${format} ==\n\n`;
      formats[format].forEach(({ speaker, note }) => {
        if (note && note.trim()) {
          txt += `## ${speaker} ##\n${note}\n\n`;
        }
      });
    });
    
    const blob = new Blob([txt], {type: 'text/plain'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'debate_timer_notes.txt';
    a.click();
    URL.revokeObjectURL(a.href);
  };
  
  importNotesBtn.onclick = () => importNotesFile.click();
  importNotesFile.onchange = e => {
    const file = e.target.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onerror = () => {
      console.error('Failed to read notes file');
      setStatus('Failed to read file');
    };
    reader.onload = e => {
      try {
        const importedNotes = JSON.parse(e.target.result);
        if(!importedNotes || typeof importedNotes !== 'object') {
          throw new Error('Invalid format');
        }
        // Merge with existing notes
        allNotes = { ...allNotes, ...importedNotes };
        try {
        localStorage.setItem('debateNotes', JSON.stringify(allNotes));
        loadSpeakerNotes(); // Refresh view
          setStatus('Notes imported successfully');
        } catch(storageErr) {
          console.error('Failed to save imported notes:', storageErr);
          setStatus('Failed to save notes');
        }
      } catch (err) {
        console.error('Failed to import notes:', err);
        setStatus('Invalid file format');
      }
    };
    reader.readAsText(file);
    e.target.value = null; // Clear input
  };
  
  clearNotesBtn.onclick = () => {
    showConfirm(
      currentLang.confirmClearNotesTitle,
      currentLang.confirmClearNotesText,
      () => {
        allNotes = {};
        try {
        localStorage.removeItem('debateNotes');
        } catch(e) {
          console.warn('Failed to clear notes:', e);
        }
        loadSpeakerNotes(); // Refresh view
      }
    );
  };

  // ---------- Quick Timer Init ----------
  function initQuickTimers(){
    cexTimer = createQuickTimer(parseTime(cexInput.value), cexClock, cexFill);
    rebTimer = createQuickTimer(parseTime(rebInput.value), rebClock, rebFill);
    prepTimer = createQuickTimer(parseTime(prepInput.value), prepClock, prepFill);
    poiTimer = createQuickTimer(parseTime(poiInput.value), poiClock, poiFill);
  }
  cexStart.onclick = ()=>cexTimer.start(); cexReset.onclick = ()=>cexTimer.reset();
  rebStart.onclick = ()=>rebTimer.start(); rebReset.onclick = ()=>rebTimer.reset();
  prepStart.onclick = ()=>prepTimer.start(); prepReset.onclick = ()=>prepTimer.reset();
  poiStart.onclick = ()=>poiTimer.start(); poiReset.onclick = ()=>poiTimer.reset();

  // ---------- Panel Toggles ----------
  function togglePanel(panel, btn, key) {
    const isOpen = panel.style.maxHeight !== '0px';
    if (isOpen) {
      panel.style.maxHeight = '0px';
      if (panel === notesPanel) { // Special handling for notes padding
        panel.style.paddingTop = '0px';
        panel.style.paddingBottom = '0px';
        panel.style.borderWidth = '0px';
        toggleNotesBtn.classList.add('panel-hidden');
      }
    } else {
      // ********** THIS IS THE FIX **********
      panel.style.maxHeight = '500px'; // Use CSS max-height, not scrollHeight
      // ***********************************
      if (panel === notesPanel) {
        panel.style.paddingTop = '16px';
        panel.style.paddingBottom = '16px';
        panel.style.borderWidth = '1px';
        toggleNotesBtn.classList.remove('panel-hidden');
      }
    }
    // Update button text/title
    if(btn) updateButtonStates();
    // Update button active state
    if (btn && btn.classList.contains('btn-icon')) {
      if (btn === toggleQuickTimers) {
      btn.classList.toggle('active', !isOpen);
      }
      // Notes button: no active class needed, colors controlled by CSS
      // The active class is not used for notes button color inversion
    }
  }

  toggleSettings.onclick = () => togglePanel(settingsPanel, toggleSettings, 'settings');
  toggleQuickTimers.onclick = () => togglePanel(quickTimersPanel, toggleQuickTimers, 'quickTimers');
  toggleNotesBtn.onclick = () => togglePanel(notesPanel, toggleNotesBtn, 'notes');

  // ---------- Confirmation Modal ----------
  let confirmCallback = null;
  function showConfirm(title, text, onConfirm) {
    confirmTitle.textContent = title;
    confirmText.textContent = text;
    confirmCallback = onConfirm;
    confirmModal.style.display = 'flex';
  }
  confirmCancel.onclick = () => {
    confirmModal.style.display = 'none';
    confirmCallback = null;
  };
  confirmOK.onclick = () => {
    confirmModal.style.display = 'none';
    if(confirmCallback) confirmCallback();
    confirmCallback = null;
  };

  // ---------- Event Listeners ----------
  startBtn.onclick = startMain;
  resetBtn.onclick = resetMain;
  singleBtn.onclick = () => ding();
  doubleBtn.onclick = () => { ding(); setTimeout(ding, (+spaceInput.value || 250)); };
  testContBtn.onclick = () => { if(contBellInterval) return; ding(); contBellInterval=setInterval(ding, (+spaceInput.value || 250)); };
  stopBellBtn.onclick = () => {
    stopContinuous();
    if(inGrace) {
      inGrace = false;
      mainRemain = 0;
      graceRemain = 0;
      pauseMain(true);
      applyBodyState(null); // <-- FIX: Reset body color
      updateMainDisplay();
      setStatus(currentLang.statusIdle);
      syncOut();
    }
  };
  
  langSelect.onchange = () => {
    setLanguage(langSelect.value);
    // Reload format to get correct language names for prep
    loadFormat(currentFormat); 
  };
  
  window.addEventListener('keydown', e => {
    // FIX: Don't run shortcuts if user is typing
    const targetTag = e.target.tagName.toLowerCase();
    if (targetTag === 'input' || targetTag === 'textarea' || targetTag === 'select') {
      return; // Block all shortcuts if typing
    }
    
    switch(e.key.toLowerCase()){
      case ' ': e.preventDefault(); startBtn.click(); break;
      case 'r': e.preventDefault(); resetBtn.click(); break;
      case 'arrowright': e.preventDefault(); nextBtn.click(); break;
      case 'arrowleft': e.preventDefault(); prevBtn.click(); break;
      case '1': e.preventDefault(); singleBtn.click(); break;
      case '2': e.preventDefault(); doubleBtn.click(); break;
      case 'm': e.preventDefault(); muteBtn.click(); break;
      case 'd': e.preventDefault(); themeBtn.click(); break;
      case 'p': e.preventDefault(); presenterBtn.click(); break;
      case 'h': e.preventDefault(); helpBtn.click(); break;
    }
  });
  
  // ---------- Help Modal Listeners (FIXED) ----------
  helpBtn.onclick = () => helpModal.style.display = 'flex';
  closeHelp.onclick = () => helpModal.style.display = 'none';

  // ---------- Initialization ----------
  function init() {
    // Load notes first
    try {
      const notesStr = localStorage.getItem('debateNotes');
      if(notesStr) {
        allNotes = JSON.parse(notesStr) || {};
      } else {
        allNotes = {};
      }
    } catch(e) {
      console.warn('Failed to load notes:', e);
      allNotes = {};
    }
    
    // Load custom formats into dropdown
    updateFormatDropdown();
    
    // Load state (format, settings)
    loadState(); // This calls loadFormat, which calls initQuickTimers and selectSpeaker
    
    // FIX: Set theme *after* state is initialized
    try {
      const theme = localStorage.getItem('debateTheme');
      setDark(theme === 'dark');
    } catch(e) {
      console.warn('Failed to load theme:', e);
    }
    
    // Hide panels by default
    if(settingsPanel) settingsPanel.style.maxHeight = '0px';
    if(quickTimersPanel) quickTimersPanel.style.maxHeight = '0px';
    if(notesPanel) {
    notesPanel.style.maxHeight = '0px';
    notesPanel.style.paddingTop = '0px';
    notesPanel.style.paddingBottom = '0px';
    notesPanel.style.borderWidth = '0px';
      if(toggleNotesBtn) toggleNotesBtn.classList.add('panel-hidden');
    }

    updateButtonStates();
  }
  
  init();
})();
</script>

</body></html>
