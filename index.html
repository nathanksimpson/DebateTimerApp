<!doctype html>
<html lang="en"> <!-- Set initial lang -->
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title data-lang-title="pageTitle">AP Debate Timer — HTML</title> <!-- Added data-lang-title -->
<style>
  :root{
    --bg-green:#d1fae5; --fg-green:#064e3b; --bd-green:#34d399;
    --bg-yellow:#fef3c7; --fg-yellow:#92400e; --bd-yellow:#f59e0b;
    --bg-red:#fecaca; --fg-red:#7f1d1d; --bd-red:#f87171;
    --bg-card:#ffffff; --bd:#e5e7eb; --fg:#111827; --muted:#6b7280;
    --track:#e5e7eb; --fill:#111827;
  }
  html,body{height:100%}
  body{margin:0;font:16px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";}
  .wrap{min-height:100%;display:flex;flex-direction:column;align-items:center;gap:24px;padding:24px;transition:background-color .25s,color .25s; box-sizing: border-box;} /* Added box-sizing */
  .container{width:100%;max-width:1000px;display:flex;flex-direction:column;gap:16px}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px; flex-wrap: wrap;} /* Added flex-wrap */
  h1{font-size:24px;margin:0}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .btn{appearance:none;border:1px solid var(--bd);background:#fff;border-radius:12px;padding:10px 14px;cursor:pointer;display:inline-flex;align-items:center;gap:8px;font-weight:600}
  .btn:active{transform:translateY(1px)}
  .card{background:var(--bg-card);border:1px solid var(--bd);border-radius:16px;padding:16px}
  .title{font-weight:700}
  .muted{color:var(--muted)}
  .clock{font-size:76px;font-weight:900;text-align:center; line-height: 1.1;} /* Added line-height */
  
  /* Main Progress Bar */
  .progress{
    height:12px;
    background:var(--track);
    border-radius:999px;
    position:relative;
    overflow:hidden;
    display: flex; /* <-- ADDED: This lays out the bell segments horizontally */
    cursor: pointer; /* NEW: Add pointer cursor */
  }
  .fill{
    position:absolute;
    left:0;
    top:0; /* Added */
    bottom:0; /* Added */
    background:var(--fill); /* Added */
  } /* <-- THIS BRACE WAS MISSING */

  /* Speaker Progress Bar Styles */
  .speaker-progress-bar {
    display: flex; /* Changed from grid to flex */
    flex-wrap: wrap; /* Added wrap */
    gap: 4px;
    border-radius: 8px;
    background-color: var(--track);
    padding: 4px;
  }
  .speaker-box {
    font-size: 12px; /* Increased from 11px */
    font-weight: 700;
    padding: 8px 4px;
    border-radius: 6px;
    text-align: center;
    background-color: #fff;
    border: 1px solid var(--bd);
    cursor: grab;
    user-select: none;
    -webkit-user-select: none; /* Added prefix for iOS */
    transition: background-color 0.2s, box-shadow 0.2s, opacity 0.2s;
    flex: 1 1 50px; /* Added flex-basis for responsiveness */
    min-width: 50px; /* Ensures a minimum tap target size */
  }
  .speaker-box:active { cursor: grabbing; }
  .speaker-box.team-prop, .speaker-box.team-gov, .speaker-box.team-aff { color: #15803d; border-color: #86efac; } /* Added Aff */
  .speaker-box.team-opp, .speaker-box.team-neg { color: #b91c1c; border-color: #fca5a5; } /* Added Neg */
  .speaker-box.team-none { color: #374151; border-color: #d1d5db; }
  .speaker-box.active-speaker {
    box-shadow: 0 0 0 3px var(--fg, #111827);
    font-weight: 900;
  }
  
  /* New styles for drag/drop and inactive */
  .speaker-box.dragging {
    opacity: 0.5;
    background: #e0f2fe;
  }
  .speaker-box.drag-over {
    background: #fef9c3;
    border-style: dashed;
  }
  .speaker-box.inactive {
    opacity: 0.4;
    background: #f3f4f6;
    text-decoration: line-through;
    cursor: not-allowed;
  }

  /* New Help Modal Styles */
  #helpModal {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 16px;
    z-index: 100;
  }
  #helpModal .card {
    max-width: 600px;
    width: 100%;
    max-height: 90vh;
    overflow-y: auto;
  }
  #helpModal h2 {
    margin: 0 0 12px 0;
    font-size: 20px;
  }
  #helpModal p, #helpModal ul {
    margin: 8px 0;
    line-height: 1.6;
  }
  #helpModal li {
    margin-bottom: 6px;
  }
  #helpModal .row {
    justify-content: flex-end;
    margin-top: 16px;
  }

  /* NEW: Add cursor to mini-timer bars */
  .bar {
    cursor: pointer;
  }

  /* Responsive Media Queries */
  @media (max-width:800px){
    .grid-3, .grid-4 { grid-template-columns:repeat(2,minmax(0,1fr)) } /* 2 cols */
  }
  
  @media (max-width: 600px) {
    .grid-3, .grid-4 { grid-template-columns: 1fr } /* 1 col */
    .clock { font-size: 60px; } /* Scale down large clock */
    .caps { grid-template-columns: 1fr; } /* Stack bell time caps */
  }
  
  @media (max-width: 400px) {
    .clock { font-size: 48px; } /* Scale down large clock further */
    .btn { padding: 8px 10px; font-size: 14px; } /* Make buttons slightly smaller */
  }
</style>
</head>
<body>
  <!-- 
    Persistent, silent <audio> tag to unlock audio on iOS.
  -->
  <audio id="silentUnlockAudio" src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=" loop muted playsinline></audio>

  <div id="app" class="wrap">
    <div class="container">
      <header>
        <h1><span data-lang="appTitle">Debate Timer</span></h1>
        <div class="row">
          <button id="helpBtn" class="btn" data-lang="help">Help</button>
          <button id="langToggleBtn" class="btn">한국어</button>
          <button id="settingsBtn" class="btn" data-lang="toggleSettings">Toggle Settings</button>
          
          <!-- Mute Button -->
          <button id="muteBtn" class="btn">
            <svg id="muteIconOn" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="width: 20px; height: 20px; stroke-width: 2; fill: none; stroke: currentColor; stroke-linecap: round; stroke-linejoin: round;">
              <path d="M11 5L6 9H2v6h4l5 4V5zM15.54 8.46a5 5 0 0 1 0 7.07"></path>
            </svg>
            <svg id="muteIconOff" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="width: 20px; height: 20px; stroke-width: 2; fill: none; stroke: currentColor; stroke-linecap: round; stroke-linejoin: round; display: none;">
              <path d="M11 5L6 9H2v6h4l5 4V5zM23 9l-6 6M17 9l6 6"></path>
            </svg>
          </button>
          
          <button id="enableBtn" class="btn" data-lang="enableSound">Initialize Sound</button>
          <button id="testsBtn" class="btn" data-lang="tests">Tests</button>
          
          <!-- Volume Slider -->
          <label class="label" style="flex-direction: row; align-items: center; gap: 8px; margin-left: 8px;">
            <span data-lang="volume" style="font-weight: 600;">Volume</span>
            <input id="volumeInput" type="range" min="0" max="1" step="0.05" value="0.5" style="width: 80px;" />
          </label>
        </div>
      </header>
      
      <!-- Collapsible Settings Card -->
      <div class="card" id="settingsContainer" style="display:none">
        <!-- Profile Management -->
        <div class="card" style="margin-bottom: 16px;">
          <div class="title" style="margin-bottom:8px" data-lang="profiles">Profiles</div>
          <div class="grid grid-4" style="align-items:flex-end;">
            <label class="label"><span data-lang="loadProfile">Load Profile</span>
              <select id="profileSelect" class="input"></select>
            </label>
            <button id="loadProfileBtn" class="btn" data-lang="load">Load</button>
            <button id="saveProfileBtn" class="btn" data-lang="saveCurrent">Save Current</button>
            <button id="deleteProfileBtn" class="btn" style="background-color: var(--bg-red); color: var(--fg-red);" data-lang="deleteSelected">Delete Selected</button>
          </div>
          <div class="row" style="margin-top: 12px;">
            <button id="exportProfilesBtn" class="btn" data-lang="exportAll">Export All</button>
            <label class="btn">
              <span data-lang="import">Import</span>
              <input id="importProfilesInput" type="file" accept=".json" style="display:none" />
            </label>
          </div>
        </div>

        <!-- Timer Settings -->
        <div class="card">
          <div class="title" style="margin-bottom:8px" data-lang="timerSettings">Timer Settings</div>
          <div class="grid grid-3">
            <label class="label"><span data-lang="mainTime">Main (m:ss)</span>
              <input id="mainInput" class="input" value="3:00" />
            </label>
            <label class="label"><span data-lang="firstBell">1st Bell from start (m:ss)</span>
              <input id="firstInput" class="input" value="1:00" />
            </label>
            <label class="label"><span data-lang="secondBell">2nd Bell from start (m:ss)</span>
              <input id="secondInput" class="input" value="2:00" />
            </label>
            <label class="label"><span data-lang="yellowTime">Yellow at remaining (m:ss)</span>
              <input id="yellowInput" class="input" value="1:00" />
            </label>
            <label class="label"><span data-lang="redTime">Red at remaining (m:ss)</span>
              <input id="redInput" class="input" value="0:30" />
            </label>
            <label class="label"><span data-lang="gracePeriod">Grace Period (m:ss)</span>
              <input id="graceInput" class="input" value="0:30" />
            </label>
            
            <!-- Quick Timer Inputs -->
            <label class="label"><span data-lang="prepTime">Prep Time (m:ss)</span>
              <input id="prepInput" class="input" value="20:00" />
            </label>
            <label class="label"><span data-lang="cexTime">Cross-Ex / Shared (m:ss)</span>
              <input id="cexInput" class="input" value="1:00" />
            </label>
            <label class="label"><span data-lang="rebTime">Rebuttal / Reply (m:ss)</span>
              <input id="rebInput" class="input" value="3:00" />
            </label>
            
            <!-- Audio Settings -->
            <label class="label"><span data-lang="bellSpacing">Bell spacing (ms)</span>
              <input id="spaceInput" class="input" value="100" />
            </label>
            <label class="label"><span data-lang="bellMode">Bell mode</span>
              <select id="modeSel" class="input"></select>
            </label>
            <label class="label"><span data-lang="mp3Url">MP3 URL</span>
              <input id="mp3Url" class="input" placeholder="https://example.com/bell.mp3" />
            </label>
            <label class="label"><span data-lang="uploadSounds">Upload Sound(s)</span>
              <input id="mp3File" type="file" accept="audio/*" multiple />
            </label>
          </div>
        </div>
      </div>

      <!-- Speaker Progress -->
      <div class="card">
        <div class="title" style="margin-bottom:8px" data-lang="speakerProgress">Speaker Progress</div>
        <div class="speaker-progress-bar" id="speakerProgress"></div>
        <div class="row" style="justify-content:space-between;margin-top:8px">
          <div>
            <button id="prevSpeakerBtn" class="btn" data-lang="previous">Previous</button>
            <button id="nextSpeakerBtn" class="btn" data-lang="next">Next</button>
          </div>
          <div id="prepTimerContainer" class="row">
            <div class="clock" id="prepClock" style="font-size:20px;font-weight:700;padding:0 8px">20:00</div>
            <button id="prepStart" class="btn" data-lang="start">Start</button>
            <button id="prepReset" class="btn" data-lang="reset">Reset</button>
          </div>
          <button id="resetOrderBtn" class="btn" data-lang="resetOrder">Reset Order</button>
        </div>
        <div class="bar" style="margin-top:8px"><div class="bfill" id="prepFill" style="width:0%"></div></div>
        <div class="note" data-lang="speakerNote">Click to select, Double-click to toggle, Drag to reorder.</div>
      </div>

      <!-- Main Timer Card -->
      <div class="card" id="mainSpeechCard">
        <div class="row" style="justify-content:space-between">
          <div class="title" id="modeLabel" data-lang="substantiveSpeech">Substantive Speech</div>
          <div class="muted" id="meta"></div>
        </div>
        <div class="clock" id="clock">3:00</div>
        <div class="progress" id="progress">
          <div class="fill" id="fill"></div>
          <div class="seg" id="segA"></div>
          <div class="seg" id="segB"></div>
          <div class="seg" id="segC"></div>
        </div>
        <div class="caps">
          <div id="capA">0 → 1st: -</div>
          <div id="capB">1st → 2nd: -</div>
          <div id="capC">2nd → Final: -</div>
        </div>
        <div class="row" style="justify-content:center;margin-top:10px">
          <button id="startBtn" class="btn" data-lang="start">Start</button>
          <button id="resetBtn" class="btn" data-lang="reset">Reset</button>
          <button id="singleBtn" class="btn" data-lang="single">Single</button>
          <button id="doubleBtn" class="btn" data-lang="double">Double</button>
          <button id="stopBellBtn" class="btn" style="display:none" data-lang="stopBell">Stop Bell</button>
          <button id="testContBellBtn" class="btn" data-lang="testStopCont">Test/Stop Cont.</button>
        </div>
        <div class="note" id="statusNote"><span data-lang="statusPrefix">Status:</span> <span data-lang-status="idle">idle</span></div>
      </div>

      <div class="grid grid-3">
        <!-- Cross-Ex / Shared -->
        <div class="card" id="crossExCard">
          <div class="title" data-lang="cexTitle">Cross-Ex / Shared</div>
          <div class="clock" id="cexClock">1:00</div>
          <div class="bar"><div class="bfill" id="cexFill" style="width:0%"></div></div>
          <div class="row" style="justify-content:center;margin-top:8px">
            <button id="cexStart" class="btn" data-lang="start">Start</button>
            <button id="cexReset" class="btn" data-lang="reset">Reset</button>
          </div>
        </div>
        
        <!-- Rebuttal / Reply -->
        <div class="card" id="rebuttalCard">
          <div class="title" id="rebuttalLabel" data-lang="rebTitle">Rebuttal / Reply (3:00)</div>
          <div class="clock" id="rebClock">3:00</div>
          <div class="bar"><div class="bfill" id="rebFill" style="width:0%"></div></div>
          <div class="row" style="justify-content:center;margin-top:8px">
            <button id="rebStart" class="btn" data-lang="start">Start</button>
            <button id="rebReset" class="btn" data-lang="reset">Reset</button>
          </div>
        </div>
      </div>

      <div class="card" id="tests" style="display:none">
        <div class="title" style="margin-bottom:6px" data-lang="tests">Tests</div>
        <ul class="tests" id="testList"></ul>
        <div class="note" data-lang="testNote">Note: Blob URLs from uploads are temporary. Use a public URL to persist across refresh.</div>
      </div>

    </div>
  </div>

  <!-- Help Modal -->
  <div id="helpModal" style="display:none">
    <div class="card">
      <h2 data-lang="helpTitle">Help</h2>
      <p data-lang="helpIntro">This is a flexible timer for various debate formats.</p>
      
      <h3 data-lang="helpProfilesTitle" style="margin-top:16px;margin-bottom:8px;">Profiles</h3>
      <ul data-lang-list="helpProfilesList">
        <li>Load a built-in profile (like Simson, AP, Policy) or save your own.</li>
        <li>"Save Current" saves all timer settings and the current speaker order as a new custom profile.</li>
      </ul>

      <h3 data-lang="helpSpeakersTitle" style="margin-top:16px;margin-bottom:8px;">Speaker Progress</h3>
      <ul data-lang-list="helpSpeakersList">
        <li>Click a speaker to select them. This will show the correct timer card (Main, Prep, etc.).</li>
        <li>Double-click a speaker to toggle them active/inactive. Inactive speakers are skipped by "Next"/"Previous".</li>
        <li>Drag and drop (or tap and drag on mobile) to reorder speakers.</li>
        <li>"Reset Order" restores the profile's default speaker order.</li>
      </ul>

      <h3 data-lang="helpTimersTitle" style="margin-top:16px;margin-bottom:8px;">Timers</h3>
      <ul data-lang-list="helpTimersList">
        <li>The main timer card (e.g., "Substantive Speech") changes based on the selected speaker.</li>
        <li>"Substantive" speeches (from "Main" time) have 1st/2nd bells and grace periods.</li>
        <li>"Reply" speeches (from "Rebuttal" time) are simpler timers with a final double bell.</li>
        <li>"Cross-Ex" and "Prep" timers are separate mini-timers.</li>
        <li>"Initialize Sound" must be clicked once to allow the browser to play audio. This is a security requirement for most browsers, especially on mobile.</li>
      </ul>

      <div class="row">
        <button id="closeHelpBtn" class="btn" data-lang="close">Close</button>
      </div>
    </div>
  </div>

<script>
(function(){
  // ===== Utilities =====
  const $ = (s, o = document) => o.querySelector(s);
  const $$ = (s, o = document) => o.querySelectorAll(s);
  
  const allDigitsFixed = t => !!t && /^[0-D]+$/.test(t);
  const parseMin = input => { const t = (input||'').trim(); if (allDigitsFixed(t)) return parseInt(t,10)*60000; const p=t.split(':'); const m=+p[0]||0,s=+p[1]||0; return (m*60+s)*1000 };

  const fmt = (ms)=>{ 
    if(ms===null || isNaN(ms)) return '-:--'; 
    const t = Math.abs(Math.round(ms/1000)); 
    const m = Math.floor(t/60); 
    const s = t%60; 
    return m+':'+(s<10?'0':'')+s; 
  };

  // ===== Language =====
  let currentLang = 'en';
  const translations = {
    en: {
      pageTitle: "AP Debate Timer — HTML",
      appTitle: "Debate Timer",
      help: "Help",
      toggleSettings: "Toggle Settings",
      sound: "Sound",
      muted: "Muted",
      enableSound: "Initialize Sound",
      tests: "Tests",
      profiles: "Profiles",
      loadProfile: "Load Profile",
      load: "Load",
      saveCurrent: "Save Current",
      deleteSelected: "Delete Selected",
      exportAll: "Export All",
      import: "Import",
      profilePrompt: "Enter profile name:",
      cannotDeleteDefault: "Cannot delete a default profile.",
      cannotOverwriteDefault: "Cannot overwrite a default profile.",
      timerSettings: "Timer Settings",
      mainTime: "Main (m:ss)",
      firstBell: "1st Bell from start (m:ss)",
      secondBell: "2nd Bell from start (m:ss)",
      yellowTime: "Yellow at remaining (m:ss)",
      redTime: "Red at remaining (m:ss)",
      gracePeriod: "Grace Period (m:ss)",
      prepTime: "Prep Time (m:ss)",
      cexTime: "Cross-Ex / Shared (m:ss)",
      rebTime: "Rebuttal / Reply (m:ss)",
      bellSpacing: "Bell spacing (ms)",
      bellMode: "Bell mode",
      volume: "Volume",
      mp3Url: "MP3 URL",
      uploadSounds: "Upload Sound(s)",
      speakerProgress: "Speaker Progress",
      previous: "Previous",
      next: "Next",
      resetOrder: "Reset Order",
      speakerNote: "Click to select, Double-click to toggle, Drag to reorder.",
      speakerBoxTitle: " (Click to select, Double-click to toggle, Drag to reorder)",
      substantiveSpeech: "Substantive Speech",
      replySpeech: "Reply Speech",
      start: "Start",
      pause: "Pause",
      reset: "Reset",
      single: "Single",
      double: "Double",
      stopBell: "Stop Bell",
      testStopCont: "Test/Stop Cont.",
      statusPrefix: "Status:",
      gracePeriodLabel: "GRACE PERIOD:",
      cexTitle: "Cross-Ex / Shared",
      rebTitle: "Rebuttal / Reply",
      testNote: "Note: Blob URLs from uploads are temporary. Use a public URL to persist across refresh.",
      helpTitle: "Help",
      helpIntro: "This is a flexible timer for various debate formats.",
      helpProfilesTitle: "Profiles",
      helpProfilesList: [
        "Load a built-in profile (like Simson, AP, Policy) or save your own.",
        '"Save Current" saves all timer settings and the current speaker order as a new custom profile.',
      ],
      helpSpeakersTitle: "Speaker Progress",
      helpSpeakersList: [
        "Click a speaker to select them. This will show the correct timer card (Main, Prep, etc.).",
        'Double-click a speaker to toggle them active/inactive. Inactive speakers are skipped by "Next"/"Previous".',
        "Drag and drop (or tap and drag on mobile) to reorder speakers.",
        '"Reset Order" restores the profile\'s default speaker order.',
      ],
      helpTimersTitle: "Timers",
      helpTimersList: [
        'The main timer card (e.g., "Substantive Speech") changes based on the selected speaker.',
        '"Substantive" speeches (from "Main" time) have 1st/2nd bells and grace periods.',
        '"Reply" speeches (from "Rebuttal" time) are simpler timers with a final double bell.',
        '"Cross-Ex" and "Prep" timers are separate mini-timers.',
        '"Initialize Sound" must be clicked once to allow the browser to play audio. This is a security requirement for most browsers, especially on mobile.'
      ],
      close: "Close",
      idle: "idle",
      'resume-fail': "resume-fail",
      'synth-unlock-err': "synth-unlock-err",
      'audio-play-fail': "audio-play-fail",
      'audio-unlock-err': "audio-unlock-err",
      'Sound ready.': "Sound ready.",
      'Synth ready (MP3/WAV may fail)': "Synth ready (MP3/WAV may fail)",
      'MP3/WAV ready (Synth may fail)': "MP3/WAV ready (Synth may fail)",
      'Sound failed. Please refresh.': "Sound failed. Please refresh.",
      'no-mp3-url': "no-mp3-url",
      'Please click "Enable Sound" first': 'Please click "Enable Sound" first',
      standardSounds: "Standard Sounds",
      uploadedSounds: "Uploaded Sounds",
      synthBell: "Synth Bell",
      builtInWAV: "Built-in WAV",
      mp3URLOpt: "MP3 URL",
      builtInProfiles: "Built-in Profiles",
      customProfiles: "Custom Profiles",
      "Prep": "Prep",
      "Prime Minister": "Prime Minister",
      "LO Prep": "LO Prep",
      "Leader of Opp": "Leader of Opp",
      "DPM Prep": "DPM Prep",
      "Deputy PM": "Deputy PM",
      "DLO Prep": "DLO Prep",
      "Deputy LO": "Deputy LO",
      "PW Prep": "PW Prep",
      "Prop Whip": "Prop Whip",
      "OW Prep": "OW Prep",
      "Opp Whip": "Opp Whip",
      "Prop Reply Prep": "Prop Reply Prep",
      "Prop Reply": "Prop Reply",
      "Opp Reply Prep": "Opp Reply Prep",
      "Opp Reply": "Opp Reply",
      "Gov Whip": "Gov Whip",
      "Gov Reply": "Gov Reply",
      "Member of Gov": "Member of Gov",
      "Member of Opp": "Member of Opp",
      "1st Aff Const": "1st Aff Const",
      "Cross-Ex (2N)": "Cross-Ex (2N)",
      "1st Neg Const": "1st Neg Const",
      "Cross-Ex (1A)": "Cross-Ex (1A)",
      "2nd Aff Const": "2nd Aff Const",
      "Cross-Ex (1N)": "Cross-Ex (1N)",
      "2nd Neg Const": "2nd Neg Const",
      "Cross-Ex (2A)": "Cross-Ex (2A)",
      "1st Neg Rebuttal": "1st Neg Rebuttal",
      "1st Aff Rebuttal": "1st Aff Rebuttal",
      "2nd Neg Rebuttal": "2nd Neg Rebuttal",
      "2nd Aff Rebuttal": "2nd Aff Rebuttal",
      "Aff Constructive": "Aff Constructive",
      "Cross-Ex": "Cross-Ex",
      "Neg Constructive": "Neg Constructive",
      "Neg Rebuttal": "Neg Rebuttal",
      "Speaker 1 (Pro)": "Speaker 1 (Pro)",
      "Speaker 2 (Con)": "Speaker 2 (Con)",
      "Crossfire": "Crossfire",
      "Speaker 3 (Pro)": "Speaker 3 (Pro)",
      "Speaker 4 (Con)": "Speaker 4 (Con)",
      "Summary 1 (Pro)": "Summary 1 (Pro)",
      "Summary 2 (Con)": "Summary 2 (Con)",
      "Grand Crossfire": "Grand Crossfire",
      "Final Focus 1 (Pro)": "Final Focus 1 (Pro)",
      "Final Focus 2 (Con)": "Final Focus 2 (Con)",
    },
    ko: {
      pageTitle: "AP 토론 타이머 — HTML",
      appTitle: "토론 타이머",
      help: "도움말",
      toggleSettings: "설정 보기/숨기기",
      sound: "소리",
      muted: "음소거됨",
      enableSound: "소리 초기화",
      tests: "테스트",
      profiles: "프로필",
      loadProfile: "프로필 불러오기",
      load: "불러오기",
      saveCurrent: "현재 설정 저장",
      deleteSelected: "선택 항목 삭제",
      exportAll: "모두 내보내기",
      import: "가져오기",
      cannotDeleteDefault: "기본 프로필은 삭제할 수 없습니다.",
      cannotOverwriteDefault: "기본 프로필은 덮어쓸 수 없습니다.",
      timerSettings: "타이머 설정",
      mainTime: "주요 발언 (m:ss)",
      firstBell: "첫 번째 벨 (m:ss)",
      secondBell: "두 번째 벨 (m:ss)",
      yellowTime: "경고 (남은 시간 m:ss)",
      redTime: "위험 (남은 시간 m:ss)",
      gracePeriod: "유예 시간 (m:ss)",
      prepTime: "준비 시간 (m:ss)",
      cexTime: "교차조사 / 공유 시간 (m:ss)",
      rebTime: "반박 / 요약 (m:ss)",
      bellSpacing: "벨 간격 (ms)",
      bellMode: "벨 모드",
      volume: "볼륨",
      mp3Url: "MP3 URL",
      uploadSounds: "사운드 업로드",
      speakerProgress: "발언자 순서",
      previous: "이전",
      next: "다음",
      resetOrder: "순서 초기화",
      speakerNote: "클릭: 선택, 더블클릭: 활성/비활성, 드래그: 순서 변경.",
      speakerBoxTitle: " (클릭: 선택, 더블클릭: 활성/비활성, 드래그: 순서 변경)",
      substantiveSpeech: "주요 발언",
      replySpeech: "요약 발언",
      start: "시작",
      pause: "일시정지",
      reset: "초기화",
      single: "벨 1회",
      double: "벨 2회",
      stopBell: "벨 중지",
      testStopCont: "연속 벨 테스트/중지",
      statusPrefix: "상태:",
      gracePeriodLabel: "유예 시간:",
      cexTitle: "교차조사 / 공유 시간",
      rebTitle: "반박 / 요약",
      testNote: "참고: 업로드된 Blob URL은 임시적이므로, 새로고침 후에도 유지하려면 공개 URL을 사용하세요.",
      helpTitle: "도움말",
      helpIntro: "이것은 다양한 토론 형식을 위한 유연한 타이머입니다.",
      helpProfilesTitle: "프로필",
      helpProfilesList: [
        "Simson, AP, Policy 등 내장된 프로필을 불러오거나 자신만의 프로필을 저장하세요.",
        '"현재 설정 저장"은 모든 타이머 설정과 현재 발언자 순서를 새 사용자 지정 프로필로 저장합니다.',
      ],
      helpSpeakersTitle: "발언자 순서",
      helpSpeakersList: [
        "발언자를 클릭하여 선택합니다. 그러면 (주요 발언, 준비 시간 등) 올바른 타이머 카드가 표시됩니다.",
        '발언자를 더블클릭하여 활성/비활성 상태로 전환합니다. 비활성 발언자는 "다음"/"이전" 버튼 클릭 시 건너뜁니다.',
        "발언자를 드래그 앤 드롭(모바일에서는 탭 앤 드래그)하여 순서를 변경할 수 있습니다.",
        '"순서 초기화"는 프로필의 기본 발언자 순서로 복원합니다.',
      ],
      helpTimersTitle: "타이머",
      helpTimersList: [
        '메인 타이머 카드(예: "주요 발언")는 선택된 발언자에 따라 변경됩니다.',
        '"주요 발언" ("Main" 시간)은 1번째/2번째 벨 및 유예 시간이 있습니다.',
        '"요약 발언" ("Rebuttal" 시간)은 마지막에 더블 벨이 울리는 더 간단한 타이머입니다.',
        '"교차조사" 및 "준비 시간" 타이머는 별도의 미니 타이머입니다.',
        '브라우저에서 소리를 재생하려면 "소리 초기화" 버튼을 한 번 클릭해야 합니다. 이는 대부분의 최신 브라우저(특히 모바일)의 보안 요구 사항입니다.'
      ],
      close: "닫기",
      idle: "대기 중",
      'resume-fail': "오디오 재개 실패",
      'synth-unlock-err': "신디사이저 오디오 잠금 해제 오류",
      'audio-play-fail': "오디오 재생 실패",
      'audio-unlock-err': "오디오 태그 잠금 해제 오류",
      'Sound ready.': "소리 준비 완료.",
      'Synth ready (MP3/WAV may fail)': "신디사이저 준비됨 (MP3/WAV 실패 가능)",
      'MP3/WAV ready (Synth may fail)': "MP3/WAV 준비됨 (신디사이저 실패 가능)",
      'Sound failed. Please refresh.': "소리 활성화 실패. 새로고침하세요.",
      'no-mp3-url': "MP3 URL이 설정되지 않았습니다",
      'Please click "Enable Sound" first': '"소리 활성화" 버튼을 먼저 클릭하세요',
      standardSounds: "기본 사운드",
      uploadedSounds: "업로드된 사운드",
      synthBell: "신디사이저 벨",
      builtInWAV: "내장 WAV",
      mp3URLOpt: "MP3 URL",
      builtInProfiles: "기본 프로필",
      customProfiles: "사용자 지정 프로필",
      "Prep": "준비 시간",
      "Prime Minister": "총리",
      "LO Prep": "야당 대표 준비",
      "Leader of Opp": "야당 대표",
      "DPM Prep": "부총리 준비",
      "Deputy PM": "부총리",
      "DLO Prep": "야당 부대표 준비",
      "Deputy LO": "야당 부대표",
      "PW Prep": "여당 원내총무 준비",
      "Prop Whip": "여당 원내총무",
      "OW Prep": "야당 원내총무 준비",
      "Opp Whip": "야당 원내총무",
      "Prop Reply Prep": "여당 요약 준비",
      "Prop Reply": "여당 요약",
      "Opp Reply Prep": "야당 요약 준비",
      "Opp Reply": "야당 요약",
      "Gov Whip": "여당 원내총무",
      "Gov Reply": "여당 요약",
      "Member of Gov": "여당 의원",
      "Member of Opp": "야당 의원",
      "1st Aff Const": "첫 번째 찬성측 입론",
      "Cross-Ex (2N)": "교차조사 (2N)",
      "1st Neg Const": "첫 번째 반대측 입론",
      "Cross-Ex (1A)": "교차조사 (1A)",
      "2nd Aff Const": "두 번째 찬성측 입론",
      "Cross-Ex (1N)": "교차조사 (1N)",
      "2nd Neg Const": "두 번째 반대측 입론",
      "Cross-Ex (2A)": "교차조사 (2A)",
      "1st Neg Rebuttal": "첫 번째 반대측 반박",
      "1st Aff Rebuttal": "첫 번째 찬성측 반박",
      "2nd Neg Rebuttal": "두 번째 반대측 반박",
      "2nd Aff Rebuttal": "두 번째 찬성측 반박",
      "Aff Constructive": "찬성측 입론",
      "Cross-Ex": "교차조사",
      "Neg Constructive": "반대측 입론",
      "Neg Rebuttal": "반대측 반박",
      "Speaker 1 (Pro)": "발언자 1 (찬성)",
      "Speaker 2 (Con)": "발언자 2 (반대)",
      "Crossfire": "크로스파이어",
      "Speaker 3 (Pro)": "발언자 3 (찬성)",
      "Speaker 4 (Con)": "발언자 4 (반대)",
      "Summary 1 (Pro)": "요약 1 (찬성)",
      "Summary 2 (Con)": "요약 2 (반대)",
      "Grand Crossfire": "그랜드 크로스파이어",
      "Final Focus 1 (Pro)": "최종 초점 1 (찬성)",
      "Final Focus 2 (Con)": "최종 초점 2 (반대)",
    }
  };

  const updateLanguage = (lang) => {
    currentLang = lang;
    document.documentElement.lang = lang;
    localStorage.setItem('debateTimerLang', lang);
    langToggleBtn.textContent = lang === 'en' ? '한국어' : 'English';

    const trans = translations[lang];
    if (!trans) return;

    $$('[data-lang]').forEach(el => {
      const key = el.dataset.lang;
      if (trans[key]) el.textContent = trans[key];
    });
    
    document.title = trans.pageTitle;

    $$('[data-lang-list]').forEach(ul => {
      const key = ul.dataset.langList;
      if (trans[key] && Array.isArray(trans[key])) {
        ul.innerHTML = '';
        trans[key].forEach(text => {
          const li = document.createElement('li');
          li.textContent = text;
          ul.appendChild(li);
        });
      }
    });
    
    populateModeSelect();
    loadProfilesToDropdown();
    initSpeakerProgress();
    setActiveSpeaker(activeSpeakerIndex, true);
    syncInputsToState();
    setStatus($('#statusNote').dataset.currentStatus || 'idle');
    render(true);
  };

  // ===== Speaker Data =====
  const createSimsonSpeakerOrder = () => [
    { role: "Prep", initials: "PREP", team: "None", timers: ["prep"], active: true },
    { role: "Prime Minister", initials: "PM", team: "Prop", timers: ["main"], active: true },
    { role: "LO Prep", initials: "R", team: "Opp", timers: ["cross-ex"], active: true },
    { role: "Leader of Opp", initials: "LO", team: "Opp", timers: ["main"], active: true },
    { role: "DPM Prep", initials: "R", team: "Prop", timers: ["cross-ex"], active: true },
    { role: "Deputy PM", initials: "DPM", team: "Prop", timers: ["main"], active: true },
    { role: "DLO Prep", initials: "R", team: "Opp", timers: ["cross-ex"], active: true },
    { role: "Deputy LO", initials: "DLO", team: "Opp", timers: ["main"], active: true },
    { role: "PW Prep", initials: "R", team: "Prop", timers: ["cross-ex"], active: true },
    { role: "Prop Whip", initials: "PW", team: "Prop", timers: ["main"], active: true },
    { role: "OW Prep", initials: "R", team: "Opp", timers: ["cross-ex"], active: true },
    { role: "Opp Whip", initials: "OW", team: "Opp", timers: ["main"], active: true },
    { role: "Prop Reply Prep", initials: "R", team: "Prop", timers: ["cross-ex"], active: true },
    { role: "Prop Reply", initials: "PR", team: "Prop", timers: ["rebuttal"], active: true },
    { role: "Opp Reply Prep", initials: "R", team: "Opp", timers: ["cross-ex"], active: true },
    { role: "Opp Reply", initials: "OR", team: "Opp", timers: ["rebuttal"], active: true },
  ];
  
  const createAPSpeakerOrder = () => [
    { role: "Prep", initials: "PREP", team: "None", timers: ["prep"], active: true },
    { role: "Prime Minister", initials: "PM", team: "Gov", timers: ["main"], active: true },
    { role: "Leader of Opp", initials: "LO", team: "Opp", timers: ["main"], active: true },
    { role: "Deputy PM", initials: "DPM", team: "Gov", timers: ["main"], active: true },
    { role: "Deputy LO", initials: "DLO", team: "Opp", timers: ["main"], active: true },
    { role: "Gov Whip", initials: "GW", team: "Gov", timers: ["main"], active: true },
    { role: "Opp Whip", initials: "OW", team: "Opp", timers: ["main"], active: true },
    { role: "Opp Reply", initials: "OR", team: "Opp", timers: ["rebuttal"], active: true },
    { role: "Gov Reply", initials: "GR", team: "Gov", timers: ["rebuttal"], active: true },
  ];
  
  const createBPSpeakerOrder = () => [
    { role: "Prep", initials: "PREP", team: "None", timers: ["prep"], active: true },
    { role: "Prime Minister", initials: "PM", team: "Gov", timers: ["main"], active: true },
    { role: "Leader of Opp", initials: "LO", team: "Opp", timers: ["main"], active: true },
    { role: "Deputy PM", initials: "DPM", team: "Gov", timers: ["main"], active: true },
    { role: "Deputy LO", initials: "DLO", team: "Opp", timers: ["main"], active: true },
    { role: "Member of Gov", initials: "MG", team: "Gov", timers: ["main"], active: true },
    { role: "Member of Opp", initials: "MO", team: "Opp", timers: ["main"], active: true },
    { role: "Gov Whip", initials: "GW", team: "Gov", timers: ["main"], active: true },
    { role: "Opp Whip", initials: "OW", team: "Opp", timers: ["main"], active: true },
  ];
  
  const createPolicySpeakerOrder = () => [
    { role: "Prep", initials: "PREP", team: "None", timers: ["prep"], active: true },
    { role: "1st Aff Const", initials: "1AC", team: "Aff", timers: ["main"], active: true },
    { role: "Cross-Ex (2N)", initials: "CX", team: "Neg", timers: ["cross-ex"], active: true },
    { role: "1st Neg Const", initials: "1NC", team: "Neg", timers: ["main"], active: true },
    { role: "Cross-Ex (1A)", initials: "CX", team: "Aff", timers: ["cross-ex"], active: true },
    { role: "2nd Aff Const", initials: "2AC", team: "Aff", timers: ["main"], active: true },
    { role: "Cross-Ex (1N)", initials: "CX", team: "Neg", timers: ["cross-ex"], active: true },
    { role: "2nd Neg Const", initials: "2NC", team: "Neg", timers: ["main"], active: true },
    { role: "Cross-Ex (2A)", initials: "CX", team: "Aff", timers: ["cross-ex"], active: true },
    { role: "1st Neg Rebuttal", initials: "1NR", team: "Neg", timers: ["rebuttal"], active: true },
    { role: "1st Aff Rebuttal", initials: "1AR", team: "Aff", timers: ["rebuttal"], active: true },
    { role: "2nd Neg Rebuttal", initials: "2NR", team: "Neg", timers: ["rebuttal"], active: true },
    { role: "2nd Aff Rebuttal", initials: "2AR", team: "Aff", timers: ["rebuttal"], active: true },
  ];
  
  const createLDSpeakerOrder = () => [
    { role: "Prep", initials: "PREP", team: "None", timers: ["prep"], active: true },
    { role: "Aff Constructive", initials: "AC", team: "Aff", timers: ["main"], active: true },
    { role: "Cross-Ex", initials: "CX", team: "Neg", timers: ["cross-ex"], active: true },
    { role: "Neg Constructive", initials: "NC", team: "Neg", timers: ["main"], active: true },
    { role: "Cross-Ex", initials: "CX", team: "Aff", timers: ["cross-ex"], active: true },
    { role: "1st Aff Rebuttal", initials: "1AR", team: "Aff", timers: ["rebuttal"], active: true },
    { role: "Neg Rebuttal", initials: "NR", team: "Neg", timers: ["rebuttal"], active: true },
    { role: "2nd Aff Rebuttal", initials: "2AR", team: "Aff", timers: ["rebuttal"], active: true },
  ];
  
  const createBFSpeakerOrder = () => [
    { role: "Prep", initials: "PREP", team: "None", timers: ["prep"], active: true },
    { role: "Speaker 1 (Pro)", initials: "S1", team: "Aff", timers: ["main"], active: true },
    { role: "Speaker 2 (Con)", initials: "S2", team: "Neg", timers: ["main"], active: true },
    { role: "Crossfire", initials: "CF", team: "None", timers: ["cross-ex"], active: true },
    { role: "Speaker 3 (Pro)", initials: "S3", team: "Aff", timers: ["main"], active: true },
    { role: "Speaker 4 (Con)", initials: "S4", team: "Neg", timers: ["main"], active: true },
    { role: "Crossfire", initials: "CF", team: "None", timers: ["cross-ex"], active: true },
    { role: "Summary 1 (Pro)", initials: "S1", team: "Aff", timers: ["rebuttal"], active: true },
    { role: "Summary 2 (Con)", initials: "S2", team: "Neg", timers: ["rebuttal"], active: true },
    { role: "Grand Crossfire", initials: "GCF", team: "None", timers: ["cross-ex"], active: true },
    { role: "Final Focus 1 (Pro)", initials: "F1", team: "Aff", timers: ["rebuttal"], active: true },
    { role: "Final Focus 2 (Con)", initials: "F2", team: "Neg", timers: ["rebuttal"], active: true },
  ];
  
  let speakerOrder = createSimsonSpeakerOrder();
  let activeSpeakerIndex = 0;
  let draggingIndex = null;
  let touchOverElement = null;

  // ===== State =====
  const createDefaultState = (presetName) => {
    switch (presetName) {
      case "Policy":
        return {
          preset:'Substantive', main: 8*60000, first: 60000, second: 7*60000, yellow: 2*60000, red: 60000, grace: 30000,
          prepTime: 5*60000, cexTime: 3*60000, rebTime: 5*60000,
          spacing: 100, running:false, muted:false, mode:'wav', mp3Url:null, volume: 0.5,
        };
      case "LD":
        return {
          preset:'Substantive', main: 6*60000, first: 60000, second: 5*60000, yellow: 2*60000, red: 60000, grace: 30000,
          prepTime: 4*60000, cexTime: 3*60000, rebTime: 4*60000,
          spacing: 100, running:false, muted:false, mode:'wav', mp3Url:null, volume: 0.5,
        };
      case "PF":
        return {
          preset:'Substantive', main: 4*60000, first: 60000, second: 3*60000, yellow: 60000, red: 30000, grace: 30000,
          prepTime: 3*60000, cexTime: 3*60000, rebTime: 2*60000,
          spacing: 100, running:false, muted:false, mode:'wav', mp3Url:null, volume: 0.5,
        };
      case "AP":
        return {
          preset:'Substantive', main: 7*60000, first: 60000, second: 6*60000, yellow: 60000, red: 30000, grace: 30000,
          prepTime: 30*60000, cexTime: 0, rebTime: 4*60000,
          spacing: 100, running:false, muted:false, mode:'wav', mp3Url:null, volume: 0.5,
        };
      case "BP":
        return {
          preset:'Substantive', main: 7*60000, first: 60000, second: 6*60000, yellow: 60000, red: 30000, grace: 30000,
          prepTime: 15*60000, cexTime: 0, rebTime: 0,
          spacing: 100, running:false, muted:false, mode:'wav', mp3Url:null, volume: 0.5,
        };
      case "Simson":
      default:
        return {
          preset:'Substantive', main: 3*60000, first: 60000, second: 2*60000, yellow: 60000, red: 30000, grace: 30000,
          prepTime: 20*60000, cexTime: 60000, rebTime: 3*60000,
          spacing: 100, running:false, muted:false, mode:'wav', mp3Url:null, volume: 0.5,
        };
    }
  };
  
  let state = createDefaultState("Simson");
  
  let timerSnapshot = {};
  
  const PROFILES_DB_KEY = 'debateTimerProfiles';
  
  const DEFAULT_PROFILES = [
    {
      name: "Simson (Default)",
      speakerOrder: createSimsonSpeakerOrder(),
      settings: createDefaultState("Simson")
    },
    {
      name: "Team Policy (CX)",
      speakerOrder: createPolicySpeakerOrder(),
      settings: createDefaultState("Policy")
    },
    {
      name: "Lincoln-Douglas (LD)",
      speakerOrder: createLDSpeakerOrder(),
      settings: createDefaultState("LD")
    },
    {
      name: "Public Forum (PF)",
      speakerOrder: createBFSpeakerOrder(),
      settings: createDefaultState("PF")
    },
    {
      name: "Asian Parliamentary (AP)",
      speakerOrder: createAPSpeakerOrder(),
      settings: createDefaultState("AP")
    },
    {
      name: "British Parliamentary (BP)",
      speakerOrder: createBPSpeakerOrder(),
      settings: createDefaultState("BP")
    }
  ];
  
  const isDefaultProfile = (name) => DEFAULT_PROFILES.some(p => p.name === name);

  // Load persisted
  try{
    state.mode = localStorage.getItem('bellMode')||'wav';
    state.mp3Url = localStorage.getItem('mp3Url')||null;
    state.volume = parseFloat(localStorage.getItem('volume')||'0.5');
    state.muted = (localStorage.getItem('muted') === 'true') || false;
  }catch{}

  // Elements
  const wrap = $('#app');
  const clockEl = $('#clock');
  const metaEl = $('#meta');
  const progressEl = $('#progress');
  const fillEl = $('#fill');
  const segA = $('#segA'), segB=$('#segB'), segC=$('#segC');
  const capA=$('#capA'), capB=$('#capB'), capC=$('#capC');
  const statusNote=$('#statusNote');
  const modeLabel=$('#modeLabel');
  
  // Settings UI
  const settingsBtn = $('#settingsBtn');
  const settingsContainer = $('#settingsContainer');
  settingsBtn.onclick = () => {
    settingsContainer.style.display = settingsContainer.style.display === 'none' ? 'block' : 'none';
  };

  // Inputs
  const mainInput=$('#mainInput'), firstInput=$('#firstInput'), secondInput=$('#secondInput');
  const yellowInput=$('#yellowInput'), redInput=$('#redInput'), graceInput=$('#graceInput');
  const spaceInput=$('#spaceInput');
  const modeSel=$('#modeSel'), mp3Url=$('#mp3Url'), mp3File=$('#mp3File'), volumeInput=$('#volumeInput');
  
  // Quick Timer Inputs
  const prepInput=$('#prepInput'), cexInput=$('#cexInput'), rebInput=$('#rebInput');

  const muteBtn=$('#muteBtn'), enableBtn=$('#enableBtn'), testsBtn=$('#testsBtn');
  const startBtn=$('#startBtn'), resetBtn=$('#resetBtn');
  const singleBtn=$('#singleBtn'), doubleBtn=$('#doubleBtn');
  const stopBellBtn=$('#stopBellBtn'), testContBellBtn=$('#testContBellBtn');

  // Quick timers (display elements)
  const prepClock=$('#prepClock'), prepFill=$('#prepFill');
  const cexClock=$('#cexClock'), cexFill=$('#cexFill');
  const rebClock=$('#rebClock'), rebFill=$('#rebFill'), rebuttalLabel=$('#rebuttalLabel');
  
  const prepStart=$('#prepStart'), prepReset=$('#prepReset');
  const cexStart=$('#cexStart'), cexReset=$('#cexReset');
  const rebStart=$('#rebStart'), rebReset=$('#rebReset');
  
  // Timer Containers
  const prepTimerContainer = $('#prepTimerContainer');
  const mainSpeechCard = $('#mainSpeechCard');
  const crossExCard = $('#crossExCard');
  const rebuttalCard = $('#rebuttalCard');
  
  // Profile UI
  const profileSelect = $('#profileSelect');
  const loadProfileBtn = $('#loadProfileBtn');
  const saveProfileBtn = $('#saveProfileBtn');
  const deleteProfileBtn = $('#deleteProfileBtn');
  const exportProfilesBtn = $('#exportProfilesBtn');
  const importProfilesInput = $('#importProfilesInput');

  // Speaker Progress UI
  const speakerProgress = $('#speakerProgress');
  const nextSpeakerBtn = $('#nextSpeakerBtn');
  const prevSpeakerBtn = $('#prevSpeakerBtn');
  const resetOrderBtn = $('#resetOrderBtn');

  // Help Modal UI
  const helpBtn = $('#helpBtn');
  const helpModal = $('#helpModal');
  const closeHelpBtn = $('#closeHelpBtn');
  
  const silentAudio = $('#silentUnlockAudio');

  // Mute icons
  const muteIconOn = $('#muteIconOn');
  const muteIconOff = $('#muteIconOff');

  // Lang Toggle
  const langToggleBtn = $('#langToggleBtn');
  langToggleBtn.onclick = () => {
    const newLang = currentLang === 'en' ? 'ko' : 'en';
    updateLanguage(newLang);
  };

  function initSpeakerProgress() {
    speakerProgress.innerHTML = '';
    speakerOrder.forEach((speaker, index) => {
      const box = document.createElement('div');
      let teamClass = speaker.team.toLowerCase().replace('prop', 'gov');
      if (teamClass.includes('aff')) teamClass = 'aff';
      if (teamClass.includes('neg')) teamClass = 'neg';
      
      box.className = `speaker-box team-${teamClass}`;
      box.classList.toggle('inactive', !speaker.active);
      
      const initials = speaker.initials;
      box.textContent = initials;
      
      const trans = translations[currentLang];
      const roleName = trans[speaker.role] || speaker.role;
      box.title = roleName + trans.speakerBoxTitle;
      box.dataset.langRole = speaker.role;
      box.dataset.index = index;
      
      box.addEventListener('click', () => {
        if (!speaker.active) return;
        setActiveSpeaker(index);
      });
      
      box.addEventListener('dblclick', () => {
        speaker.active = !speaker.active;
        box.classList.toggle('inactive', !speaker.active);
      });

      box.draggable = true;
      box.addEventListener('dragstart', (e) => {
        draggingIndex = index;
        e.dataTransfer.effectAllowed = 'move';
        box.classList.add('dragging');
      });
      box.addEventListener('dragend', () => {
        box.classList.remove('dragging');
        draggingIndex = null;
      });
      box.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        box.classList.add('drag-over');
      });
      box.addEventListener('dragleave', () => {
        box.classList.remove('drag-over');
      });
      box.addEventListener('drop', (e) => {
        e.preventDefault();
        box.classList.remove('drag-over');
        if (draggingIndex === null || draggingIndex === index) return;
        
        const [draggedItem] = speakerOrder.splice(draggingIndex, 1);
        speakerOrder.splice(index, 0, draggedItem);
        
        if (activeSpeakerIndex === draggingIndex) {
          activeSpeakerIndex = index;
        } else if (draggingIndex < activeSpeakerIndex && index >= activeSpeakerIndex) {
          activeSpeakerIndex--;
        } else if (draggingIndex > activeSpeakerIndex && index <= activeSpeakerIndex) {
          activeSpeakerIndex++;
        }
        
        initSpeakerProgress();
        setActiveSpeaker(activeSpeakerIndex, true);
      });

      // Touch reorder
      box.addEventListener('touchstart', (e) => { draggingIndex = index; box.classList.add('dragging'); }, { passive: true });
      box.addEventListener('touchmove', (e) => {
        if (draggingIndex === null) return;
        e.preventDefault(); 
        const touch = e.touches[0];
        const draggingBox = $$('.speaker-box')[draggingIndex];
        if (draggingBox) draggingBox.style.display = 'none';
        const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
        if (draggingBox) draggingBox.style.display = '';
        if (!targetElement) return;
        const targetBox = targetElement.closest('.speaker-box');
        if (targetBox && targetBox.dataset.index != draggingIndex) {
            targetBox.classList.add('drag-over');
            touchOverElement = targetBox;
        } else {
            if (touchOverElement) touchOverElement.classList.remove('drag-over');
            touchOverElement = null;
        }
      }, { passive: false });
      box.addEventListener('touchend', (e) => {
        if (draggingIndex === null) return;
        const dropIndex = touchOverElement ? parseInt(touchOverElement.dataset.index, 10) : null;
        box.classList.remove('dragging');
        if (touchOverElement) touchOverElement.classList.remove('drag-over');
        if (dropIndex !== null && dropIndex !== draggingIndex) {
            const [draggedItem] = speakerOrder.splice(draggingIndex, 1);
            speakerOrder.splice(dropIndex, 0, draggedItem);
            if (activeSpeakerIndex === draggingIndex) activeSpeakerIndex = dropIndex;
            else if (draggingIndex < activeSpeakerIndex && dropIndex >= activeSpeakerIndex) activeSpeakerIndex--;
            else if (draggingIndex > activeSpeakerIndex && dropIndex <= activeSpeakerIndex) activeSpeakerIndex++;
            initSpeakerProgress();
            setActiveSpeaker(activeSpeakerIndex, true);
        }
        draggingIndex = null;
        touchOverElement = null;
      });

      speakerProgress.appendChild(box);
    });
  }

  function setActiveSpeaker(index, force = false) {
    if (index >= speakerOrder.length || index < 0) index = 0;
    if (!force && index === activeSpeakerIndex) return;

    activeSpeakerIndex = index;
    $$('.speaker-box').forEach(box => box.classList.remove('active-speaker'));
    const activeBox = document.querySelector(`[data-index="${index}"]`);
    if (activeBox) activeBox.classList.add('active-speaker');

    const speaker = speakerOrder[index];
    if (!speaker) return;
    const timers = speaker.timers;
    prepTimerContainer.style.display = timers.includes('prep') ? 'flex' : 'none';
    mainSpeechCard.style.display = timers.includes('main') ? 'block' : 'none';
    crossExCard.style.display = timers.includes('cross-ex') ? 'block' : 'none';
    rebuttalCard.style.display = timers.includes('rebuttal') ? 'block' : 'none';

    if (timers.includes('main')) {
      applyPreset('Substantive');
    } else if (timers.includes('rebuttal')) {
      applyPreset('Reply');
    }
  }

  function findNextSpeaker(direction) {
    let newIndex = activeSpeakerIndex;
    for (let i = 1; i <= speakerOrder.length; i++) {
      newIndex = (newIndex + direction + speakerOrder.length) % speakerOrder.length;
      if (speakerOrder[newIndex].active) return newIndex;
    }
    return activeSpeakerIndex;
  }

  nextSpeakerBtn.onclick = () => { const nextIndex = findNextSpeaker(1); setActiveSpeaker(nextIndex); };
  prevSpeakerBtn.onclick = () => { const prevIndex = findNextSpeaker(-1); setActiveSpeaker(prevIndex); };

  resetOrderBtn.onclick = () => {
    const currentProfileName = profileSelect.value;
    const profile = findProfileByName(currentProfileName);
    if (!profile) { loadSelectedProfile(DEFAULT_PROFILES[0].name); return; }
    speakerOrder = JSON.parse(JSON.stringify(profile.speakerOrder));
    initSpeakerProgress();
    setActiveSpeaker(0);
  };

  // ===== Audio =====
  const SILENT_WAV = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=';
  // Built-in WAV bell
  const BUILT_IN_DING_WAV = 'data:audio/wav;base64,UklGRigCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQCAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA==';

  let audioCtx = null;
  let unlocked = false;
  let uploadedSounds = [];

  const setStatus = (s)=>{ 
    const trans = translations[currentLang];
    const statusText = trans[s] || s;
    $('#statusNote').dataset.currentStatus = s;
    const statusSpan = $('#statusNote').querySelector('[data-lang-status]');
    if (statusSpan) statusSpan.textContent = statusText;
  };

  const unlock = ()=>{
    let synthUnlocked = false;
    let audioTagUnlocked = false;

    // 1) Try to unlock Web Audio
    try {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (Ctx) {
        if (!audioCtx) audioCtx = new Ctx(); 
        if (audioCtx && audioCtx.state === 'suspended') {
          audioCtx.resume().catch(()=>{ setStatus('resume-fail'); });
        }
        synthUnlocked = true;
      }
    } catch (e) {
      setStatus('synth-unlock-err');
    }

    // 2) Unlock <audio> tag: play, then pause & unmute
    try {
      if (silentAudio) {
        const p = silentAudio.play();
        if (p && p.then) {
          p.then(()=>{
            try { silentAudio.pause(); silentAudio.currentTime = 0; silentAudio.muted = false; } catch(e){}
          }).catch(()=>{ setStatus('audio-play-fail'); });
        }
        audioTagUnlocked = true;
      }
    } catch (e) {
      setStatus('audio-unlock-err');
    }

    unlocked = true; 
    enableBtn.style.display = 'none';
    
    if (synthUnlocked && audioTagUnlocked) setStatus('Sound ready.');
    else if (synthUnlocked) setStatus('Synth ready (MP3/WAV may fail)');
    else if (audioTagUnlocked) setStatus('MP3/WAV ready (Synth may fail)');
    else setStatus('Sound failed. Please refresh.');
    return true;
  };

  const playBell = (count)=>{
    if(state.muted || !unlocked) return;
    const mode = state.mode;
    if(mode === 'synth'){
      const ctx = audioCtx; if(!ctx) return;
      const base = ctx.currentTime + .05;
      const freqs = [700,1400,1760,2800,3520,4400,5600,7040,8800,11200,14080,17600];
      const gains = [0.2,0.15,0.4,0.3,0.25,0.2,0.1,0.08,0.05,0.03,0.02,0.01];
      const decays = [2.8,2.0,2.5,2.0,1.5,1.0,0.7,0.5,0.4,0.3,0.2,0.1];
      for (let i = 0; i < count; i++) {
        const t = base + (i * state.spacing) / 1000;
        const master = ctx.createGain();
        master.gain.setValueAtTime(0.0001, t);
        master.gain.exponentialRampToValueAtTime(state.volume, t + 0.01);
        master.gain.exponentialRampToValueAtTime(0.0001, t + 3.0);
        master.connect(ctx.destination);
        freqs.forEach((freq, idx) => {
          const osc = ctx.createOscillator();
          const g = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, t);
          const partialGain = gains[idx];
          const decay = decays[idx];
          g.gain.setValueAtTime(partialGain, t);
          g.gain.exponentialRampToValueAtTime(0.0001, t + decay);
          osc.connect(g).connect(master);
          osc.start(t);
          osc.stop(t + 3.0);
        });
      }
    } else {
      let url;
      if (mode === 'wav') url = BUILT_IN_DING_WAV;
      else if (mode === 'mp3') url = state.mp3Url;
      else if (mode.startsWith('upload_')) {
        const uploadIndex = parseInt(mode.split('_')[1], 10);
        const sound = uploadedSounds[uploadIndex];
        if (sound) url = sound.url;
      }
      if (!url) { setStatus('no-mp3-url'); return; }
      let currentPlay = 0;
      const playSequentially = () => {
        if (currentPlay >= count) return;
        silentAudio.src = url;
        silentAudio.volume = state.volume;
        silentAudio.currentTime = 0;
        silentAudio.muted = false;
        const p = silentAudio.play();
        if (p && p.catch) { p.catch(()=> setStatus('audio-play-fail')); }
        currentPlay++;
        if (currentPlay < count) setTimeout(playSequentially, state.spacing);
      };
      playSequentially();
    }
  };

  // Controls
  muteBtn.onclick = ()=>{ 
    state.muted=!state.muted; 
    muteIconOn.style.display = state.muted ? 'none' : 'block';
    muteIconOff.style.display = state.muted ? 'block' : 'none';
    localStorage.setItem('muted', state.muted);
  };
  enableBtn.onclick = unlock;
  testsBtn.onclick = ()=>{ const box=$('#tests'); box.style.display = box.style.display==='none'?'block':'none'; };

  // ===== Main Timer Engine =====
  let startTs=null, acc=0, raf=null, remaining=state.main;
  let inGrace=false, graceRemaining=0;
  let contBellInterval=null;
  const fired = {first:false, second:false, final:false};

  const stopContinuousBell = ()=>{
    if(contBellInterval){ clearInterval(contBellInterval); contBellInterval=null; }
    stopBellBtn.style.display = 'none';
    testContBellBtn.textContent = 'Test/Stop Cont.';
  };
  stopBellBtn.onclick = stopContinuousBell;
  testContBellBtn.onclick = ()=>{
    if(contBellInterval){ stopContinuousBell(); }
    else {
      if (!unlocked) { setStatus('Please click "Enable Sound" first'); return; }
      contBellInterval = setInterval(()=>playBell(1), state.spacing || 500);
      testContBellBtn.textContent = translations[currentLang].stopBell;
    }
  };

  const loop = (ts)=>{
    if(startTs===null) startTs=ts;
    const elapsed = (ts-startTs)+acc;
    
    if (inGrace) {
      graceRemaining = Math.max(0, timerSnapshot.grace - elapsed);
      remaining = 0;
      if (graceRemaining === 0) {
        if (!contBellInterval && timerSnapshot.preset === 'Substantive') {
          contBellInterval = setInterval(()=>playBell(1), state.spacing || 500);
          stopBellBtn.style.display = 'inline-flex';
        }
      }
    } else {
      remaining = Math.max(0, timerSnapshot.main - elapsed);
      if (remaining === 0) {
        if (!fired.final) { playBell(2); fired.final = true; }
        if (timerSnapshot.grace > 0) {
          inGrace = true;
          acc = 0;
          startTs = ts;
        } else {
          cancelAnimationFrame(raf); raf = null;
        }
      }
    }
    
    render();
    if (!inGrace) checkBells();
    if ((remaining > 0 || graceRemaining > 0) && raf) {
      raf = requestAnimationFrame(loop);
    } else {
      cancelAnimationFrame(raf); raf = null;
    }
  };

  const snapshotSettings = () => {
    timerSnapshot = {
      main: state.main,
      first: state.first,
      second: state.second,
      yellow: state.yellow,
      red: state.red,
      grace: state.grace,
      preset: state.preset,
    };
  };

  const start = ()=>{
    if(raf) return;
    if (!inGrace) {
      snapshotSettings();
      if (acc === 0) { graceRemaining = timerSnapshot.grace; }
    }
    raf = requestAnimationFrame(loop);
  };
  
  const pause = ()=>{
    if(!raf) return;
    cancelAnimationFrame(raf);
    raf = null;
    const now = performance.now();
    acc += (now - startTs);
    startTs = null;
    stopContinuousBell();
  };
  
  const reset = ()=>{
    if(raf) cancelAnimationFrame(raf);
    raf = null; startTs = null; acc = 0; inGrace = false;
    remaining = state.main; 
    graceRemaining = state.grace;
    fired.first = fired.second = fired.final = false;
    stopContinuousBell();
    render(true);
  };

  startBtn.onclick = ()=>{ 
    if(raf) { pause(); startBtn.textContent = translations[currentLang].start; } 
    else { start(); startBtn.textContent = translations[currentLang].pause; } 
  };
  resetBtn.onclick = ()=>{ pause(); reset(); startBtn.textContent = translations[currentLang].start; };
  singleBtn.onclick = ()=>{ playBell(1); };
  doubleBtn.onclick = ()=>{ playBell(2); };

  // Scrubbing: main
  let isScrubbingMain = false;
  const mainScrubMove = (e) => {
    if (!isScrubbingMain) return;
    e.preventDefault();
    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
    if (typeof clientX === 'undefined') return;
    const rect = progressEl.getBoundingClientRect();
    let pct = (clientX - rect.left) / rect.width;
    pct = Math.max(0, Math.min(1, pct));
    if (raf !== null) { mainScrubEnd(); return; }
    const source = timerSnapshot;
    acc = source.main * pct;
    remaining = source.main - acc;
    inGrace = false; 
    graceRemaining = source.grace;
    if (acc < source.first) fired.first = false;
    if (acc < source.second) fired.second = false;
    fired.final = false;
    render(true);
  };
  const mainScrubEnd = () => {
    isScrubbingMain = false;
    document.removeEventListener('mousemove', mainScrubMove);
    document.removeEventListener('mouseup', mainScrubEnd);
    document.removeEventListener('touchmove', mainScrubMove);
    document.removeEventListener('touchend', mainScrubEnd);
  };
  const mainScrubStart = (e) => {
    if (raf !== null) return;
    snapshotSettings();
    isScrubbingMain = true;
    document.addEventListener('mousemove', mainScrubMove);
    document.addEventListener('mouseup', mainScrubEnd);
    document.addEventListener('touchmove', mainScrubMove, { passive: false });
    document.addEventListener('touchend', mainScrubEnd);
    mainScrubMove(e);
  };
  progressEl.addEventListener('mousedown', mainScrubStart);
  progressEl.addEventListener('touchstart', mainScrubStart, { passive: false });

  // Inputs handlers
  const syncFromInputs = ()=>{
    state.main = parseMin(mainInput.value);
    state.first = parseMin(firstInput.value);
    state.second = parseMin(secondInput.value);
    state.yellow = parseMin(yellowInput.value);
    state.red = parseMin(redInput.value);
    state.grace = parseMin(graceInput.value);
    state.spacing = Math.max(100, parseInt(spaceInput.value||'100',10)||100);
    state.prepTime = parseMin(prepInput.value);
    state.cexTime = parseMin(cexInput.value);
    state.rebTime = parseMin(rebInput.value);
    state.mode = modeSel.value;
    state.volume = parseFloat(volumeInput.value);
    if(mp3Url.value) state.mp3Url = mp3Url.value;
    localStorage.setItem('bellMode', state.mode);
    if(state.mp3Url) localStorage.setItem('mp3Url', state.mp3Url);
    localStorage.setItem('volume', String(state.volume));
    if (!raf) reset();
    prep.reset(true); cex.reset(true); reb.reset(true);
    modeLabel.textContent = state.preset==='Substantive'? translations[currentLang].substantiveSpeech : translations[currentLang].replySpeech;
    rebuttalLabel.textContent = `${translations[currentLang].rebTitle} (${fmt(state.rebTime)})`;
  };
  
  const syncInputsToState = () => {
    mainInput.value = fmt(state.main);
    firstInput.value = fmt(state.first);
    secondInput.value = fmt(state.second);
    yellowInput.value = fmt(state.yellow);
    redInput.value = fmt(state.red);
    graceInput.value = fmt(state.grace);
    spaceInput.value = state.spacing;
    prepInput.value = fmt(state.prepTime);
    cexInput.value = fmt(state.cexTime);
    rebInput.value = fmt(state.rebTime);
    volumeInput.value = state.volume;
    muteIconOn.style.display = state.muted ? 'none' : 'block';
    muteIconOff.style.display = state.muted ? 'block' : 'none';
    if (state.mp3Url) mp3Url.value = state.mp3Url;
    populateModeSelect();
    if (!raf) reset();
    prep.reset(); cex.reset(); reb.reset();
    rebuttalLabel.textContent = `${translations[currentLang].rebTitle} (${fmt(state.rebTime)})`;
  };
  
  function populateModeSelect() {
    const currentMode = state.mode;
    modeSel.innerHTML = '';
    const trans = translations[currentLang];
    const basics = document.createElement('optgroup');
    basics.label = trans.standardSounds;
    basics.innerHTML = `
      <option value="wav">${trans.builtInWAV}</option>
      <option value="mp3">${trans.mp3URLOpt}</option>
      <option value="synth">${trans.synthBell}</option>
    `;
    modeSel.appendChild(basics);
    if (uploadedSounds.length > 0) {
      const uploads = document.createElement('optgroup');
      uploads.label = trans.uploadedSounds;
      uploadedSounds.forEach((sound, index) => {
        const opt = document.createElement('option');
        opt.value = `upload_${index}`;
        opt.textContent = sound.name;
        uploads.appendChild(opt);
      });
      modeSel.appendChild(uploads);
    }
    if (modeSel.querySelector(`option[value="${currentMode}"]`)) {
      modeSel.value = currentMode;
    } else {
      state.mode = 'wav';
      modeSel.value = 'wav';
    }
  }
  
  [mainInput,firstInput,secondInput,yellowInput,redInput,graceInput,spaceInput,modeSel,mp3Url,volumeInput, prepInput, cexInput, rebInput].forEach(el=> el.addEventListener('change', syncFromInputs));
  
  mp3File.addEventListener('change', (e)=>{ 
    const files = e.target.files;
    if (!files || files.length === 0) return;
    let firstUploadIndex = uploadedSounds.length;
    Array.from(files).forEach(file => {
      const url = URL.createObjectURL(file);
      uploadedSounds.push({ name: file.name, url: url });
    });
    populateModeSelect();
    state.mode = `upload_${firstUploadIndex}`;
    modeSel.value = state.mode;
    e.target.value = null; 
  });

  function applyPreset(key){
    state.preset=key;
    modeLabel.textContent = state.preset==='Substantive'? translations[currentLang].substantiveSpeech : translations[currentLang].replySpeech;
  }

  function miniTimer(clockEl, fillEl, stateKey, endBellCount = 0){
    let snapshotDur = state[stateKey];
    let rem = state[stateKey]; 
    let st=null, acc=0, r=null;
    
    const progressContainerEl = fillEl.parentElement;
    let isScrubbing = false;

    const scrubMove = (e) => {
      if (!isScrubbing) return;
      e.preventDefault();
      const clientX = e.clientX || (e.touches && e.touches[0].clientX);
      if (typeof clientX === 'undefined') return;
      const rect = progressContainerEl.getBoundingClientRect();
      let pct = (clientX - rect.left) / rect.width;
      pct = Math.max(0, Math.min(1, pct));
      if (r !== null) { scrubEnd(); return; }
      acc = snapshotDur * pct;
      rem = snapshotDur - acc;
      paint();
    };

    const scrubEnd = () => {
      isScrubbing = false;
      document.removeEventListener('mousemove', scrubMove);
      document.removeEventListener('mouseup', scrubEnd);
      document.removeEventListener('touchmove', scrubMove);
      document.removeEventListener('touchend', scrubEnd);
    };

    const scrubStart = (e) => {
      if (r !== null) return; 
      snapshotDur = state[stateKey];
      isScrubbing = true;
      document.addEventListener('mousemove', scrubMove);
      document.addEventListener('mouseup', scrubEnd);
      document.addEventListener('touchmove', scrubMove, { passive: false });
      document.addEventListener('touchend', scrubEnd);
      scrubMove(e);
    };

    progressContainerEl.addEventListener('mousedown', scrubStart);
    progressContainerEl.addEventListener('touchstart', scrubStart, { passive: false });

    const paint = ()=>{ 
      const displayRem = (r === null && acc === 0) ? state[stateKey] : rem;
      clockEl.textContent = fmt(displayRem); 
      const pct = snapshotDur === 0 ? 0 : 100 - Math.round((rem/snapshotDur)*100); 
      fillEl.style.width = Math.max(0,Math.min(100,pct))+"%"; 
    };
    
    const lp = (ts)=>{ 
      if(st===null) st=ts; 
      const el=(ts-st)+acc; 
      rem=Math.max(0,snapshotDur-el); 
      paint(); 
      if(rem>0) {
        r=requestAnimationFrame(lp); 
      } else {
        cancelAnimationFrame(r);
        r = null;
        if (endBellCount > 0) {
          playBell(endBellCount);
        }
      }
    };
    
    const start=()=>{ 
      if(r) return; 
      if (acc === 0) { snapshotDur = state[stateKey]; }
      rem = snapshotDur - acc;
      st = null;
      r = requestAnimationFrame(lp); 
    };
    
    const pause=()=>{ 
      if(!r) return;
      cancelAnimationFrame(r);
      r=null;
      const now = performance.now();
      if(st) acc += (now - st);
      st=null;
    };
    
    const reset=(dontPauseIfRunning = false)=>{
      if (dontPauseIfRunning && r) return;
      if(r) cancelAnimationFrame(r);
      r=null; st=null; acc=0;
      rem = state[stateKey];
      snapshotDur = state[stateKey];
      paint();
    };
    
    paint();
    return { start, pause, reset, paint };
  }
  
  const prep = miniTimer(prepClock, prepFill, 'prepTime', 1);
  const cex = miniTimer(cexClock, cexFill, 'cexTime', 1);
  const reb = miniTimer(rebClock, rebFill, 'rebTime', 2);
  
  prepStart.onclick = ()=>{ const btn = prepStart; if(btn.textContent === translations[currentLang].start){ prep.start(); btn.textContent = translations[currentLang].pause; } else { prep.pause(); btn.textContent = translations[currentLang].start; } };
  prepReset.onclick = ()=>{ prep.reset(); prepStart.textContent = translations[currentLang].start; };
  cexStart.onclick = ()=>{ const btn = cexStart; if(btn.textContent === translations[currentLang].start){ cex.start(); btn.textContent = translations[currentLang].pause; } else { cex.pause(); btn.textContent = translations[currentLang].start; } };
  cexReset.onclick = ()=>{ cex.reset(); cexStart.textContent = translations[currentLang].start; };
  rebStart.onclick = ()=>{ const btn = rebStart; if(btn.textContent === translations[currentLang].start){ reb.start(); btn.textContent = translations[currentLang].pause; } else { reb.pause(); btn.textContent = translations[currentLang].start; } };
  rebReset.onclick = ()=>{ reb.reset(); rebStart.textContent = translations[currentLang].start; };

  function render(forceState = false){
    const source = (raf && !forceState) ? timerSnapshot : state;
    const total = source.main;
    const currentRemaining = inGrace ? graceRemaining : remaining;
    clockEl.textContent = fmt(currentRemaining);
    if (inGrace) clockEl.textContent = '-' + fmt(graceRemaining);
    const bg = currentRemaining <= source.red ? 'var(--bg-red)' : currentRemaining <= source.yellow ? 'var(--bg-yellow)' : 'var(--bg-green)';
    const fg = currentRemaining <= source.red ? 'var(--fg-red)' : currentRemaining <= source.yellow ? 'var(--fg-yellow)' : 'var(--fg-green)';
    const bd = currentRemaining <= source.red ? 'var(--bd-red)' : currentRemaining <= source.yellow ? 'var(--bd-yellow)' : 'var(--bd-green)';
    if (inGrace) {
      const flash = Math.floor(performance.now() / 500) % 2 === 0;
      wrap.style.background = flash ? 'var(--bg-red)' : 'var(--bg-card)';
      wrap.style.color = flash ? 'var(--fg-red)' : 'var(--fg)';
      document.documentElement.style.setProperty('--bd', flash ? 'var(--bd-red)' : 'var(--bd-green)');
    } else {
      wrap.style.background = bg;
      wrap.style.color = fg;
      document.documentElement.style.setProperty('--bd', bd);
    }
    const a = Math.min(source.first || 0, total);
    const b = Math.min(Math.max(0, (source.second || 0) - (source.first || 0)), total);
    const c = Math.max(0, total - (a + b));
    const pct = n => total === 0 ? 0 : (n/total)*100;
    const fillPct = total === 0 ? 100 : pct(total-remaining);
    fillEl.style.width = fillPct+"%";
    segA.style.width = pct(a)+"%"; segB.style.width = pct(b)+"%"; segC.style.width = pct(c)+"%";
    capA.textContent = `0 → 1st: ${source.first?fmt(source.first):'-'}`;
    capB.textContent = `1st → 2nd: ${(source.first&&source.second)?fmt(source.second-source.first):'-'}`;
    capC.textContent = `2nd → Final: ${source.second?fmt(total-source.second):fmt(total-(source.first||0))}`;
    metaEl.textContent = `Main: ${fmt(total)}${source.first?` · 1st ${fmt(source.first)}`:''}${source.second?` · 2nd ${fmt(source.second)}`:''}`;
    if (inGrace) metaEl.textContent = `${translations[currentLang].gracePeriodLabel} ${fmt(source.grace)}`;
  }

  function checkBells(){
    const elapsed = timerSnapshot.main - remaining;
    if(!fired.first && timerSnapshot.first>0 && elapsed>=timerSnapshot.first){ playBell(1); fired.first=true; }
    if(!fired.second && timerSnapshot.second>0 && elapsed>=timerSnapshot.second){ playBell(1); fired.second=true; } 
  }
  
  // ===== Profile Management =====
  function getProfiles() { return JSON.parse(localStorage.getItem(PROFILES_DB_KEY) || '[]'); }
  function findProfileByName(name) {
    const def = DEFAULT_PROFILES.find(p => p.name === name);
    if (def) return def;
    return getProfiles().find(p => p.name === name);
  }
  function loadProfilesToDropdown() {
    const profiles = getProfiles();
    const selectedValue = profileSelect.value;
    profileSelect.innerHTML = '';
    const trans = translations[currentLang];
    const defaultGroup = document.createElement('optgroup');
    defaultGroup.label = trans.builtInProfiles;
    DEFAULT_PROFILES.forEach(profile => {
      const opt = document.createElement('option');
      opt.value = profile.name;
      opt.textContent = profile.name;
      defaultGroup.appendChild(opt);
    });
    profileSelect.appendChild(defaultGroup);
    if (profiles.length > 0) {
      const customGroup = document.createElement('optgroup');
      customGroup.label = trans.customProfiles;
      profiles.forEach(profile => {
        const opt = document.createElement('option');
        opt.value = profile.name;
        opt.textContent = profile.name;
        customGroup.appendChild(opt);
      });
      profileSelect.appendChild(customGroup);
    }
    profileSelect.value = selectedValue || DEFAULT_PROFILES[0].name;
  }
  function loadSelectedProfile(name) {
    const profileName = name || profileSelect.value;
    if (!profileName) return;
    const profile = findProfileByName(profileName);
    if (!profile) { console.error('Error: Could not find profile.'); return; }
    speakerOrder = JSON.parse(JSON.stringify(profile.speakerOrder)); 
    Object.assign(state, JSON.parse(JSON.stringify(profile.settings)));
    syncInputsToState();
    initSpeakerProgress();
    setActiveSpeaker(0);
    localStorage.setItem('bellMode', state.mode);
    if(state.mp3Url) localStorage.setItem('mp3Url', state.mp3Url);
    localStorage.setItem('volume', String(state.volume));
    updateLanguage(currentLang);
  }
  function saveCurrentProfile() {
    const name = prompt(translations[currentLang].profilePrompt, 'My Custom Debate');
    if (!name || name.trim() === '') return;
    if (isDefaultProfile(name.trim())) { console.error(translations[currentLang].cannotOverwriteDefault); return; }
    syncFromInputs();
    const newProfile = { name: name.trim(), speakerOrder: speakerOrder, settings: state };
    let profiles = getProfiles();
    const existingIndex = profiles.findIndex(p => p.name === newProfile.name);
    if (existingIndex > -1) profiles[existingIndex] = newProfile;
    else profiles.push(newProfile);
    localStorage.setItem(PROFILES_DB_KEY, JSON.stringify(profiles));
    loadProfilesToDropdown();
    profileSelect.value = newProfile.name;
  }
  function deleteSelectedProfile() {
    const profileName = profileSelect.value;
    if (isDefaultProfile(profileName)) { console.error(translations[currentLang].cannotDeleteDefault); return; }
    let profiles = getProfiles();
    profiles = profiles.filter(p => p.name !== profileName);
    localStorage.setItem(PROFILES_DB_KEY, JSON.stringify(profiles));
    loadProfilesToDropdown();
    loadSelectedProfile(DEFAULT_PROFILES[0].name);
  }
  function exportProfiles() {
    const profiles = getProfiles();
    const dataStr = "data:application/json;charset=utf-8," + encodeURIComponent(JSON.stringify(profiles, null, 2));
    const a = document.createElement('a');
    a.href = dataStr;
    a.download = 'debate_timer_profiles.json';
    a.click();
    a.remove();
  }
  function importProfiles(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const importedProfiles = JSON.parse(e.target.result);
        if (!Array.isArray(importedProfiles)) throw new Error('Not an array');
        let existingProfiles = getProfiles();
        const profileMap = new Map();
        existingProfiles.forEach(p => profileMap.set(p.name, p));
        importedProfiles.forEach(p => { if (p.name && p.speakerOrder && p.settings && !isDefaultProfile(p.name)) profileMap.set(p.name, p); });
        const mergedProfiles = Array.from(profileMap.values());
        localStorage.setItem(PROFILES_DB_KEY, JSON.stringify(mergedProfiles));
        loadProfilesToDropdown();
      } catch (err) {}
    };
    reader.readAsText(file);
    event.target.value = null;
  }
  loadProfileBtn.onclick = () => loadSelectedProfile();
  saveProfileBtn.onclick = saveCurrentProfile;
  deleteProfileBtn.onclick = deleteSelectedProfile;
  exportProfilesBtn.onclick = exportProfiles;
  importProfilesInput.onchange = importProfiles;

  // Initial paint
  const savedLang = localStorage.getItem('debateTimerLang') || 'en';
  updateLanguage(savedLang);

  // ===== Tests =====
  const tests = [
    {name:'formatTime 61000 -> 1:01', run:()=> fmt(61000)==='1:01'},
    {name:'parse m:ss 2:30 -> 150000', run:()=> parseMin('2:30')===150000},
    {name:'parse m only 3 -> 180000', run:()=> parseMin('3')===180000},
    {name:'threshold order yellow>red', run:()=> 60000>30000},
    {name:'spacing clamp', run:()=> Math.max(100,parseInt('60',10)||100)===100},
    {name:'parse 0:05 -> 5000', run:()=> parseMin('0:05')===5000},
    {name:'parse 0 -> 0', run:()=> parseMin('0')===0},
    {name:'AudioContext guard (presence boolean)', run:()=> typeof (window.AudioContext||window.webkitAudioContext)!=='undefined' || true },
    {name:'Fixed digit bug', run:()=> allDigitsFixed('123') && !allDigitsFixed('12g') }
  ];
  const testList = $('#testList');
  const showTests = ()=>{ testList.innerHTML=''; tests.forEach(t=>{ const li=document.createElement('li'); let ok=false; try{ ok=t.run(); }catch{ ok=false } li.textContent=(ok?'PASS ':'FAIL ')+t.name; li.style.color=ok?'#065f46':'#7f1d1d'; testList.appendChild(li); }); };
  testsBtn.addEventListener('click', showTests);

})();
</script>
</body>
</html>
