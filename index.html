<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Debate Timer — SimsonTimer Final</title>
<style>
  /* ---------- THEME ---------- */
  :root{
    --bg:#f9fafb; --fg:#111827; --card:#ffffff; --bd:#e5e7eb;
    --track:#e5e7eb; --fill:#111827; --muted:#6b7280;
    --ok-bg:#d1fae5; --ok-fg:#065f46; --warn-bg:#fef3c7; --warn-fg:#92400e; --bad-bg:#fee2e2; --bad-fg:#7f1d1d;
    --prop-bg:#dbeafe; --prop-border:#93c5fd; --prop-fg:#1e3a8a;
    --opp-bg:#fee2e2; --opp-border:#fca5a5; --opp-fg:#7f1d1d;
    --prep-bg:#f3f4f6; --prep-border:#d1d5db; --prep-fg:#374151;
    --grace-fg: #7f1d1d; /* Color for grace text in presenter */
    /* NEW: Active/Inverted State Colors */
    --btn-active-bg: #111827;
    --btn-active-fg: #ffffff;
  }
  :root.dark{
    --bg:#1f2937; --fg:#f9fafb; --card:#111827; --bd:#374151;
    --track:#374151; --fill:#f9fafb; --muted:#9ca3af;
    --grace-fg: #f9fafb;
    /* NEW: Active/Inverted State Colors (Dark) */
    --btn-active-bg: #f9fafb;
    --btn-active-fg: #1f2937;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--fg);font:16px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  
  /* --- FIX: App/Presenter Mode Toggle (prevents FOUC) --- */
  /* Hide both roots by default */
  #mainAppRoot, #presenterRoot {
    display: none;
  }
  /* Show main app when in main mode */
  body.main-mode #mainAppRoot {
    display: block;
  }
  /* Show presenter root when in presenter mode */
  body.presenter-mode #presenterRoot {
    display: flex; /* Use flex to center it */
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    text-align: center;
  }
  /* --- End App/Presenter Mode Toggle --- */

  .wrap{min-height:100%;display:flex;flex-direction:column;gap:24px;align-items:center;padding:24px}
  .container{width:100%;max-width:1100px;display:flex;flex-direction:column;gap:16px}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
  h1{font-size:24px;margin:0}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .btn{appearance:none;border:1px solid var(--bd);background:var(--card);color:var(--fg);border-radius:12px;padding:10px 14px;cursor:pointer;font-weight:700}
  .btn:active{transform:translateY(1px)}
  .card{background:var(--card);border:1px solid var(--bd);border-radius:16px;padding:16px}
  .muted{color:var(--muted)}
  .clock{font-family: "Rubik", ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; font-size:76px; font-weight:900; text-align:center; line-height:1.08; letter-spacing:1px}
  .progress{height:14px;background:var(--track);border-radius:999px;position:relative;overflow:hidden;touch-action:none}
  .fill{position:absolute;inset:0;transform-origin:left center;background:var(--fill);transform:scaleX(0)}
  .grid{display:grid;gap:12px}
  .grid-4{grid-template-columns:repeat(4,minmax(0,1fr))}
  .grid-3{grid-template-columns:repeat(3,minmax(0,1fr))}
  .label{display:flex;flex-direction:column;gap:6px}
  input.input, select.input, textarea.input{padding:10px 12px;border-radius:10px;border:1px solid var(--bd);background:var(--card);color:var(--fg)}
  .note{font-size:14px;color:var(--muted)}
  .speaker-progress{display:flex;flex-wrap:wrap;gap:9px;padding:6px 4px}
  .spk{font-size:13px;font-weight:800;padding:10px 10px;border-radius:10px;background:var(--card);border:2px solid var(--bd);cursor:grab;user-select:none;min-width:58px;text-align:center;display:flex;align-items:center;justify-content:center}
  .spk.inactive{opacity:.4;text-decoration:line-through}
  .spk.active{box-shadow:0 0 0 3px rgba(0,0,0,0.06) inset}
  .spk.prop{background:var(--prop-bg);border-color:var(--prop-border);color:var(--prop-fg)}
  .spk.opp{background:var(--opp-bg);border-color:var(--opp-border);color:var(--opp-fg)}
  .spk.prep{background:var(--prep-bg);border-color:var(--prep-border);color:var(--prep-fg)}
  
  /* --- NEW: Active speaker inverted color --- */
  .spk.active.prop { background: var(--prop-fg); color: var(--prop-bg); }
  .spk.active.opp { background: var(--opp-fg); color: var(--opp-bg); }
  .spk.active.prep { background: var(--prep-fg); color: var(--prep-bg); }
  .spk.active.neutral { background: var(--fg); color: var(--bg); }
  
  /* Modals */
  #helpModal, #confirmModal {position:fixed;inset:0;background:rgba(0,0,0,.5);display:none;align-items:center;justify-content:center;padding:16px;z-index:100}
  #helpModal .card, #confirmModal .card {max-width:760px;max-height:90vh;overflow:auto}
  #confirmModal .card { max-width: 400px; }
  
  @media (max-width:800px){.grid-3{grid-template-columns:repeat(2,minmax(0,1fr))}.grid-4{grid-template-columns:repeat(2,minmax(0,1fr))}}
  @media (max-width:540px){.grid-3{grid-template-columns:1fr}.grid-4{grid-template-columns:1fr}.clock{font-size:56px}}
  
  /* Hideable settings/timers/notes panel */
  #settingsPanel, #quickTimersPanel {
    overflow: hidden;
    max-height: 1000px; /* Default open height for transition */
    transition: max-height 0.35s ease;
  }
  /* Fix: Notes panel transition (was getting cut off) */
  #notesPanel {
    overflow: hidden;
    transition: max-height 0.35s ease, padding-top 0.35s ease, padding-bottom 0.35s ease, border-width 0.35s ease;
    max-height: 500px; /* Default open height */
    padding: 16px;
    border-width: 1px;
  }

  /* STATE COLORS VIA BODY CLASSES */
  body.state-warn{background:var(--warn-bg); color:var(--warn-fg)}
  body.state-bad{background:var(--bad-bg); color:var(--bad-fg)}
  body.state-warn .card, body.state-bad .card{border-color: currentColor}
  body.state-grace{animation:pulseGrace 2.4s ease-in-out infinite}
  @keyframes pulseGrace{0%{background:var(--bg)}50%{background:var(--bad-bg)}100%{background:var(--bg)}}
  
  /* Icon Buttons Base */
  .btn-icon {
    width: 46px; /* 10px*2 padding + 24px icon + 2px border */
    height: 46px;
    padding: 10px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
    flex-shrink: 0;
  }
  .btn-icon svg {
    width: 24px;
    height: 24px;
  }
  
  /* NEW: Active/Inverted State for *any* button */
  .btn.active {
    background: var(--btn-active-bg);
    color: var(--btn-active-fg);
  }
  /* Make active inverted icons readable */
  .btn.active svg {
    stroke: var(--btn-active-fg);
  }
  
  /* FIX: Readability for Header Icons */
  /* Default header icons to be outlines */
  #helpBtn svg, #themeBtn svg, #presenterBtn svg, #mirrorBtn svg, #toggleQuickTimers svg, #toggleNotesBtn svg {
    fill: none;
    stroke: currentColor;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  /* Specific icons that *should* be filled */
  .dark #themeBtn .icon-dark, /* Moon in dark mode */
  #themeBtn .icon-light, /* Sun in light mode */
  #muteBtn .icon-on, /* Mute On */
  #muteBtn.muted .icon-off { /* Mute Off */
    fill: currentColor;
    stroke: none;
  }
  
  /* Theme button logic (Sun/Moon swap) */
  #themeBtn .icon-light { display: none; } /* Hide sun in light mode */
  .dark #themeBtn .icon-dark { display: none; } /* Hide moon in dark mode */
  .dark #themeBtn .icon-light { display: inline-block; } /* Show sun in dark mode */
  
  /* Mute button logic */
  #muteBtn .icon-off { display: none; }
  #muteBtn.muted .icon-on { display: none; }
  #muteBtn.muted .icon-off { display: inline-block; }
  
  /* Toggle Notes/Timers button logic (Slash icons) */
  #toggleQuickTimers .icon-no-slash, #toggleNotesBtn .icon-no-slash { display: none; }
  #toggleQuickTimers.open .icon-slash, #toggleNotesBtn.open .icon-slash { display: none; }
  #toggleQuickTimers.open .icon-no-slash, #toggleNotesBtn.open .icon-no-slash { display: inline-block; }
  
  /* Main Timer Button Logic */
  /* This holds the Start/Pause text */
  .btn-main-timer {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    padding-top: 12px;
    padding-bottom: 12px;
    width: 72px; /* Fixed width */
    height: auto;
  }
  .btn-main-timer .label-text {
    font-size: 11px;
    font-weight: 700;
  }
  #startBtn.running .icon-play { display: none; }
  #startBtn.running .icon-pause { display: block; }
  #startBtn .icon-pause { display: none; }
  #startBtn .icon-play { display: block; }
  /* Main timer icons should be fill */
  #startBtn svg, #singleBtn svg, #doubleBtn svg, #stopBellBtn svg {
    fill: currentColor;
    stroke: none;
  }
  /* Fix for reset/cont bell which are outlines */
  #resetBtn svg, #testContBtn svg {
    fill: none;
    stroke: currentColor;
    stroke-width: 2.5;
  }
  /* Fix: Thinner stroke for continuous bell inner icon */
  #testContBtn svg:last-child {
    stroke-width: 2.8;
  }


  /* Presenter grace mode */
  .presenter-grace #pClock { color: var(--grace-fg); }
  .presenter-grace { animation: gracePulse 1.6s ease-in-out infinite !important; }
  @keyframes gracePulse {
    0% { background: var(--bg); color: var(--fg); }
    50% { background: var(--bad-bg); color: var(--bad-fg); }
    100% { background: var(--bg); color: var(--fg); }
  }
  .presenter-grace.state-grace #pClock {
    color: var(--bad-fg);
  }
  
  /* --- Presenter Mode Root Styles --- */
  #pClock {
    font-family: "Rubik", ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    font-weight: 900;
    font-size: 22vw;
    line-height: 1;
    letter-spacing: 2px;
  }
  #pMeta {
    margin-top: 12px;
    color: var(--muted);
    font-weight: 700;
    font-size: 2vw; /* Make meta text responsive */
  }
  
  /* --- Mirror Mode Styles --- */
  body.mirror-mode .wrap {
    padding: 24px; /* Keep some padding */
  }
  body.mirror-mode .container {
    max-width: 100%; /* Allow main card to be centered */
  }
  /* Hide everything except the main timer card */
  body.mirror-mode #mainAppRoot header,
  body.mirror-mode #mainAppRoot .card:first-child, /* Speaker Progress card */
  body.mirror-mode #notesPanel, /* HIDE NOTES IN MIRROR MODE */
  body.mirror-mode #quickTimersPanel,
  body.mirror-mode #mainAppRoot .card:last-child { /* Settings card */
    display: none;
  }
  /* Make main timer title clickable to exit */
  body.mirror-mode #mainTitle {
    cursor: pointer;
  }
  
  /* --- Bigger Mirror Mode Timer --- */
  body.mirror-mode #mainCard { /* Target main card specifically */
    border: none;
    box-shadow: none;
    background: transparent;
    padding: 0;
  }
  body.mirror-mode #clock {
    font-size: 20vw; /* Make it huge like presenter mode */
    font-size: clamp(76px, 20vw, 220px); /* Add clamp for usability */
    line-height: 1;
    margin-top: 24px; /* Add some space */
  }
  
</style>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Rubik:wght@700;900&display=swap" rel="stylesheet">
</head>
<body>

  <!-- 
    FIX: This root is for the main application. 
    It will be hidden if `?presenter=true` is in the URL.
  -->
  <div id="mainAppRoot">
    <div class="wrap">
      <div class="container">
        <header>
          <!-- Title removed for space -->
          <div class="row">
            <label class="label">
              <span style="font-weight:700" data-lang-key="debateStyle">Debate Style</span>
              <select id="formatSelect" class="input">
                <option value="SIMSON">Simson</option>
                <option value="AP">AP</option>
                <option value="BP">BP</option>
                <option value="WSDC">WSDC</option>
                <option value="PF">PF</option>
                <option value="CX">Policy / CX</option>
                <option value="LD">Lincoln–Douglas</option>
                <option value="CUSTOM">Custom</option>
              </select>
            </label>
            <label class="label" style="flex-direction:row;align-items:center;gap:8px; margin-top: 18px;">
              <span style="font-weight:700" data-lang-key="volume">Volume</span>
              <input id="volume" type="range" min="0" max="1" step="0.05" value="0.6" style="min-width: 80px;">
            </label>
            <label class="label" style="flex-direction:row;align-items:center;gap:8px; margin-top: 18px;">
              <span style="font-weight:700" data-lang-key="lang">Lang</span>
              <select id="langSelect" class="input" style="padding-top:10px; padding-bottom:10px;">
                <option value="en">English</option>
                <option value="ko">한국어</option>
              </select>
            </label>
          </div>
          <div class="row" style="margin-top: 18px;">
            <button id="helpBtn" class="btn btn-icon" title="Help (H)">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
            </button>
            <button id="themeBtn" class="btn btn-icon" title="Toggle Dark Mode (D)">
              <svg class="icon-light" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
              <svg class="icon-dark" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
            </button>
            <button id="presenterBtn" class="btn btn-icon" title="Presenter Mode (P)">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>
            </button>
            <button id="mirrorBtn" class="btn btn-icon" title="Mirror Mode">
              <!-- Mirror Icon -->
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 3h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-1M10 21h9a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2h-1"></path></svg>
            </button>
            <button id="toggleQuickTimers" class="btn btn-icon" title="Toggle Quick Timers">
              <svg class="icon-slash" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 3v6h6"></path><path d="M3.4 13A9 9 0 1 0 3.4 5V3"></path><path d="M12 6v6l4 2"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>
              <svg class="icon-no-slash" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 3v6h6"></path><path d="M3.4 13A9 9 0 1 0 3.4 5V3"></path><path d="M12 6v6l4 2"></path></svg>
            </button>
            <button id="toggleNotesBtn" class="btn btn-icon" title="Toggle Speaker Notes">
              <svg class="icon-slash" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline><line x1="1" y1="1" x2="23" y2="23"></line></svg>
              <svg class="icon-no-slash" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>
            </button>
            <button id="enableBtn" class="btn" data-lang-key="initSound" style="padding: 10px 14px;">Initialize Sound</button>
            <button id="muteBtn" class="btn btn-icon" title="Mute (M)">
              <svg class="icon-on" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke="none"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
              <svg class="icon-off" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M11 5L6 9H2v6h4l5 4V5z"></path><path d="M23 9l-6 6"></path><path d="M17 9l6 6"></path></svg>
            </button>
          </div>
        </header>
  
        <!-- Speaker Progress --><div class="card">
          <div style="font-weight:800;margin-bottom:8px" data-lang-key="spkProgress">Speaker Progress</div>
          <div id="spkBar" class="speaker-progress"></div>
          <div class="row" style="justify-content:space-between;margin-top:8px">
            <div class="row">
              <button id="prevBtn" class="btn" data-lang-key="prev">Previous</button>
              <button id="nextBtn" class="btn" data-lang-key="next">Next</button>
            </div>
            <button id="resetOrder" class="btn" data-lang-key="resetOrder">Reset Order</button>
          </div>
          <div class="note" data-lang-key="spkNote">Click = select • Double-click = toggle active • Drag = reorder</div>
        </div>
  
        <!-- Main Timer Card --><div class="card" id="mainCard">
          <div class="row" style="justify-content:space-between"><div id="mainTitle" style="font-weight:800">Substantive Speech</div><div id="meta" class="muted"></div></div>
          <div id="clock" class="clock">7:00</div>
          <div id="mainProgress" class="progress"><div id="fill" class="fill"></div></div>
          <div class="row" style="justify-content:center;margin-top:10px">
            <button id="startBtn" class="btn btn-main-timer" title="Start/Pause (Space)">
              <svg class="icon-play" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 4l12 8-12 8V4z"></path></svg>
              <svg class="icon-pause" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"></path></svg>
              <span class="label-text" data-lang-key="start">Start</span>
            </button>
            <button id="resetBtn" class="btn btn-main-timer" title="Reset (R)">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path d="M1 4v6h6"></path>
                <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
              </svg>
              <span class="label-text" data-lang-key="reset">Reset</span>
            </button>
            <button id="singleBtn" class="btn btn-main-timer" title="Single Bell (1)">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path></svg>
              <span class="label-text" data-lang-key="single">Single</span>
            </button>
            <button id="doubleBtn" class="btn btn-main-timer" title="Double Bell (2)">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path></svg>
              <span class="label-text" data-lang-key="double">Double</span>
            </button>
            <button id="testContBtn" class="btn btn-main-timer" title="Start continuous bell test">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="width: 21px; height: 21px;">
                <path d="M1 4v6h6"></path>
                <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
              </svg>
              <svg xmlns="http://www.w3.org/2D/svg" viewBox="0 0 24 24" style="width: 19px; height: 19px; margin-left: -6px; margin-top: -2px;">
                <path d="M10 10C6 10 6 14 10 14c4 0 4-4 8-4 4 0 4 4 0 4s-4-4-8-4z"></path>
              </svg>
              <span class="label-text" data-lang-key="cont">Cont.</span>
            </button>
            <button id="stopBellBtn" class="btn btn-main-timer" title="Stop continuous bell">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13.73 21a2 2 0 0 1-3.46 0"></path><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="m1 1 22 22"></path></svg>
              <span class="label-text" data-lang-key="stop">Stop</span>
            </button>
          </div>
          <div class="note"><strong data-lang-key="status">Status:</strong> <span id="status">idle</span></div>
        </div>
        
        <!-- NEW Notes Card (Hideable) -->
        <div id="notesPanel" class="card">
          <div class="row" style="justify-content:space-between; margin-bottom: 12px;">
            <div style="font-weight:800;margin-bottom:8px" data-lang-key="speakerNotes">Speaker Notes</div>
            <div class="row">
              <button id="exportNotesBtn" class="btn" data-lang-key="exportNotes">Export Notes</button>
              <button id="importNotesBtn" class="btn" data-lang-key="importNotes">Import Notes</button>
              <button id="clearNotesBtn" class="btn" data-lang-key="clearAllNotes">Clear All Notes</button>
              <input id="importNotesFile" type="file" accept="application/json,text/plain" style="display:none">
            </div>
          </div>
          <textarea id="notesArea" class="input" style="width:100%;min-height:110px;font:inherit" data-lang-key="notesPlaceholder"></textarea>
        </div>
  
        <!-- Quick Timers --><div id="quickTimersPanel" class="grid grid-4">
          <div class="card">
            <div style="font-weight:800;margin-bottom:6px" data-lang-key="crossEx">Cross-Ex / Shared</div>
            <div id="cexClock" class="clock" style="font-size:32px">01:00</div>
            <div class="progress" style="margin-top:8px"><div id="cexFill" class="fill"></div></div>
            <div class="row" style="justify-content:center;margin-top:8px"><button id="cexStart" class="btn" data-lang-key="start">Start</button><button id="cexReset" class="btn" data-lang-key="reset">Reset</button></div>
          </div>
          <div class="card">
            <div style="font-weight:800;margin-bottom:6px" data-lang-key="rebuttal">Rebuttal / Reply</div>
            <div id="rebClock" class="clock" style="font-size:32px">04:00</div>
            <div class="progress" style="margin-top:8px"><div id="rebFill" class="fill"></div></div>
            <div class="row" style="justify-content:center;margin-top:8px"><button id="rebStart" class="btn" data-lang-key="start">Start</button><button id="rebReset" class="btn" data-lang-key="reset">Reset</button></div>
          </div>
          <div class="card">
            <div style="font-weight:800;margin-bottom:6px" data-lang-key="prep">Prep</div>
            <div id="prepClock" class="clock" style="font-size:32px">01:00</div>
            <div class="progress" style="margin-top:8px"><div id="prepFill" class="fill"></div></div>
            <div class="row" style="justify-content:center;margin-top:8px"><button id="prepStart" class="btn" data-lang-key="start">Start</button><button id="prepReset" class="btn" data-lang-key="reset">Reset</button></div>
          </div>
          <div class="card">
            <div style="font-weight:800;margin-bottom:6px" data-lang-key="poi">POI</div>
            <div id="poiClock" class="clock" style="font-size:32px">00:15</div>
            <div class="progress" style="margin-top:8px"><div id="poiFill" class="fill"></div></div>
            <div class="row" style="justify-content:center;margin-top:8px"><button id="poiStart" class="btn" data-lang-key="start">Start</button><button id="poiReset" class="btn" data-lang-key="reset">Reset</button></div>
          </div>
        </div>
  
        <!-- Settings (hideable) --><div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px"><span style="font-weight:800;" data-lang-key="settingsTitle">Timer Settings</span><button id="toggleSettings" class="btn" style="padding:6px 10px;font-size:14px">Hide</button></div>
          <div id="settingsPanel">
            <div class="grid grid-4">
              <label class="label"><span data-lang-key="mainTime">Main (m:ss)</span><input id="mainInput" class="input" value="3:00"/></label>
              <label class="label"><span data-lang-key="firstBell">1st Bell from start (m:ss)</span><input id="firstInput" class="input" value="1:00"/></label>
              <label class="label"><span data-lang-key="secondBell">2nd Bell from start (m:ss)</span><input id="secondInput" class="input" value="2:00"/></label>
              <label class="label"><span data-lang-key="yellowAt">Yellow at remaining (m:ss)</span><input id="yellowInput" class="input" value="1:00"/></label>
              <label class="label"><span data-lang-key="redAt">Red at remaining (m:ss)</span><input id="redInput" class="input" value="0:30"/></label>
              <label class="label"><span data-lang-key="gracePeriod">Grace Period (m:ss)</span><input id="graceInput" class="input" value="0:30"/></label>
              <label class="label"><span data-lang-key="prepTime">Prep Time (m:ss)</span><input id="prepInput" class="input" value="1:00"/></label>
              <label class="label"><span data-lang-key="crossExTime">Cross-Ex (m:ss)</span><input id="cexInput" class="input" value="1:00"/></label>
              <label class="label"><span data-lang-key="rebuttalTime">Rebuttal (m:ss)</span><input id="rebInput" class="input" value="3:00"/></label>
              <label class="label"><span data-lang-key="poiTime">POI Time (m:ss)</span><input id="poiInput" class="input" value="0:15"/></label>
              <label class="label"><span data-lang-key="bellSpacing">Bell spacing (ms)</span><input id="spaceInput" class="input" value="250"/></label>
            </div>
            <div class="row" style="margin-top:12px;gap:8px;flex-wrap:wrap">
              <button id="exportBtn" class="btn" data-lang-key="exportSettings">Export Settings</button>
              <button id="importBtn" class="btn" data-lang-key="importSettings">Import Settings</button>
              <input id="importFile" type="file" accept="application/json" style="display:none">
            </div>
          </div>
        </div>
  
      </div>
    </div>
  </div><!-- End #mainAppRoot -->

  <!-- 
    FIX: This root is for the PRESENTER view. 
    It is hidden by default and will be shown if `?presenter=true` is in the URL.
  -->
  <div id="presenterRoot">
    <div class="presenter-wrap">
      <div id="pClock">00:00</div>
      <div id="pMeta">Presenter</div>
    </div>
  </div>

  <!-- Help Modal (lives outside main app root) --><div id="helpModal">
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
        <h2 style="margin:0" data-lang-key="helpTitle">Help</h2>
        <button id="closeHelp" class="btn" data-lang-key="close">Close</button>
      </div>
      <hr style="border:0;border-top:1px solid var(--bd);margin:12px 0"/>
      <h3 data-lang-key="quickStart">Quick Start</h3>
      <ol>
        <li data-lang-key="quickStart1"><strong><u>Click <strong>Initialize Sound</strong> once.</u></strong> (Mobile browsers require a gesture to enable audio).</li>
        <li data-lang-key="quickStart2">Select your <strong>Debate Style</strong> from the dropdown.</li>
        <li data-lang-key="quickStart3">Use <strong>Speaker Progress</strong> to pick who is speaking.</li>
        <li data-lang-key="quickStart4">Press <strong>Start</strong> (or Spacebar) to begin.</li>
        <li data-lang-key="quickStart5">Use <strong>Presenter Mode</strong> or <strong>Mirror Mode</strong> for your audience.</li>
      </ol>
      
      <h3 data-lang-key="headerIcons">Header Icons</h3>
      <ul>
        <li data-lang-key="helpIcon"><strong>Help (H):</strong> Shows this help window.</li>
        <li data-lang-key="themeIcon"><strong>Theme (D):</strong> Toggles between Light and Dark mode.</li>
        <li data-lang-key="presenterIcon"><strong>Presenter (P):</strong> Opens a clean, large timer-only display in a separate window. It mirrors all timer activity in real time. (Requires M-series iPad or Android DeX to extend display).</li>
        <li data-lang-key="mirrorIcon"><strong>Mirror Mode:</strong> Simplifies the main screen to show *only* the giant timer. This is for devices that can only mirror their display (like iPhones or older iPads). <strong>Click the speech title to exit Mirror Mode.</strong></li>
        <li data-lang-key="timersIcon"><strong>Quick Timers:</strong> Toggles the visibility of the four mini-timers (Cross-Ex, Rebuttal, Prep, POI). Icon shows a slash when hidden.</li>
        <li data-lang-key="notesIcon"><strong>Speaker Notes:</strong> Toggles the notes panel. Icon shows a slash when hidden. The button will invert its color (be "active") if the *current* speaker has notes.</li>
        <li data-lang-key="muteIcon"><strong>Mute (M):</strong> Toggles all bell sounds on or off.</li>
      </ul>
      
      <h3 data-lang-key="mainTimerTitle">Main Timer Controls</h3>
      <ul>
        <li data-lang-key="startPauseIcon"><strong>Start/Pause (Space):</strong> Toggles the main timer.</li>
        <li data-lang-key="resetIcon"><strong>Reset (R):</strong> Resets the current timer to its starting time.</li>
        <li data-lang-key="singleIcon"><strong>Single (1):</strong> Plays a single bell.</li>
        <li data-lang-key="doubleIcon"><strong>Double (2):</strong> Plays two bells, spaced by the "Bell Spacing" setting.</li>
        <li data-lang-key="contIcon"><strong>Cont.:</strong> Tests the continuous bell.</li>
        <li data-lang-key="stopIcon"><strong>Stop Bell:</strong> Stops the continuous bell *and* immediately ends any grace period.</li>
      </ul>
      
      <h3 data-lang-key="timerLogicTitle">Timer Logic</h3>
      <ul>
        <li data-lang-key="timerLogic1"><strong>Substantive:</strong> Uses "Main Time". Plays a single bell at "1st Bell" and "2nd Bell" times.</li>
        <li data-lang-key="timerLogic2"><strong>Reply/Rebuttal:</strong> Uses "Rebuttal Time". Plays a double bell at the end (no grace period).</li>
        <li data-lang-key="timerLogic3"><strong>Grace Period:</strong> When a "Substantive" speech hits 0:00, it plays a double bell and starts counting *up* for the "Grace Period" time.</li>
        <li data-lang-key="timerLogic4"><strong>Continuous Bell:</strong> If the grace period ends, a continuous bell will ring until "Stop Bell" is pressed.</li>
      </ul>
      
      <h3 data-Jlang-key="notesDataTitle">Notes & Data</h3>
      <ul>
        <li data-lang-key="notesData1">Notes are saved per-speaker, per-format (e.g., "AP - Prime Minister").</li>
        <li data-lang-key="notesData2">`<strong>Export Notes:</strong> Saves a ".txt" file of all your notes, organized by format and speaker.</li>
        <li data-lang-key="notesData3"><strong>Import Notes:</strong> Imports notes from a ".json" or ".txt" file and merges them with your current notes.</li>
        <li data-lang-key="notesData4"><strong>Clear All Notes:</strong> Deletes all notes from the app. This cannot be undone.</li>
        <li data-lang-key="notesData5"><strong>Export Settings:</strong> Saves a ".json" file of all your *timer settings* (for all formats) and your *custom speaker list*. This does NOT include notes.</li>
      </ul>
    </div>
  </div>
  
  <!-- Confirmation Modal -->
  <div id="confirmModal">
    <div class="card">
      <h3 id="confirmTitle" style="margin-top:0">Are you sure?</h3>
      <p id="confirmText">This action cannot be undone.</p>
      <div class="row" style="justify-content:flex-end; margin-top: 20px;">
        <button id="confirmCancel" class="btn">Cancel</button>
        <button id="confirmOK" class="btn" style="background:var(--bad-bg);color:var(--bad-fg);">OK</button>
      </div>
    </div>
  </div>

<script>
// ---------- GLOBAL Utilities (for main + presenter) ----------
const $ = (s,o=document)=>o.querySelector(s);
const fmt=(ms)=>{ms=Math.max(0,Math.round(ms/1000));const m=Math.floor(ms/60),s=ms%60;return m+":"+(s<10?"0":"")+s};
function setDarkGlobal(on) { document.documentElement.classList.toggle('dark', on); }
function applyBodyState(state){
  document.body.classList.remove('state-warn','state-bad','state-grace');
  if(state) document.body.classList.add(state);
}

(function(){
  // --- FIX: Check for presenter mode *immediately* ---
  const isPresenter = new URLSearchParams(location.search).get('presenter')==='true';

  // --- NEW CSS-based mode toggle ---
  // This runs *before* any content is rendered, preventing FOUC
  if (isPresenter) {
    document.body.classList.add('presenter-mode');
  } else {
    document.body.classList.add('main-mode');
  }
  // --- End new toggle ---

  if(isPresenter){
    // Listen for sync messages
    const channel = new BroadcastChannel('debate_timer_sync_v1');
    channel.onmessage=(e)=>{
      if(!e||!e.data) return; const m=e.data;
      if(m.type==='state'){
        const pc=$('#pClock'); const pm=$('#pMeta');
        
        // Apply theme (using global function)
        setDarkGlobal(m.theme === 'dark');

        // Apply time and meta
        if(pc) pc.textContent = fmt(m.main.remain);
        if(pm) pm.textContent = m.meta||'';
        
        // Apply grace pulse
        document.body.classList.toggle('presenter-grace', m.inGrace);

        // Apply visual state (using global function)
        applyBodyState(m.state);
      }
    };
    return; // STOP script execution for presenter window
  }

  // ---------- Utilities ----------
  const $$ = (s,o=document)=>Array.from(o.querySelectorAll(s));
  const clamp=(n,a,b)=>Math.min(Math.max(n,a),b);
  const parseTime = t=>{const p=(t||'').trim().split(':'); if(p.length===1) return (+p[0]||0)*1000; const m=+p[0]||0,s=+p[1]||0; return (m*60+s)*1000};
  
  // ---------- Translations ----------
  const translations = {
    en: {
      debateTimerTitle: 'Debate Timer', debateStyle: 'Debate Style', help: 'Help', lightMode: 'Light Mode', darkMode: 'Dark Mode',
      presenterMode: 'Presenter Mode', mirrorMode: 'Mirror Mode', showQuickTimers: 'Show Quick Timers', hideQuickTimers: 'Hide Quick Timers',
      showNotes: 'Show Notes', hideNotes: 'Hide Notes', initSound: 'Initialize Sound', volume: 'Volume', lang: 'Lang',
      spkProgress: 'Speaker Progress', prev: 'Previous', next: 'Next', resetOrder: 'Reset Order',
      spkNote: 'Click = select • Double-click = toggle active • Drag = reorder',
      substantive: 'Substantive Speech', replyRebuttal: 'Reply/Rebuttal', grace: 'Grace', status: 'Status:',
      statusIdle: 'idle', statusRunning: 'running', statusPaused: 'paused', statusSoundReady: 'Sound ready.',
      statusSoundFail: 'Sound failed. Please refresh.', start: 'Start', pause: 'Pause', reset: 'Reset',
      single: 'Single', double: 'Double', cont: 'Cont.', stop: 'Stop',
      speakerNotes: 'Speaker Notes', notesPlaceholder: 'Type notes for the current speaker...',
      exportNotes: 'Export Notes', importNotes: 'Import Notes', clearAllNotes: 'Clear All Notes',
      crossEx: 'Cross-Ex / Shared', rebuttal: 'Rebuttal / Reply', prep: 'Prep', poi: 'POI',
      settingsTitle: 'Timer Settings', hide: 'Hide', show: 'Show', mainTime: 'Main (m:ss)',
      firstBell: '1st Bell from start (m:ss)', secondBell: '2nd Bell from start (m:ss)',
      yellowAt: 'Yellow at remaining (m:ss)', redAt: 'Red at remaining (m:ss)',
      gracePeriod: 'Grace Period (m:ss)', prepTime: 'Prep Time (m:ss)', crossExTime: 'Cross-Ex (m:ss)',
      rebuttalTime: 'Rebuttal (m:ss)', poiTime: 'POI Time (m:ss)', bellSpacing: 'Bell spacing (ms)',
      exportSettings: 'Export Settings', importSettings: 'Import Settings',
      helpTitle: 'Help', close: 'Close', quickStart: 'Quick Start',
      quickStart1: '<strong><u>Click <strong>Initialize Sound</strong> once.</u></strong> (Mobile browsers require a gesture to enable audio).',
      quickStart2: 'Select your <strong>Debate Style</strong> from the dropdown.',
      quickStart3: 'Use <strong>Speaker Progress</strong> to pick who is speaking.',
      quickStart4: 'Press <strong>Start</strong> (or Spacebar) to begin.',
      quickStart5: 'Use <strong>Presenter Mode</strong> or <strong>Mirror Mode</strong> for your audience.',
      headerIcons: 'Header Icons',
      helpIcon: '<strong>Help (H):</strong> Shows this help window.',
      themeIcon: '<strong>Theme (D):</strong> Toggles between Light and Dark mode.',
      presenterIcon: '<strong>Presenter (P):</strong> Opens a clean, large timer-only display in a separate window. It mirrors all timer activity in real time. (Requires M-series iPad or Android DeX to extend display).',
      mirrorIcon: '<strong>Mirror Mode:</strong> Simplifies the main screen to show *only* the giant timer. This is for devices that can only mirror their display (like iPhones or older iPads). <strong>Click the speech title to exit Mirror Mode.</strong>',
      timersIcon: '<strong>Quick Timers:</strong> Toggles the visibility of the four mini-timers (Cross-Ex, Rebuttal, Prep, POI). Icon shows a slash when hidden.',
      notesIcon: '<strong>Speaker Notes:</strong> Toggles the notes panel. Icon shows a slash when hidden. The button will invert its color (be "active") if the *current* speaker has notes.',
      muteIcon: '<strong>Mute (M):</strong> Toggles all bell sounds on or off.',
      mainTimerTitle: 'Main Timer Controls',
      startPauseIcon: '<strong>Start/Pause (Space):</strong> Toggles the main timer.',
      resetIcon: '<strong>Reset (R):</strong> Resets the current timer to its starting time.',
      singleIcon: '<strong>Single (1):</strong> Plays a single bell.',
      doubleIcon: '<strong>Double (2):</strong> Plays two bells, spaced by the "Bell Spacing" setting.',
      contIcon: '<strong>Cont.:</strong> Tests the continuous bell.',
      stopIcon: '<strong>Stop Bell:</strong> Stops the continuous bell *and* immediately ends any grace period.',
      timerLogicTitle: 'Timer Logic',
      timerLogic1: '<strong>Substantive:</strong> Uses "Main Time". Plays a single bell at "1st Bell" and "2nd Bell" times.',
      timerLogic2: '<strong>Reply/Rebuttal:</strong> Uses "Rebuttal Time". Plays a double bell at the end (no grace period).',
      timerLogic3: '<strong>Grace Period:</strong> When a "Substantive" speech hits 0:00, it plays a double bell and starts counting *up* for the "Grace Period" time.',
      timerLogic4: '<strong>Continuous Bell:</strong> If the grace period ends, a continuous bell will ring until "Stop Bell" is pressed.',
      notesDataTitle: 'Notes & Data',
      notesData1: 'Notes are saved per-speaker, per-format (e.g., "AP - Prime Minister").',
      notesData2: '<strong>Export Notes:</strong> Saves a ".txt" file of all your notes, organized by format and speaker.',
      notesData3: '<strong>Import Notes:</strong> Imports notes from a ".json" or ".txt" file and merges them with your current notes.',
      notesData4: '<strong>Clear All Notes:</strong> Deletes all notes from the app. This cannot be undone.',
      notesData5: '<strong>Export Settings:</strong> Saves a ".json" file of all your *timer settings* (for all formats) and your *custom speaker list*. This does NOT include notes.',
      roundPrep: 'Round Prep', prepFor: 'Prep for',
      titleMute: 'Mute (M)', titleStart: 'Start/Pause (Space)', titleReset: 'Reset (R)', titleSingle: 'Single Bell (1)',
      titleDouble: 'Double Bell (2)', titleTestCont: 'Start continuous bell test', titleStopBell: 'Stop continuous bell',
      titleHelp: 'Help (H)', titleTheme: 'Toggle Dark Mode (D)', titlePresenter: 'Presenter Mode (P)', titleMirror: 'Mirror Mode',
      titleQuickTimers: 'Toggle Quick Timers', titleNotes: 'Toggle Speaker Notes',
      confirmClear: 'Clear All Notes?', confirmClearText: 'Are you sure you want to delete all speaker notes? This cannot be undone.',
      confirmOK: 'OK', confirmCancel: 'Cancel'
    },
    ko: {
      debateTimerTitle: '토론 타이머', debateStyle: '토론 방식', help: '도움말', lightMode: '라이트 모드', darkMode: '다크 모드',
      presenterMode: '발표자 모드', mirrorMode: '미러 모드', showQuickTimers: '빠른 타이머 표시', hideQuickTimers: '빠른 타이머 숨기기',
      showNotes: '메모 보이기', hideNotes: '메모 숨기기', initSound: '소리 초기화', volume: '볼륨', lang: '언어',
      spkProgress: '발표자 진행', prev: '이전', next: '다음', resetOrder: '순서 초기화',
      spkNote: '클릭 = 선택 • 더블 클릭 = 활성/비활성 • 드래그 = 순서 변경',
      substantive: '입론', replyRebuttal: '답변/반박', grace: '유예', status: '상태:',
      statusIdle: '대기 중', statusRunning: '실행 중', statusPaused: '일시정지', statusSoundReady: '소리 준비 완료.',
      statusSoundFail: '소리 초기화 실패. 새로고침하세요.', start: '시작', pause: '일시정지', reset: '초기화',
      single: '싱글', double: '더블', cont: '연속', stop: '정지',
      speakerNotes: '발표자 메모', notesPlaceholder: '현재 발표자/다음 준비를 위한 메모 입력...',
      exportNotes: '메모 내보내기', importNotes: '메모 가져오기', clearAllNotes: '모든 메모 지우기',
      crossEx: '교차조사 / 공유', rebuttal: '반박 / 답변', prep: '준비', poi: 'POI',
      settingsTitle: '타이머 설정', hide: '숨기기', show: '보이기', mainTime: '주요 (m:ss)',
      firstBell: '첫 번째 벨 (시작부터 m:ss)', secondBell: '두 번째 벨 (시작부터 m:ss)',
      yellowAt: '노란색 (남은 시간 m:ss)', redAt: '빨간색 (남은 시간 m:ss)',
      gracePeriod: '유예 시간 (m:ss)', prepTime: '준비 시간 (m:ss)', crossExTime: '교차조사 (m:ss)',
      rebuttalTime: '반박 (m:ss)', poiTime: 'POI 시간 (m:ss)', bellSpacing: '벨 간격 (ms)',
      exportSettings: '설정 내보내기', importSettings: '설정 가져오기',
      helpTitle: '도움말', close: '닫기', quickStart: '빠른 시작',
      quickStart1: '<strong><u><strong>소리 초기화</strong>를 한 번 클릭하세요.</u></strong> (모바일 브라우저).',
      quickStart2: '<strong>토론 방식</strong> 드롭다운에서 방식을 선택하세요.',
      quickStart3: '<strong>발표자 진행</strong>을 사용해 현재 발표자를 선택하세요.',
      quickStart4: '<strong>시작</strong> (또는 스페이스바)을 눌러 시작하세요.',
      quickStart5: '청중을 위해 <strong>발표자 모드</strong> 또는 <strong>미러 모드</strong>를 사용하세요.',
      headerIcons: '헤더 아이콘',
      helpIcon: '<strong>도움말 (H):</strong> 이 도움말 창을 엽니다.',
      themeIcon: '<strong>테마 (D):</strong> 라이트/다크 모드를 전환합니다.',
      presenterIcon: '<strong>발표자 (P):</strong> 별도 창에 크고 깔끔한 타이머 전용 디스플레이를 엽니다. 모든 타이머 활동이 실시간으로 동기화됩니다. (M-시리즈 iPad 또는 Android DeX 필요).',
      mirrorIcon: '<strong>미러 모드:</strong> 메인 화면을 타이머만 표시하도록 단순화합니다. (iPhone 또는 구형 iPad처럼) 화면 미러링만 가능한 기기용입니다. <strong>미러 모드를 종료하려면 발표 제목을 클릭하세요.</strong>',
      timersIcon: '<strong>빠른 타이머:</strong> 4개의 미니 타이머(교차조사, 반박, 준비, POI)의 표시 여부를 전환합니다. 숨겨져 있을 땐 아이콘에 슬래시가 표시됩니다.',
      notesIcon: '<strong>발표자 메모:</strong> 메모 패널의 표시 여부를 전환합니다. 숨겨져 있을 땐 아이콘에 슬래시가 표시됩니다. 현재 발표자에게 메모가 있으면 버튼이 반전되어 "활성" 상태로 표시됩니다.',
      muteIcon: '<strong>음소거 (M):</strong> 모든 벨 소리를 켜거나 끕니다.',
      mainTimerTitle: '메인 타이머 컨트롤',
      startPauseIcon: '<strong>시작/일시정지 (Space):</strong> 메인 타이머를 토글합니다.',
      resetIcon: '<strong>초기화 (R):</strong> 현재 타이머를 시작 시간으로 초기화합니다.',
      singleIcon: '<strong>싱글 (1):</strong> 싱글 벨을 울립니다.',
      doubleIcon: '<strong>더블 (2):</strong> "벨 간격" 설정에 따라 두 번의 벨을 울립니다.',
      contIcon: '<strong>연속:</strong> 연속 벨을 테스트합니다.',
      stopIcon: '<strong>벨 정지:</strong> 연속 벨을 멈추고 *모든* 유예 시간을 즉시 종료합니다.',
      timerLogicTitle: '타이머 로직',
      timerLogic1: '<strong>입론:</strong> "주요 시간"을 사용합니다. "1차 벨"과 "2차 벨" 시간에 싱글 벨을 울립니다.',
      timerLogic2: '<strong>답변/반박:</strong> "반박 시간"을 사용합니다. 종료 시 더블 벨을 울립니다 (유예 시간 없음).',
      timerLogic3: '<strong>유예 시간:</strong> "입론"이 0:00에 도달하면, 더블 벨을 울리고 "유예 시간"만큼 카운트 *업*을 시작합니다.',
      timerLogic4: '<strong>연속 벨:</strong> 유예 시간이 끝나면, "벨 정지"를 누를 때까지 연속 벨이 울립니다.',
      notesDataTitle: '메모 & 데이터',
      notesData1: '메모는 토론 방식 및 발표자별로 저장됩니다 (예: "AP - 총리").',
      notesData2: '<strong>메모 내보내기:</strong> 모든 메모를 방식과 발표자별로 정리된 ".txt" 파일로 저장합니다.',
      notesData3: '<strong>메모 가져오기:</strong> ".json" 또는 ".txt" 파일에서 메모를 가져와 현재 메모와 병합합니다.',
      notesData4: '<strong>모든 메모 지우기:</strong> 앱의 모든 메모를 삭제합니다. 이 작업은 취소할 수 없습니다.',
      notesData5: '<strong>설정 내보내기:</strong> 모든 *타이머 설정* (모든 방식 포함)과 *커스텀 발표자 목록*을 ".json" 파일로 저장합니다. 메모는 포함되지 않습니다.',
      roundPrep: '라운드 준비', prepFor: '준비 (다음)',
      titleMute: '음소거 (M)', titleStart: '시작/일시정지 (Space)', titleReset: '초기화 (R)', titleSingle: '싱글 벨 (1)',
      titleDouble: '더블 벨 (2)', titleTestCont: '연속 벨 테스트', titleStopBell: '벨 멈춤',
      titleHelp: '도움말 (H)', titleTheme: '다크 모드 전환 (D)', titlePresenter: '발표자 모드 (P)', titleMirror: '미러 모드',
      titleQuickTimers: '빠른 타이머 토글', titleNotes: '발표자 메모 토글',
      confirmClear: '모든 메모 지우기?', confirmClearText: '정말로 모든 발표자 메모를 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.',
      confirmOK: '확인', confirmCancel: '취소'
    }
  };
  let currentLang = translations.en;
  const langSelect = $('#langSelect');

  // ---------- DOM Elements ----------
  // Header
  const formatSelect = $('#formatSelect');
  const volume = $('#volume');
  const helpBtn = $('#helpBtn'), themeBtn = $('#themeBtn'), presenterBtn = $('#presenterBtn'),
        mirrorBtn = $('#mirrorBtn'), toggleQuickTimers = $('#toggleQuickTimers'),
        toggleNotesBtn = $('#toggleNotesBtn'), enableBtn = $('#enableBtn'), muteBtn = $('#muteBtn');
  // Modals
  const helpModal = $('#helpModal'), closeHelp = $('#closeHelp');
  const confirmModal = $('#confirmModal'), confirmTitle = $('#confirmTitle'), confirmText = $('#confirmText'),
        confirmCancel = $('#confirmCancel'), confirmOK = $('#confirmOK');
  // Speaker Progress
  const spkBar = $('#spkBar'), prevBtn = $('#prevBtn'), nextBtn = $('#nextBtn'), resetOrder = $('#resetOrder');
  // Main Timer
  const mainCard = $('#mainCard'), titleEl = $('#mainTitle'), metaEl = $('#meta'),
        clock = $('#clock'), mainProgress = $('#mainProgress'), fill = $('#fill'), statusEl = $('#status');
  const startBtn = $('#startBtn'), resetBtn = $('#resetBtn'), singleBtn = $('#singleBtn'),
        doubleBtn = $('#doubleBtn'), testContBtn = $('#testContBtn'), stopBellBtn = $('#stopBellBtn');
  // Notes
  const notesPanel = $('#notesPanel'), notesArea = $('#notesArea'),
        exportNotesBtn = $('#exportNotesBtn'), importNotesBtn = $('#importNotesBtn'),
        clearNotesBtn = $('#clearNotesBtn'), importNotesFile = $('#importNotesFile');
  // Quick Timers
  const quickTimersPanel = $('#quickTimersPanel');
  // Settings
  const settingsPanel = $('#settingsPanel'), toggleSettings = $('#toggleSettings'),
        mainInput = $('#mainInput'), firstInput = $('#firstInput'), secondInput = $('#secondInput'),
        yellowInput = $('#yellowInput'), redInput = $('#redInput'), graceInput = $('#graceInput'),
        prepInput = $('#prepInput'), cexInput = $('#cexInput'), rebInput = $('#rebInput'),
        poiInput = $('#poiInput'), spaceInput = $('#spaceInput');
  const exportBtn = $('#exportBtn'), importBtn = $('#importBtn'), importFile = $('#importFile');

  // ---------- Audio ----------
  let audioCtx=null, unlocked=false, masterGain=null, muted=false; let contBellInterval=null;
  async function initAudio(){
    try{
      audioCtx = new (window.AudioContext||window.webkitContext)();
      masterGain = audioCtx.createGain(); masterGain.gain.value = +volume.value; masterGain.connect(audioCtx.destination);
      unlocked=true; setStatus('statusSoundReady');
    }catch(e){ setStatus('statusSoundFail'); }
  }
  volume.oninput=()=>{ if(masterGain) masterGain.gain.value = +volume.value };
  function ding({type='single'}={}){
    if(!unlocked||!audioCtx) return;
    const now=audioCtx.currentTime;
    const osc=audioCtx.createOscillator();
    const osc2=audioCtx.createOscillator();
    const gain=audioCtx.createGain();
    const base=880; // A5
    osc.type='sine'; osc.frequency.setValueAtTime(base,now);
    osc2.type='sine'; osc2.frequency.setValueAtTime(base*1.5,now);
    gain.gain.setValueAtTime(muted?0:0.4,now);
    gain.gain.exponentialRampToValueAtTime(muted?0:0.0001, now+0.8);
    osc.connect(gain); osc2.connect(gain); gain.connect(masterGain);
    osc.start(now); osc2.start(now); osc.stop(now+0.9); osc2.stop(now+0.9);
  }
  function stopContinuous(){ if(contBellInterval){ clearInterval(contBellInterval); contBellInterval=null } }

  // ---------- Theme ----------
  const setDark = (on)=>{
    document.documentElement.classList.toggle('dark',on); 
    localStorage.setItem('debateTheme', on? 'dark':'light'); 
    themeBtn.classList.toggle('active', on);
    updateButtonStates(); // Update tooltips
  };
  
  // ---------- Help/Confirm Modals ----------
  helpBtn.onclick = () => helpModal.style.display = 'flex';
  closeHelp.onclick = () => helpModal.style.display = 'none';
  
  let confirmCallback = null;
  function showConfirm({ title, text, okText, callback }) {
    confirmTitle.textContent = title;
    confirmText.textContent = text;
    confirmOK.textContent = okText;
    confirmCallback = callback;
    confirmModal.style.display = 'flex';
  }
  confirmCancel.onclick = () => {
    confirmCallback = null;
    confirmModal.style.display = 'none';
  };
  confirmOK.onclick = () => {
    if (confirmCallback) confirmCallback();
    confirmCallback = null;
    confirmModal.style.display = 'none';
  };

  // ---------- Presenter Mode ----------
  const channel = new BroadcastChannel('debate_timer_sync_v1');
  let presenterWin=null;
  presenterBtn.onclick=()=>{
    if(!presenterWin || presenterWin.closed){
      presenterWin = window.open(window.location.pathname+'?presenter=true', 'presenter', 'width=1000,height=700');
      if(presenterWin){ presenterWin.focus(); setTimeout(()=>syncOut(true),150); }
    }else{ presenterWin.focus(); }
  };
  
  // ---------- Mirror Mode ----------
  mirrorBtn.onclick = () => {
    const on = document.body.classList.toggle('mirror-mode');
    mirrorBtn.classList.toggle('active', on);
  };
  titleEl.onclick = () => {
    document.body.classList.remove('mirror-mode');
    mirrorBtn.classList.remove('active');
  };

  // ---------- Sync Function ----------
  function syncOut(full=false){
    const left = mainRemain;
    const warn = left <= yellow && left > red && mode==='main' && !inGrace;
    const bad = left <= red && left > 0 && mode==='main' && !inGrace;
    let bodyState = null;
    let metaText = (titleEl?.textContent||'') + (metaEl.textContent? ' — '+metaEl.textContent : '');
    let remainTime = mainRemain;

    if(inGrace) {
      bodyState = 'state-grace';
      remainTime = graceRemain; 
      
      const s = speakers[activeIdx];
      const role = s ? (s[currentLang.role_key] || s.role_en || '') : '';
      metaText = `${role} — ${currentLang.grace}`; 
    }
    else if(bad) bodyState = 'state-bad';
    else if(warn) bodyState = 'state-warn';

    const payload={
      type:'state', 
      full, 
      main:{remain: remainTime, total:mainTotal, running:mainRunning}, 
      meta: metaText, 
      inGrace,
      state: bodyState,
      theme: document.documentElement.classList.contains('dark') ? 'dark' : 'light'
    };
    channel.postMessage(payload);
  }
  
  // ---------- Presets (base) ----------
  const PRESETS = {
    SIMSON: {
      label: 'Simson',
      base: [
        {role_en:'PM', role_ko:'총리 (PM)', side:'prop', initials:'PM'},
        {role_en:'LO', role_ko:'야당대표 (LO)', side:'opp', initials:'LO'},
        {role_en:'DPM', role_ko:'부총리 (DPM)', side:'prop', initials:'DPM'},
        {role_en:'DLO', role_ko:'야당부대표 (DLO)', side:'opp', initials:'DLO'},
        {role_en:'GW', role_ko:'여당 원내총무 (GW)', side:'prop', initials:'GW'},
        {role_en:'OW', role_ko:'야당 원내총무 (OW)', side:'opp', initials:'OW'},
        {role_en:'GR', role_ko:'여당 답변 (GR)', side:'prop', initials:'GR'},
        {role_en:'OR', role_ko:'야당 답변 (OR)', side:'opp', initials:'OR'}
      ],
      settings: { main:'3:00', first:'1:00', second:'2:00', yellow:'1:00', red:'0:30', grace:'0:30', prep:'1:00', cex:'1:00', reb:'3:00', poi: '0:15', spacing:'250', roundPrep:'20:00' }
    },
    AP: {
      label: 'Asian Parliamentary',
      base: [
        {role_en:'Prime Minister', role_ko:'총리', side:'prop', initials:'PM'},
        {role_en:'Leader of Opposition', role_ko:'야당대표', side:'opp', initials:'LO'},
        {role_en:'Deputy Prime Minister', role_ko:'부총리', side:'prop', initials:'DPM'},
        {role_en:'Deputy Leader of Opposition', role_ko:'야당부대표', side:'opp', initials:'DLO'},
        {role_en:'Government Whip', role_ko:'여당 원내총무', side:'prop', initials:'GW'},
        {role_en:'Opposition Whip', role_ko:'야당 원내총무', side:'opp', initials:'OW'},
        {role_en:'Opposition Reply', role_ko:'야당 답변', side:'opp', initials:'OR'},
        {role_en:'Government Reply', role_ko:'여당 답변', side:'prop', initials:'GR'}
      ],
      settings: { main:'7:00', first:'1:00', second:'6:00', yellow:'1:00', red:'0:30', grace:'0:30', prep:'30:00', cex:'1:00', reb:'4:00', poi: '0:15', spacing:'250', roundPrep:'00:00' }
    },
    BP: {
      label: 'British Parliamentary',
      base: [
        {role_en:'Prime Minister', role_ko:'총리', side:'prop', initials:'PM'},
        {role_en:'Leader of Opposition', role_ko:'야당대표', side:'opp', initials:'LO'},
        {role_en:'Deputy Prime Minister', role_ko:'부총리', side:'prop', initials:'DPM'},
        {role_en:'Deputy Leader of Opposition', role_ko:'야당부대표', side:'opp', initials:'DLO'},
        {role_en:'Member of Government', role_ko:'여당 의원', side:'prop', initials:'MG'},
        {role_en:'Member of Opposition', role_ko:'야당 의원', side:'opp', initials:'MO'},
        {role_en:'Government Whip', role_ko:'여당 원내총무', side:'prop', initials:'GW'},
        {role_en:'Opposition Whip', role_ko:'야당 원내총무', side:'opp', initials:'OW'},
        {role_en:'Opposition Reply', role_ko:'야당 답변', side:'opp', initials:'OR'},
        {role_en:'Government Reply', role_ko:'여당 답변', side:'prop', initials:'GR'}
      ],
      settings: { main:'7:00', first:'1:00', second:'6:00', yellow:'1:00', red:'0:30', grace:'0:30', prep:'0:00', cex:'1:00', reb:'4:00', poi: '0:15', spacing:'250', roundPrep:'15:00' }
    },
    WSDC: {
      label: 'WSDC',
      base: [
        {role_en:'1st Prop', role_ko:'1번 찬성', side:'prop', initials:'P1'},
        {role_en:'1st Opp', role_ko:'1번 반대', side:'opp', initials:'O1'},
        {role_en:'2nd Prop', role_ko:'2번 찬성', side:'prop', initials:'P2'},
        {role_en:'2nd Opp', role_ko:'2번 반대', side:'opp', initials:'O2'},
        {role_en:'3rd Prop', role_ko:'3번 찬성', side:'prop', initials:'P3'},
        {role_en:'3rd Opp', role_ko:'3번 반대', side:'opp', initials:'O3'},
        {role_en:'Opp Reply', role_ko:'반대 답변', side:'opp', initials:'OR'},
        {role_en:'Prop Reply', role_ko:'찬성 답변', side:'prop', initials:'PR'}
      ],
      settings: { main:'8:00', first:'1:00', second:'7:00', yellow:'1:00', red:'0:30', grace:'0:30', prep:'0:00', cex:'1:00', reb:'4:00', poi: '0:15', spacing:'250', roundPrep:'00:00' }
    },
    PF: {
      label: 'Public Forum',
      base: [
        {role_en:'Speaker 1 (Team A)', role_ko:'발표자 1 (A팀)', side:'prop', initials:'A1'},
        {role_en:'Speaker 2 (Team B)', role_ko:'발표자 2 (B팀)', side:'opp', initials:'B1'},
        {role_en:'Crossfire (1 & 2)', role_ko:'교차조사 (1 & 2)', side:'neutral', initials:'C1-2'},
        {role_en:'Speaker 3 (Team A)', role_ko:'발표자 3 (A팀)', side:'prop', initials:'A2'},
        {role_en:'Speaker 4 (Team B)', role_ko:'발표자 4 (B팀)', side:'opp', initials:'B2'},
        {role_en:'Crossfire (3 & 4)', role_ko:'교차조사 (3 & 4)', side:'neutral', initials:'C3-4'},
        {role_en:'Summary 1 (Team A)', role_ko:'요약 1 (A팀)', side:'prop', initials:'AS'},
        {role_en:'Summary 2 (Team B)', role_ko:'요약 2 (B팀)', side:'opp', initials:'BS'},
        {role_en:'Grand Crossfire', role_ko:'전체 교차조사', side:'neutral', initials:'GC'},
        {role_en:'Final Focus 1 (A)', role_ko:'최종 1 (A팀)', side:'prop', initials:'AFF'},
        {role_en:'Final Focus 2 (B)', role_ko:'최종 2 (B팀)', side:'opp', initials:'BFF'}
      ],
      settings: { main:'4:00', first:'1:00', second:'3:00', yellow:'1:00', red:'0:30', grace:'0:30', prep:'0:00', cex:'3:00', reb:'2:00', poi: '0:15', spacing:'250', roundPrep:'00:00' }
    },
    CX: {
      label: 'Policy / CX',
      base: [
        {role_en:'1st Aff Constructive', role_ko:'1차 긍정 입론', side:'prop', initials:'1AC'},
        {role_en:'Cross-Ex (by 2NC)', role_ko:'교차조사 (2NC)', side:'opp', initials:'CX'},
        {role_en:'1st Neg Constructive', role_ko:'1차 부정 입론', side:'opp', initials:'1NC'},
        {role_en:'Cross-Ex (by 1AC)', role_ko:'교차조사 (1AC)', side:'prop', initials:'CX'},
        {role_en:'2nd Aff Constructive', role_ko:'2차 긍정 입론', side:'prop', initials:'2AC'},
        {role_en:'Cross-Ex (by 1NC)', role_ko:'교차조사 (1NC)', side:'opp', initials:'CX'},
        {role_en:'2nd Neg Constructive', role_ko:'2차 부정 입론', side:'opp', initials:'2NC'},
        {role_en:'Cross-Ex (by 2AC)', role_ko:'교차조사 (2AC)', side:'prop', initials:'CX'},
        {role_en:'1st Neg Rebuttal', role_ko:'1차 부정 반박', side:'opp', initials:'1NR'},
        {role_en:'1st Aff Rebuttal', role_ko:'1차 긍정 반박', side:'prop', initials:'1AR'},
        {role_en:'2nd Neg Rebuttal', role_ko:'2차 부정 반박', side:'opp', initials:'2NR'},
        {role_en:'2nd Aff Rebuttal', role_ko:'2차 긍정 반박', side:'prop', initials:'2AR'}
      ],
      settings: { main:'8:00', first:'1:00', second:'7:00', yellow:'1:00', red:'0:30', grace:'0:30', prep:'0:00', cex:'3:00', reb:'5:00', poi: '0:15', spacing:'250', roundPrep:'00:00' }
    },
    LD: {
      label: 'Lincoln–Douglas',
      base: [
        {role_en:'Aff Constructive', role_ko:'긍정 입론', side:'prop', initials:'AC'},
        {role_en:'Cross-Ex', role_ko:'교차조사', side:'opp', initials:'CX'},
        {role_en:'Neg Constructive', role_ko:'부정 입론', side:'opp', initials:'NC'},
        {role_en:'Cross-Ex', role_ko:'교차조사', side:'prop', initials:'CX'},
        {role_en:'1st Aff Rebuttal', role_ko:'1차 긍정 반박', side:'prop', initials:'1AR'},
        {role_en:'Neg Rebuttal', role_ko:'부정 반박', side:'opp', initials:'NR'},
        {role_en:'2nd Aff Rebuttal', role_ko:'2차 긍정 반박', side:'prop', initials:'2AR'}
      ],
      settings: { main:'6:00', first:'1:00', second:'5:00', yellow:'1:00', red:'0:30', grace:'0:30', prep:'0:00', cex:'3:00', reb:'4:00', poi: '0:15', spacing:'250', roundPrep:'00:00' }
    },
    CUSTOM: {
      label: 'Custom',
      base: [],
      settings: {}
    }
  };

  // ---------- Runtime state ----------
  let speakers = [];       // full sequence including prep tokens
  let baseSpeakers = [];   // just the speakers, for dragging
  let activeIdx = 0;
  let currentPresetId = 'SIMSON';
  let currentSettings = {};
  
  let mode = 'main'; // main, grace
  let mainRunning = false, mainStart = 0, mainTotal = 0, mainRemain = 0;
  let firstBell=0, secondBell=0, yellow=0, red=0, grace=0, spacing=0;
  let graceRunning = false, graceStart = 0, graceRemain = 0;
  let inGrace = false;
  let firstTrigger=false, secondTrigger=false;
  
  let isDragging = false;
  
  // ---------- Main Timer ----------
  function tick(){
    if(mainRunning){
      mainRemain = mainTotal - (Date.now()-mainStart);
      if(mainRemain <= 0 && !inGrace){
        mainRemain=0;
        triggerEndOfSpeech();
      }
      if(!inGrace){
        if(!firstTrigger && mainTotal-mainRemain >= firstBell && firstBell>0){ firstTrigger=true; ding(); }
        if(!secondTrigger && mainTotal-mainRemain >= secondBell && secondBell>0){ secondTrigger=true; ding(); }
      }
    }
    if(inGrace){
      graceRemain = Date.now()-graceStart;
      if(graceRemain > grace){
        graceRemain = grace;
        if(!contBellInterval) contBellInterval = setInterval(ding, spacing);
      }
    }
    if(mainRunning || inGrace) requestAnimationFrame(tick);
    render();
    syncOut();
  }
  function triggerEndOfSpeech(){
    mainRunning=false;
    if(mode==='main' && grace>0){
      inGrace=true; graceStart=Date.now(); graceRemain=0;
      ding({type:'double'});
      setTimeout(ding, spacing); // Spaced double bell
      requestAnimationFrame(tick);
    }else if(mode==='main'){
      ding({type:'double'});
      setTimeout(ding, spacing);
    }
    // 'reb' mode just ends
  }
  function startMain(){
    if(mainRunning || mainRemain <= 0) return;
    mainRunning=true;
    mainStart=Date.now() - (mainTotal-mainRemain);
    setStatus('statusRunning');
    requestAnimationFrame(tick);
  }
  function pauseMain(){
    mainRunning=false;
    if(inGrace) inGrace=false; // pause kills grace
    setStatus('statusPaused');
  }
  function resetMain(){
    mainRunning=false; inGrace=false;
    mainRemain=mainTotal;
    firstTrigger=false; secondTrigger=false;
    stopContinuous();
    setStatus('statusIdle');
    applyBodyState(null); // FIX: Reset color on change/reset
  }
  function scrubTo(pc){
    mainTotal = mainTotal || 1; // prevent div by 0
    mainRemain = mainTotal * (1 - pc);
    mainStart = Date.now() - (mainTotal - mainRemain);
    if(mainRunning) pauseMain();
    if(inGrace) { inGrace = false; stopContinuous(); }
    
    // Check bell triggers
    firstTrigger = (mainTotal-mainRemain >= firstBell && firstBell>0);
    secondTrigger = (mainTotal-mainRemain >= secondBell && secondBell>0);
    
    // FIX: Update colors on scrub
    render();
    syncOut();
  }
  
  // ---------- Quick Timers ----------
  function createQuickTimer(clockEl, fillEl, startBtn, resetBtn, totalMs) {
    let running = false, startTime = 0, remain = totalMs;
    const update = () => {
      if(running){
        remain = totalMs - (Date.now() - startTime);
        if(remain <= 0){
          remain = 0; running = false;
          ding({type:'double'});
          setTimeout(ding, spacing);
          startBtn.textContent = currentLang.start;
        }
        requestAnimationFrame(update);
      }
      clockEl.textContent = fmt(remain);
      fillEl.style.transform = `scaleX(${(totalMs - remain) / (totalMs || 1)})`;
    };
    startBtn.onclick = () => {
      if(running){
        running = false;
        startBtn.textContent = currentLang.start;
      } else {
        running = true;
        startTime = Date.now() - (totalMs - remain);
        startBtn.textContent = currentLang.pause;
        requestAnimationFrame(update);
      }
    };
    resetBtn.onclick = () => {
      running = false;
      remain = totalMs;
      startBtn.textContent = currentLang.start;
      update();
    };
    // Initial render
    clockEl.textContent = fmt(remain);
    fillEl.style.transform = 'scaleX(0)';
    // Return a function to update totalMs
    return (newTotal) => {
      totalMs = newTotal;
      if (!running) {
        remain = totalMs;
        clockEl.textContent = fmt(remain);
        fillEl.style.transform = 'scaleX(0)';
      }
    };
  }
  
  let updateCex, updateReb, updatePrep, updatePoi;

  // ---------- Speaker Progress & Data ----------
  function buildSequence(base, settings){
    speakers = [];
    baseSpeakers = JSON.parse(JSON.stringify(base)); // deep copy
    const prepTime = parseTime(settings.prep);
    const roundPrepTime = parseTime(settings.roundPrep);
    
    if(roundPrepTime > 0){
      speakers.push({type:'prep', time:roundPrepTime, role_en:`Round Prep`, role_ko:`라운드 준비`, side:'prep', initials:'P'});
    }
    
    baseSpeakers.forEach((s,i)=>{
      // Add speaker
      s.type = (s.role_en.includes('Reply') || s.role_en.includes('Rebuttal') || s.role_en.includes('Final Focus')) ? 'reb' : 'main';
      s.time = (s.type==='reb') ? parseTime(settings.reb) : parseTime(settings.main);
      s.first = parseTime(settings.first); s.second = parseTime(settings.second);
      s.yellow = parseTime(settings.yellow); s.red = parseTime(settings.red);
      s.grace = (s.type==='reb') ? 0 : parseTime(settings.grace);
      s.active = true; // FIX: Always enable on load
      speakers.push(s);
      
      // Add prep time *between* speakers (if > 0 and not WSDC/BP/AP/PF/CX/LD)
      const nonPrepFormats = ['WSDC', 'BP', 'AP', 'PF', 'CX', 'LD'];
      if(prepTime > 0 && i < baseSpeakers.length - 1 && !nonPrepFormats.includes(currentPresetId)){
        speakers.push({type:'prep', time:prepTime, role_en:`Prep for ${baseSpeakers[i+1].initials}`, role_ko:`준비 (${baseSpeakers[i+1].initials})`, side:'prep', initials:'P'});
      }
    });
  }
  function renderSpeakerProgress(){
    spkBar.innerHTML = '';
    speakers.forEach((s,i)=>{
      const el = document.createElement('div');
      el.className = `spk ${s.side || 'neutral'}`;
      el.classList.toggle('inactive', !s.active);
      el.classList.toggle('active', i === activeIdx);
      el.textContent = s[currentLang.role_key] || s.role_en;
      el.dataset.idx = i;
      el.onclick = ()=>setActive(i);
      el.ondblclick = ()=>{ s.active = !s.active; el.classList.toggle('inactive', !s.active) };
      spkBar.appendChild(el);
    });
  }
  
  // FIX: This function *must* be safe to call with an undefined speaker
  function setActive(idx) {
    activeIdx = idx;
    const s = speakers[activeIdx]; // Get the speaker (or undefined)

    // --- NEW SAFETY CHECK ---
    if (s) {
      // This is the code that was crashing
      const role = s[currentLang.role_key] || s.role_en;
      const type = s.type;
      
      let title = '';
      if(type === 'prep') title = currentLang.prep;
      else if(type === 'reb') title = currentLang.replyRebuttal;
      else title = currentLang.substantive;
      titleEl.textContent = title;
      metaEl.textContent = `— ${role}`;
      
      mode = (type==='reb') ? 'reb' : 'main';
      mainTotal = s.time;
      firstBell = s.first || 0; secondBell = s.second || 0;
      yellow = s.yellow || 0; red = s.red || 0;
      grace = s.grace || 0;
      spacing = parseTime(spaceInput.value) || 250;

      // Update notes button state
      const note = getNoteForSpeaker(s);
      toggleNotesBtn.classList.toggle('active', !!note);
      
      // Load notes into text area
      if (isNotesOpen) {
        loadNotesForSpeaker(s);
      }

    } else {
      // No speaker selected (or array is empty)
      // This is the "safe" block
      mode = 'main';
      mainTotal = 0;
      mainRemain = 0;
      firstBell = 0;
      secondBell = 0;
      yellow = 0; red = 0; grace = 0;
      mainRunning = false;
      inGrace = false;

      titleEl.textContent = 'No Speaker';
      metaEl.textContent = '';
      
      // Update notes button state (no speaker = no notes)
      toggleNotesBtn.classList.toggle('active', false);
      if (isNotesOpen) {
        notesArea.value = '';
        notesArea.disabled = true;
      }
    }

    // These should run *outside* the if block, to render the cleared state
    toggleNotesBtn.classList.toggle('open', isNotesOpen);
    
    resetMain(); // This resets the timer/colors
    render(); // This renders the 0:00
    updateButtonStates();
    syncOut();
    
    // Update active class in speaker bar
    $$('.spk.active').forEach(el=>el.classList.remove('active'));
    const el = $(`[data-idx="${activeIdx}"]`);
    if(el) el.classList.add('active');
  }

  // ---------- Notes ----------
  let allNotes = {}; // formatKey_roleKey: "note text"
  let isNotesOpen = false;
  
  function getNoteKey(speaker) {
    if (!speaker || !speaker.role_en) return null;
    // Use role_en as the stable key, replacing spaces
    const roleKey = speaker.role_en.replace(/\s+/g, '_');
    return `${currentPresetId}_${roleKey}`;
  }
  
  function getNoteForSpeaker(speaker) {
    const key = getNoteKey(speaker);
    return key ? (allNotes[key] || "") : "";
  }
  
  function loadNotesForSpeaker(speaker) {
    const key = getNoteKey(speaker);
    if (key) {
      notesArea.value = allNotes[key] || "";
      notesArea.disabled = false;
      notesArea.setAttribute('placeholder', currentLang.notesPlaceholder);
    } else {
      // Not a speaker (e.g., prep timer)
      // Try to find *next* speaker
      const nextSpeaker = speakers[activeIdx + 1];
      if (nextSpeaker && nextSpeaker.type !== 'prep') {
        const nextKey = getNoteKey(nextSpeaker);
        notesArea.value = allNotes[nextKey] || "";
        notesArea.disabled = true;
        notesArea.setAttribute('placeholder', `${currentLang.prepFor} ${nextSpeaker[currentLang.role_key] || nextSpeaker.role_en}...`);
      } else {
        notesArea.value = "";
        notesArea.disabled = true;
        notesArea.setAttribute('placeholder', '');
      }
    }
  }
  
  function saveNote() {
    const s = speakers[activeIdx];
    const key = getNoteKey(s);
    if (key) {
      allNotes[key] = notesArea.value;
      // Update button state immediately
      toggleNotesBtn.classList.toggle('active', !!notesArea.value);
      // Save all notes to localStorage
      localStorage.setItem('debateNotes', JSON.stringify(allNotes));
    }
  }
  
  function exportNotesTxt() {
    let txt = `Debate Timer Notes - ${new Date().toLocaleString()}\n`;
    
    // Group by preset
    const grouped = {};
    for (const key in allNotes) {
      if (allNotes[key]) {
        const [preset, ...roleParts] = key.split('_');
        const role = roleParts.join(' ').replace(/_/g, ' '); // Recreate role_en
        if (!grouped[preset]) grouped[preset] = [];
        grouped[preset].push({ role, note: allNotes[key] });
      }
    }
    
    for (const presetId in grouped) {
      txt += `\n== ${presetId} ==\n`;
      for (const item of grouped[presetId]) {
        txt += `\n## ${item.role} ##\n${item.note}\n`;
      }
    }
    
    const blob = new Blob([txt], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'debate_notes.txt';
    a.click();
    URL.revokeObjectURL(url);
  }
  
  function importNotes(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        let importedNotes = {};
        if (file.type === 'application/json') {
          importedNotes = JSON.parse(e.target.result);
        } else {
          // Parse .txt format
          const txt = e.target.result;
          let currentPreset = '';
          let currentRole = '';
          const lines = txt.split('\n');
          for (const line of lines) {
            if (line.startsWith('== ') && line.endsWith(' ==')) {
              currentPreset = line.substring(3, line.length - 3).trim();
            } else if (line.startsWith('## ') && line.endsWith(' ##')) {
              currentRole = line.substring(3, line.length - 3).trim().replace(/\s+/g, '_');
            } else if (currentPreset && currentRole) {
              const key = `${currentPreset}_${currentRole}`;
              if (!importedNotes[key]) importedNotes[key] = '';
              importedNotes[key] += line + '\n';
            }
          }
          // Clean up trailing newlines
          for (const key in importedNotes) {
            importedNotes[key] = importedNotes[key].trim();
          }
        }
        
        // Merge with existing notes
        allNotes = { ...allNotes, ...importedNotes };
        localStorage.setItem('debateNotes', JSON.stringify(allNotes));
        // Reload notes for current speaker
        if(speakers[activeIdx]) loadNotesForSpeaker(speakers[activeIdx]);
        // Update button state
        toggleNotesBtn.classList.toggle('active', !!getNoteForSpeaker(speakers[activeIdx]));
      } catch (err) {
        console.error('Failed to import notes:', err);
      }
    };
    reader.readAsText(file);
  }
  
  function clearAllNotes() {
    showConfirm({
      title: currentLang.confirmClear,
      text: currentLang.confirmClearText,
      okText: currentLang.confirmOK,
      callback: () => {
        allNotes = {};
        localStorage.removeItem('debateNotes');
        if(speakers[activeIdx]) loadNotesForSpeaker(speakers[activeIdx]);
        toggleNotesBtn.classList.toggle('active', false);
      }
    });
  }
  
  // ---------- Settings / Presets ----------
  function loadPreset(id, importedSettings=null){
    let p, settings;
    if(id==='CUSTOM' && importedSettings){
      p = PRESETS.CUSTOM;
      p.base = importedSettings.base || [];
      settings = importedSettings.settings || {};
      PRESETS.CUSTOM.base = p.base;
      PRESETS.CUSTOM.settings = settings;
      localStorage.setItem('debateCustomPreset', JSON.stringify(PRESETS.CUSTOM));
    } else if (id==='CUSTOM') {
      p = JSON.parse(localStorage.getItem('debateCustomPreset')) || PRESETS.CUSTOM;
      if(!p.base) p.base = [];
      if(!p.settings) p.settings = PRESETS.SIMSON.settings; // Default
      PRESETS.CUSTOM = p; // Ensure it's in memory
      settings = p.settings;
    } else {
      p = PRESETS[id];
      settings = p.settings;
    }
    currentPresetId = id;
    currentSettings = settings;
    
    // Apply settings to inputs
    mainInput.value = settings.main;
    firstInput.value = settings.first;
    secondInput.value = settings.second;
    yellowInput.value = settings.yellow;
    redInput.value = settings.red;
    graceInput.value = settings.grace;
    prepInput.value = settings.prep;
    cexInput.value = settings.cex;
    rebInput.value = settings.reb;
    poiInput.value = settings.poi || '0:15';
    spaceInput.value = settings.spacing;
    
    // Update quick timers
    if(updateCex) updateCex(parseTime(settings.cex));
    if(updateReb) updateReb(parseTime(settings.reb));
    if(updatePrep) updatePrep(parseTime(settings.prep));
    if(updatePoi) updatePoi(parseTime(settings.poi || '0:15'));
    
    // Build speaker sequence
    buildSequence(p.base, settings);
    renderSpeakerProgress();
    
    // FIX: Only set active if there are speakers
    if (speakers.length > 0) {
      setActive(0);
    } else {
      setActive(-1); // This will clear the timer
    }
    
    localStorage.setItem('debateFormat', id);
  }
  
  function collectSettings() {
    return {
      main: mainInput.value, first: firstInput.value, second: secondInput.value,
      yellow: yellowInput.value, red: redInput.value, grace: graceInput.value,
      prep: prepInput.value, cex: cexInput.value, reb: rebInput.value,
      poi: poiInput.value, spacing: spaceInput.value,
      roundPrep: currentSettings.roundPrep || '0:00' // Preserve this
    };
  }
  
  function exportSettings() {
    const data = {
      base: (currentPresetId === 'CUSTOM') ? baseSpeakers : PRESETS[currentPresetId].base,
      settings: collectSettings()
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${currentPresetId}_settings.json`;
    a.click();
    URL.revokeObjectURL(url);
  }
  
  function importSettings(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = JSON.parse(e.target.result);
        if (data.base && data.settings) {
          loadPreset('CUSTOM', data);
          formatSelect.value = 'CUSTOM';
        }
      } catch (err) {
        console.error('Failed to import settings:', err);
      }
    };
    reader.readAsText(file);
  }
  
  // ---------- Render / Update ----------
  function render(){
    const left = mainRemain;
    const warn = left <= yellow && left > red && mode==='main' && !inGrace;
    const bad = left <= red && left > 0 && mode==='main' && !inGrace;
    
    if(inGrace){
      clock.textContent = fmt(graceRemain);
      fill.style.transform = `scaleX(${graceRemain / (grace || 1)})`;
    }else{
      clock.textContent = fmt(mainRemain);
      fill.style.transform = `scaleX(${(mainTotal - mainRemain) / (mainTotal || 1)})`;
    }
    
    // FIX: Reset color on change/reset
    if (!mainRunning && mainRemain === mainTotal) {
      applyBodyState(null);
    } else if(inGrace) {
      applyBodyState('state-grace');
    } else if(bad) {
      applyBodyState('state-bad');
    } else if(warn) {
      applyBodyState('state-warn');
    } else {
      applyBodyState(null);
    }
  }
  
  function setStatus(langKey){
    statusEl.textContent = currentLang[langKey] || langKey;
  }
  
  function updateButtonStates() {
    startBtn.classList.toggle('running', mainRunning);
    // Update text
    const startLabel = startBtn.querySelector('.label-text');
    if (startLabel) startLabel.textContent = mainRunning ? currentLang.pause : currentLang.start;
    
    // Update tooltips
    themeBtn.title = document.documentElement.classList.contains('dark') ? currentLang.lightMode : currentLang.darkMode;
    muteBtn.title = currentLang.titleMute;
    startBtn.title = currentLang.titleStart;
    resetBtn.title = currentLang.titleReset;
    singleBtn.title = currentLang.titleSingle;
    doubleBtn.title = currentLang.titleDouble;
    testContBtn.title = currentLang.titleTestCont;
    stopBellBtn.title = currentLang.titleStopBell;
    helpBtn.title = currentLang.titleHelp;
    presenterBtn.title = currentLang.titlePresenter;
    mirrorBtn.title = currentLang.titleMirror;
    toggleQuickTimers.title = isQuickTimersOpen ? currentLang.hideQuickTimers : currentLang.showQuickTimers;
    toggleNotesBtn.title = isNotesOpen ? currentLang.hideNotes : currentLang.showNotes;
  }
  
  let isSettingsOpen = true, isQuickTimersOpen = false;
  
  function togglePanel(panel, isOpen, btn, btnClass) {
    if (isOpen) {
      // FIX: Use hardcoded max-height to prevent clipping
      panel.style.maxHeight = '500px'; 
      panel.style.padding = '16px';
      panel.style.borderWidth = '1px';
      if(btn) btn.classList.add(btnClass || 'open');
    } else {
      panel.style.maxHeight = '0px';
      panel.style.padding = '0 16px';
      panel.style.borderWidth = '0px';
      if(btn) btn.classList.remove(btnClass || 'open');
    }
    return isOpen;
  }
  
  // ---------- Language ----------
  function setLang(lang){
    currentLang = translations[lang] || translations.en;
    currentLang.role_key = (lang === 'ko') ? 'role_ko' : 'role_en';
    
    $$('[data-lang-key]').forEach(el => {
      const key = el.dataset.langKey;
      if (currentLang[key]) {
        if(el.tagName === 'TEXTAREA' || el.tagName === 'INPUT') {
          if (el.placeholder) el.placeholder = currentLang[key];
        } else {
          el.innerHTML = currentLang[key]; // Use innerHTML for <strong> tags in help
        }
      }
    });
    
    // Update dynamic elements
    updateButtonStates();
    if (speakers.length > 0) {
      setActive(activeIdx); // Re-set active to update titles
      renderSpeakerProgress(); // Re-render speaker names
    }
  }
  function updateLang(lang){
    langSelect.value = lang;
    setLang(lang);
    localStorage.setItem('debateLang', lang);
  }

  // ---------- Event Listeners ----------
  // Main timer
  startBtn.onclick = ()=>{ if(mainRunning) pauseMain(); else startMain() };
  resetBtn.onclick = ()=>{ resetMain(); render(); syncOut() };
  singleBtn.onclick = ding;
  doubleBtn.onclick = ()=>{ ding({type:'double'}); setTimeout(ding, spacing) };
  testContBtn.onclick = ()=>{ if(!contBellInterval) contBellInterval = setInterval(ding, spacing) };
  stopBellBtn.onclick = ()=>{ 
    stopContinuous();
    if(inGrace){
      inGrace = false;
      resetMain();
      render();
      syncOut();
    }
  };
  
  // Drag-to-scrub
  let isScrubbing = false;
  const scrubHandler = (e) => {
    if (!isScrubbing) return;
    const rect = mainProgress.getBoundingClientRect();
    const pc = clamp((e.clientX - rect.left) / rect.width, 0, 1);
    scrubTo(pc);
  };
  mainProgress.addEventListener('mousedown', (e) => {
    isScrubbing = true;
    scrubHandler(e);
  });
  document.addEventListener('mousemove', scrubHandler);
  document.addEventListener('mouseup', () => {
    isScrubbing = false;
  });
  // Touch support
  mainProgress.addEventListener('touchstart', (e) => {
    isScrubbing = true;
    scrubHandler(e.touches[0]);
  }, { passive: true });
  document.addEventListener('touchmove', (e) => {
    scrubHandler(e.touches[0]);
  }, { passive: true });
  document.addEventListener('touchend', () => {
    isScrubbing = false;
  });
  // Click support (non-drag)
  mainProgress.addEventListener('click', (e) => {
    if (isDragging) return; // Don't scrub if it was a drag
    const rect = mainProgress.getBoundingClientRect();
    const pc = clamp((e.clientX - rect.left) / rect.width, 0, 1);
    scrubTo(pc);
  });
  
  // Speaker progress
  prevBtn.onclick = ()=>setActive(Math.max(0, activeIdx-1));
  nextBtn.onclick = ()=>setActive(Math.min(speakers.length-1, activeIdx+1));
  resetOrder.onclick = ()=>loadPreset(currentPresetId);
  
  // Drag-and-drop reordering
  let dragEl = null;
  spkBar.addEventListener('dragstart', (e) => {
    dragEl = e.target;
    isDragging = true;
  });
  spkBar.addEventListener('dragover', (e) => {
    e.preventDefault();
    const target = e.target.closest('.spk');
    if (target && target !== dragEl) {
      const rect = target.getBoundingClientRect();
      const mid = rect.left + rect.width / 2;
      if (e.clientX < mid) {
        spkBar.insertBefore(dragEl, target);
      } else {
        spkBar.insertBefore(dragEl, target.nextSibling);
      }
    }
  });
  spkBar.addEventListener('dragend', () => {
    if (!dragEl) return;
    dragEl = null;
    isDragging = false;
    const newBase = $$('.spk').map(el => speakers[+el.dataset.idx]).filter(s => s.type !== 'prep');
    // Save to custom preset
    loadPreset('CUSTOM', { base: newBase, settings: collectSettings() });
    formatSelect.value = 'CUSTOM';
  });

  // Settings
  formatSelect.onchange = (e)=>loadPreset(e.target.value);
  [mainInput, firstInput, secondInput, yellowInput, redInput, graceInput, prepInput, cexInput, rebInput, poiInput, spaceInput].forEach(el => {
    el.onchange = () => {
      const settings = collectSettings();
      // If we're not on custom, switch to custom
      if (currentPresetId !== 'CUSTOM') {
        loadPreset('CUSTOM', { base: baseSpeakers, settings });
        formatSelect.value = 'CUSTOM';
      } else {
        // Just update the custom preset
        PRESETS.CUSTOM.settings = settings;
        localStorage.setItem('debateCustomPreset', JSON.stringify(PRESETS.CUSTOM));
        // Reload current speaker with new times
        loadPreset('CUSTOM');
      }
    };
  });
  
  exportBtn.onclick = exportSettings;
  importBtn.onclick = () => importFile.click();
  importFile.onchange = (e) => {
    if (e.target.files[0]) importSettings(e.target.files[0]);
    e.target.value = null; // Reset file input
  };

  // Notes
  notesArea.oninput = saveNote;
  exportNotesBtn.onclick = exportNotesTxt;
  importNotesBtn.onclick = () => importNotesFile.click();
  importNotesFile.onchange = (e) => {
    if (e.target.files[0]) importNotes(e.target.files[0]);
    e.target.value = null;
  };
  clearNotesBtn.onclick = clearAllNotes;
  
  // Toggle Panels
  toggleSettings.onclick = () => {
    isSettingsOpen = !isSettingsOpen;
    togglePanel(settingsPanel, isSettingsOpen);
    toggleSettings.textContent = isSettingsOpen ? currentLang.hide : currentLang.show;
  };
  toggleQuickTimers.onclick = () => {
    isQuickTimersOpen = !isQuickTimersOpen;
    togglePanel(quickTimersPanel, isQuickTimersOpen, toggleQuickTimers, 'open');
    updateButtonStates();
  };
  toggleNotesBtn.onclick = () => {
    isNotesOpen = !isNotesOpen;
    togglePanel(notesPanel, isNotesOpen, toggleNotesBtn, 'open');
    if (isNotesOpen && speakers[activeIdx]) {
      loadNotesForSpeaker(speakers[activeIdx]);
    }
    updateButtonStates();
  };
  
  // Other header buttons
  langSelect.onchange = (e)=>updateLang(e.target.value);
  themeBtn.onclick = ()=> setDark(!document.documentElement.classList.contains('dark'));
  enableBtn.onclick = initAudio;
  muteBtn.onclick = () => { 
    muted = !muted; 
    muteBtn.classList.toggle('active', muted);
    muteBtn.classList.toggle('muted', muted); // for old css
    updateButtonStates();
  };

  // Keyboard shortcuts
  window.addEventListener('keydown', e => {
    // FIX: Ignore shortcuts if typing in an input or textarea
    const activeEl = document.activeElement;
    const isTyping = activeEl && (activeEl.tagName === 'TEXTAREA' || activeEl.tagName === 'INPUT');
    if (isTyping) {
      return;
    }
    
    switch(e.key.toLowerCase()){
      case ' ': e.preventDefault(); startBtn.click(); break;
      case 'r': resetBtn.click(); break;
      case 'arrowright': nextBtn.click(); break;
      case 'arrowleft': prevBtn.click(); break;
      case '1': singleBtn.click(); break;
      case '2': doubleBtn.click(); break;
      case 'm': muteBtn.click(); break;
      case 'd': themeBtn.click(); break;
      case 'p': presenterBtn.click(); break;
      case 'h': helpModal.style.display = 'flex'; break;
    }
  });

  // ---------- Init ----------
  function init() {
    // Init quick timers
    updateCex = createQuickTimer($('#cexClock'), $('#cexFill'), $('#cexStart'), $('#cexReset'), parseTime(cexInput.value));
    updateReb = createQuickTimer($('#rebClock'), $('#rebFill'), $('#rebStart'), $('#rebReset'), parseTime(rebInput.value));
    updatePrep = createQuickTimer($('#prepClock'), $('#prepFill'), $('#prepStart'), $('#prepReset'), parseTime(prepInput.value));
    updatePoi = createQuickTimer($('#poiClock'), $('#poiFill'), $('#poiStart'), $('#poiReset'), parseTime(poiInput.value));
    
    // Load notes
    allNotes = JSON.parse(localStorage.getItem('debateNotes') || '{}');
    
    // Init panels (hide by default)
    togglePanel(settingsPanel, false); isSettingsOpen = false;
    toggleSettings.textContent = currentLang.show;
    
    togglePanel(quickTimersPanel, false, toggleQuickTimers, 'open'); isQuickTimersOpen = false;
    togglePanel(notesPanel, false, toggleNotesBtn, 'open'); isNotesOpen = false;
    
    // FIX: Load preset *before* setting lang (which calls setActive)
    loadPreset(localStorage.getItem('debateFormat') || 'SIMSON');
    updateLang(localStorage.getItem('debateLang') || 'en');
    
    // Set theme
    setDark(localStorage.getItem('debateTheme')==='dark');
  }
  
  init();

})();
</script>
</body>
</html>
