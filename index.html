<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Debate Timer — SimsonTimer Final</title>
<style>
  /* ---------- THEME ---------- */
  :root{
    --bg:#f9fafb; --fg:#111827; --card:#ffffff; --bd:#e5e7eb;
    --track:#e5e7eb; --fill:#111827; --muted:#6b7280;
    --ok-bg:#d1fae5; --ok-fg:#065f46; --warn-bg:#fef3c7; --warn-fg:#92400e; --bad-bg:#fee2e2; --bad-fg:#7f1d1d;
    --prop-bg:#dbeafe; --prop-border:#93c5fd; --prop-fg:#1e3a8a;
    --opp-bg:#fee2e2; --opp-border:#fca5a5; --opp-fg:#7f1d1d;
    --prep-bg:#f3f4f6; --prep-border:#d1d5db; --prep-fg:#374151;
  }
  :root.dark{
    --bg:#1f2937; --fg:#f9fafb; --card:#111827; --bd:#374151;
    --track:#374151; --fill:#f9fafb; --muted:#9ca3af;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--fg);font:16px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{min-height:100%;display:flex;flex-direction:column;gap:24px;align-items:center;padding:24px}
  .container{width:100%;max-width:1100px;display:flex;flex-direction:column;gap:16px}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
  h1{font-size:24px;margin:0}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .btn{appearance:none;border:1px solid var(--bd);background:var(--card);color:var(--fg);border-radius:12px;padding:10px 14px;cursor:pointer;font-weight:700}
  .btn:active{transform:translateY(1px)}
  .card{background:var(--card);border:1px solid var(--bd);border-radius:16px;padding:16px}
  .muted{color:var(--muted)}
  .clock{font-family: "Rubik", ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; font-size:76px; font-weight:900; text-align:center; line-height:1.08; letter-spacing:1px}
  .progress{height:14px;background:var(--track);border-radius:999px;position:relative;overflow:hidden;touch-action:none}
  .fill{position:absolute;inset:0;transform-origin:left center;background:var(--fill);transform:scaleX(0)}
  .grid{display:grid;gap:12px}
  .grid-3{grid-template-columns:repeat(3,minmax(0,1fr))}
  .label{display:flex;flex-direction:column;gap:6px}
  input.input, select.input{padding:10px 12px;border-radius:10px;border:1px solid var(--bd);background:var(--card);color:var(--fg)}
  .note{font-size:14px;color:var(--muted)}
  .speaker-progress{display:flex;flex-wrap:wrap;gap:9px;padding:6px 4px}
  .spk{font-size:13px;font-weight:800;padding:10px 10px;border-radius:10px;background:var(--card);border:2px solid var(--bd);cursor:grab;user-select:none;min-width:58px;text-align:center;display:flex;align-items:center;justify-content:center}
  .spk.inactive{opacity:.4;text-decoration:line-through}
  .spk.active{box-shadow:0 0 0 3px rgba(0,0,0,0.06) inset}
  .spk.prop{background:var(--prop-bg);border-color:var(--prop-border);color:var(--prop-fg)}
  .spk.opp{background:var(--opp-bg);border-color:var(--opp-border);color:var(--opp-fg)}
  .spk.prep{background:var(--prep-bg);border-color:var(--prep-border);color:var(--prep-fg)}
  #helpModal{position:fixed;inset:0;background:rgba(0,0,0,.5);display:none;align-items:center;justify-content:center;padding:16px;z-index:100}
  #helpModal .card{max-width:760px;max-height:90vh;overflow:auto}
  @media (max-width:800px){.grid-3{grid-template-columns:repeat(2,minmax(0,1fr))}}
  @media (max-width:540px){.grid-3{grid-template-columns:1fr}.clock{font-size:56px}}
  /* Hideable settings panel */
  #settingsPanel{overflow:hidden;max-height:1000px;transition:max-height 0.35s ease;}
  #quickTimersPanel{overflow:hidden;max-height:1000px;transition:max-height 0.35s ease;}

  /* STATE COLORS VIA BODY CLASSES */
  body.state-warn{background:var(--warn-bg); color:var(--warn-fg)}
  body.state-bad{background:var(--bad-bg); color:var(--bad-fg)}
  body.state-warn .card, body.state-bad .card{border-color: currentColor}
  body.state-grace{animation:pulseGrace 2.4s ease-in-out infinite}
  @keyframes pulseGrace{0%{background:var(--bg)}50%{background:var(--bad-bg)}100%{background:var(--bg)}}
  
  #muteBtn .icon-off { display: none; }
  #muteBtn.muted .icon-on { display: none; }
  #muteBtn.muted .icon-off { display: inline-block; }
  #muteBtn svg { vertical-align: middle; width: 18px; height: 18px; }

/* Presenter grace mode */
.presenter-grace #pClock { color: var(--grace-fg); }
.presenter-grace { animation: gracePulse 1.6s ease-in-out infinite !important; }
</style>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Rubik:wght@700;900&display=swap" rel="stylesheet">
</head>
<body>
  <div class="wrap">
    <div class="container">
      <header>
        <h1>Debate Timer</h1>
        <div class="row">
          <label class="label" style="margin-right:8px">
            <span style="font-weight:700">Debate Style</span>
            <select id="formatSelect" class="input">
              <option value="SIMSON">Simson</option>
              <option value="AP">AP</option>
              <option value="BP">BP</option>
              <option value="WSDC">WSDC</option>
              <option value="PF">PF</option>
              <option value="CX">Policy / CX</option>
              <option value="LD">Lincoln–Douglas</option>
            </select>
          </label>
          <button id="helpBtn" class="btn">Help</button>
          <button id="themeBtn" class="btn">Dark Mode</button>
          <button id="presenterBtn" class="btn">Presenter Mode</button>
          <button id="toggleQuickTimers" class="btn">Show Quick Timers</button>
          <button id="enableBtn" class="btn">Initialize Sound</button>
          <button id="muteBtn" class="btn" title="Mute (M)">
            <svg class="icon-on" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
            <svg class="icon-off" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M11 5L6 9H2v6h4l5 4V5z"></path><path d="M23 9l-6 6"></path><path d="M17 9l6 6"></path></svg>
          </button>
          <label class="label" style="flex-direction:row;align-items:center;gap:8px"><span style="font-weight:700">Volume</span><input id="volume" type="range" min="0" max="1" step="0.05" value="0.6"/></label>
        </div>
      </header>

      <!-- Speaker Progress -->
      <div class="card">
        <div style="font-weight:800;margin-bottom:8px">Speaker Progress</div>
        <div id="spkBar" class="speaker-progress"></div>
        <div class="row" style="justify-content:space-between;margin-top:8px">
          <div class="row">
            <button id="prevBtn" class="btn">Previous</button>
            <button id="nextBtn" class="btn">Next</button>
          </div>
          <button id="resetOrder" class="btn">Reset Order</button>
        </div>
        <div class="note">Click = select • Double-click = toggle active • Drag = reorder</div>
      </div>

      <!-- Main Timer Card -->
      <div class="card" id="mainCard">
        <div class="row" style="justify-content:space-between"><div id="mainTitle" style="font-weight:800">Substantive Speech</div><div id="meta" class="muted"></div></div>
        <div id="clock" class="clock">7:00</div>
        <div id="mainProgress" class="progress"><div id="fill" class="fill"></div></div>
        <div class="row" style="justify-content:center;margin-top:10px">
          <button id="startBtn" class="btn">Start</button>
          <button id="resetBtn" class="btn">Reset</button>
          <button id="singleBtn" class="btn">Single</button>
          <button id="doubleBtn" class="btn">Double</button>
          <button id="testContBtn" class="btn" title="Start continuous bell test">Test Continuous Bell</button>
          <button id="stopBellBtn" class="btn" title="Stop continuous bell">Stop Bell</button>
        </div>
        <div class="note"><strong>Status:</strong> <span id="status">idle</span></div>
      </div>

      <!-- Quick Timers -->
      <div id="quickTimersPanel" class="grid grid-3">
        <div class="card">
          <div style="font-weight:800;margin-bottom:6px">Cross-Ex / Shared</div>
          <div id="cexClock" class="clock" style="font-size:32px">01:00</div>
          <div class="progress" style="margin-top:8px"><div id="cexFill" class="fill"></div></div>
          <div class="row" style="justify-content:center;margin-top:8px"><button id="cexStart" class="btn">Start</button><button id="cexReset" class="btn">Reset</button></div>
        </div>
        <div class="card">
          <div style="font-weight:800;margin-bottom:6px">Rebuttal / Reply</div>
          <div id="rebClock" class="clock" style="font-size:32px">04:00</div>
          <div class="progress" style="margin-top:8px"><div id="rebFill" class="fill"></div></div>
          <div class="row" style="justify-content:center;margin-top:8px"><button id="rebStart" class="btn">Start</button><button id="rebReset" class="btn">Reset</button></div>
        </div>
        <div class="card">
          <div style="font-weight:800;margin-bottom:6px">Prep</div>
          <div id="prepClock" class="clock" style="font-size:32px">01:00</div>
          <div class="progress" style="margin-top:8px"><div id="prepFill" class="fill"></div></div>
          <div class="row" style="justify-content:center;margin-top:8px"><button id="prepStart" class="btn">Start</button><button id="prepReset" class="btn">Reset</button></div>
        </div>
      </div>

      <!-- Settings (hideable) -->
      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px"><span style="font-weight:800;">Timer Settings</span><button id="toggleSettings" class="btn" style="padding:6px 10px;font-size:14px">Hide</button></div>
        <div id="settingsPanel">
          <div class="grid grid-3">
            <label class="label"><span>Main (m:ss)</span><input id="mainInput" class="input" value="3:00"/></label>
            <label class="label"><span>1st Bell from start (m:ss)</span><input id="firstInput" class="input" value="1:00"/></label>
            <label class="label"><span>2nd Bell from start (m:ss)</span><input id="secondInput" class="input" value="2:00"/></label>
            <label class="label"><span>Yellow at remaining (m:ss)</span><input id="yellowInput" class="input" value="1:00"/></label>
            <label class="label"><span>Red at remaining (m:ss)</span><input id="redInput" class="input" value="0:30"/></label>
            <label class="label"><span>Grace Period (m:ss)</span><input id="graceInput" class="input" value="0:30"/></label>
            <label class="label"><span>Prep Time (m:ss)</span><input id="prepInput" class="input" value="1:00"/></label>
            <label class="label"><span>Cross-Ex (m:ss)</span><input id="cexInput" class="input" value="1:00"/></label>
            <label class="label"><span>Rebuttal (m:ss)</span><input id="rebInput" class="input" value="3:00"/></label>
            <label class="label"><span>Bell spacing (ms)</span><input id="spaceInput" class="input" value="100"/></label>
          </div>
          <div class="row" style="margin-top:12px;gap:8px;flex-wrap:wrap">
            <button id="exportBtn" class="btn">Export Settings</button>
            <button id="importBtn" class="btn">Import Settings</button>
            <input id="importFile" type="file" accept="application/json" style="display:none">
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- Help Modal -->
  <div id="helpModal">
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
        <h2 style="margin:0">Help</h2>
        <button id="closeHelp" class="btn">Close</button>
      </div>
      <hr style="border:0;border-top:1px solid var(--bd);margin:12px 0"/>
      <h3>Quick Start</h3>
      <ol>
        <li>Click <strong>Initialize Sound</strong> once (mobile browsers require a gesture).</li>
        <li>Adjust times in <strong>Timer Settings</strong> if needed.</li>
        <li>Use <strong>Speaker Progress</strong> to pick who is speaking.</li>
        <li>Press <strong>Presenter Mode</strong> to open the projector view.</li>
      </ol>
      <h3>Presenter Mode</h3>
      <p>Opens a clean, large timer-only display in a separate window. It mirrors start/pause/reset and bells in real time. Use your browser’s move-to-display / fullscreen options on the projector.</p>
      <h3>Keyboard Shortcuts</h3>
      <ul>
        <li><strong>Space</strong> — Start/Pause main timer</li>
        <li><strong>R</strong> — Reset current timer</li>
        <li><strong>→ / ←</strong> — Next / Previous speaker</li>
        <li><strong>1 / 2</strong> — Single / Double bell</li>
        <li><strong>M</strong> — Mute / Unmute</li>
        <li><strong>D</strong> — Toggle Dark Mode</li>
        <li><strong>P</strong> — Toggle Presenter window</li>
        <li><strong>H</strong> — Open Help</li>
      </ul>
      <h3>Timers</h3>
      <ul>
        <li><strong>Substantive</strong> uses main time with 1st & 2nd bell and a grace period; after grace, continuous bell (250 ms) until stopped.</li>
        <li><strong>Rebuttal</strong> runs from the Rebuttal time, ending with a double bell.</li>
        <li><strong>Cross-Ex</strong> and <strong>Prep</strong> are separate mini timers.</li>
      </ul>
      <p class="note">Sound respects the volume slider. Uploadable/custom sounds can be added later if needed.</p>
    </div>
  </div>

<script>
// ---------- GLOBAL Utilities (for main + presenter) ----------
const $ = (s,o=document)=>o.querySelector(s);
const fmt=(ms)=>{ms=Math.max(0,Math.round(ms/1000));const m=Math.floor(ms/60),s=ms%60;return m+":"+(s<10?"0":"")+s};
function setDarkGlobal(on) { document.documentElement.classList.toggle('dark', on); }
function applyBodyState(state){
  document.body.classList.remove('state-warn','state-bad','state-grace');
  if(state) document.body.classList.add(state);
}

(function(){
  // ---------- Utilities ----------
  const $$ = (s,o=document)=>Array.from(o.querySelectorAll(s));
  const clamp=(n,a,b)=>Math.min(Math.max(n,a),b);
  const parseTime = t=>{const p=(t||'').trim().split(':'); if(p.length===1) return (+p[0]||0)*1000; const m=+p[0]||0,s=+p[1]||0; return (m*60+s)*1000};
  
  // ---------- Theme ----------
  const themeBtn = $('#themeBtn');
  const setDark = (on)=>{document.documentElement.classList.toggle('dark',on); localStorage.setItem('debateTheme', on? 'dark':'light'); themeBtn.textContent = on? 'Light Mode':'Dark Mode'};
  setDark(localStorage.getItem('debateTheme')==='dark');
  themeBtn.onclick = ()=> setDark(!document.documentElement.classList.contains('dark'));

  // ---------- Help ----------
  const helpBtn=$('#helpBtn'), helpModal=$('#helpModal'), closeHelp=$('#closeHelp');
  helpBtn.onclick=()=>helpModal.style.display='flex';
  closeHelp.onclick=()=>helpModal.style.display='none';
  window.addEventListener('keydown',e=>{ if(e.key.toLowerCase()==='h'){ helpModal.style.display='flex' } });

  // ---------- Audio ----------
  let audioCtx=null, unlocked=false, masterGain=null, muted=false; let contBellInterval=null;
  const enableBtn=$('#enableBtn'), muteBtn=$('#muteBtn'), volume=$('#volume');
  async function initAudio(){
    try{
      audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      masterGain = audioCtx.createGain(); masterGain.gain.value = +volume.value; masterGain.connect(audioCtx.destination);
      unlocked=true; setStatus('Sound ready.');
    }catch(e){ setStatus('Sound failed. Please refresh.'); }
  }
  enableBtn.onclick=initAudio;
  volume.oninput=()=>{ if(masterGain) masterGain.gain.value = +volume.value };
  function ding({type='single'}={}){
    if(!unlocked||!audioCtx) return;
    const now=audioCtx.currentTime;
    const osc=audioCtx.createOscillator();
    const osc2=audioCtx.createOscillator();
    const gain=audioCtx.createGain();
    const base=880; // A5
    osc.type='sine'; osc.frequency.setValueAtTime(base,now);
    osc2.type='sine'; osc2.frequency.setValueAtTime(base*1.5,now);
    gain.gain.setValueAtTime(muted?0:0.4,now);
    gain.gain.exponentialRampToValueAtTime(muted?0:0.0001, now+0.8);
    osc.connect(gain); osc2.connect(gain); gain.connect(masterGain);
    osc.start(now); osc2.start(now); osc.stop(now+0.9); osc2.stop(now+0.9);
  }
  function stopContinuous(){ if(contBellInterval){ clearInterval(contBellInterval); contBellInterval=null } }

  muteBtn.onclick=()=>{ 
    muted=!muted; 
    muteBtn.classList.toggle('muted', muted);
  };

  // ---------- Presenter Mode ----------
  const channel = new BroadcastChannel('debate_timer_sync_v1');
  let presenterWin=null;
  const presenterBtn=$('#presenterBtn');
  presenterBtn.onclick=()=>{
    if(!presenterWin || presenterWin.closed){
      presenterWin = window.open(window.location.pathname+'?presenter=true', 'presenter', 'width=1000,height=700');
      if(presenterWin){ presenterWin.focus(); setTimeout(()=>syncOut(true),150); }
    }else{ presenterWin.focus(); }
  };

  const isPresenter = new URLSearchParams(location.search).get('presenter')==='true';
  if(isPresenter){
    document.body.innerHTML = `
      <div style="min-height:100vh;display:flex;align-items:center;justify-content:center;background:var(--bg);color:var(--fg);">
        <div style="text-align:center">
          <div id="pClock" style="font-family:Rubik,ui-rounded,system-ui;-webkit-font-smoothing:antialiased;font-weight:900;font-size:22vw;line-height:1;letter-spacing:2px;">00:00</div>
          <div id="pMeta" style="margin-top:12px;color:var(--muted);font-weight:700">Presenter</div>
        </div>
      </div>`;
  }

  function syncOut(full=false){
    // Calculate state here, just for the message
    const left = mainRemain;
    const warn = left <= yellow && left > red && mode==='main' && !inGrace;
    const bad = left <= red && left > 0 && mode==='main' && !inGrace;
    let bodyState = null;
    if(inGrace) bodyState = 'state-grace';
    else if(bad) bodyState = 'state-bad';
    else if(warn) bodyState = 'state-warn';

    const payload={
      type:'state', 
      full, 
      main:{remain: mainRemain, total:mainTotal, running:mainRunning}, 
      meta: (titleEl?.textContent||'') + (metaEl.textContent? ' — '+metaEl.textContent : ''), 
      inGrace,
      state: bodyState,
      theme: document.documentElement.classList.contains('dark') ? 'dark' : 'light'
    };
    channel.postMessage(payload);
  }
  channel.onmessage=(e)=>{
    if(!e||!e.data) return; const m=e.data;
    if(isPresenter && m.type==='state'){
      const pc=$('#pClock'); const pm=$('#pMeta');
      
      // Apply theme (using global function)
      setDarkGlobal(m.theme === 'dark');

      // Apply time and meta (using global functions)
      if(pc) pc.textContent = fmt(m.main.remain);
      if(pm) pm.textContent = m.meta||'';
      
      // Apply grace pulse
      document.body.classList.toggle('presenter-grace', m.inGrace);

      // Apply visual state (using global function)
      applyBodyState(m.state);
    }
  };

  // ---------- Presets (base) ----------
  const PRESETS = {
    SIMSON: {
      label: 'Simson',
      base: [
        {role:'PM', side:'prop', initials:'PM'},
        {role:'LO', side:'opp', initials:'LO'},
        {role:'DPM', side:'prop', initials:'DPM'},
        {role:'DLO', side:'opp', initials:'DLO'},
        {role:'GW', side:'prop', initials:'GW'},
        {role:'OW', side:'opp', initials:'OW'},
        {role:'GR', side:'prop', initials:'GR'},
        {role:'OR', side:'opp', initials:'OR'}
      ],
      // NOTE: Simson between-speech prep is 1:00. Add a 20:00 round prep at the very beginning via sequence builder.
      settings: { main:'3:00', first:'1:00', second:'2:00', yellow:'1:00', red:'0:30', grace:'0:30', prep:'1:00', cex:'1:00', reb:'3:00', spacing:'100', roundPrep:'20:00' }
    },
    AP: {
      label: 'Asian Parliamentary',
      base: [
        {role:'Prime Minister', side:'prop', initials:'PM'},
        {role:'Leader of Opposition', side:'opp', initials:'LO'},
        {role:'Deputy Prime Minister', side:'prop', initials:'DPM'},
        {role:'Deputy Leader of Opposition', side:'opp', initials:'DLO'},
        {role:'Government Whip', side:'prop', initials:'GW'},
        {role:'Opposition Whip', side:'opp', initials:'OW'},
        {role:'Government Reply', side:'prop', initials:'GR'},
        {role:'Opposition Reply', side:'opp', initials:'OR'}
      ],
      settings: { main:'7:00', first:'1:00', second:'6:00', yellow:'1:00', red:'0:30', grace:'0:30', prep:'20:00', cex:'1:00', reb:'4:00', spacing:'100', roundPrep:'00:00' }
    }
    // Other presets can be added similarly...
  };

  // ---------- Runtime state ----------
  let speakers = [];       // full sequence including prep tokens
  let baseSpeakers = [];   // base speakers (no preps)
  let activeIdx = 0;
  const spkBar=$('#spkBar');
  const formatSelect=$('#formatSelect');

  // ---------- DOM references ----------
  const clockEl=$('#clock'), fillEl=$('#fill'), metaEl=$('#meta'), statusEl=$('#status'), titleEl=$('#mainTitle');
  const mainProgress=$('#mainProgress');
  const mainInput=$('#mainInput'), firstInput=$('#firstInput'), secondInput=$('#secondInput'), yellowInput=$('#yellowInput'), redInput=$('#redInput'), graceInput=$('#graceInput');
  const prepInput=$('#prepInput'), cexInput=$('#cexInput'), rebInput=$('#rebInput'), spaceInput=$('#spaceInput');
  const startBtn=$('#startBtn'), resetBtn=$('#resetBtn'), singleBtn=$('#singleBtn'), doubleBtn=$('#doubleBtn'), testContBtn=$('#testContBtn'), stopBellBtn=$('#stopBellBtn');
  const prepClock=$('#prepClock'), prepFill=$('#prepFill'), prepStart=$('#prepStart'), prepReset=$('#prepReset');
  const cexClock=$('#cexClock'), cexFill=$('#cexFill'), cexStart=$('#cexStart'), cexReset=$('#cexReset');
  const rebClock=$('#rebClock'), rebFill=$('#rebFill'), rebStart=$('#rebStart'), rebReset=$('#rebReset');

  // Global timer state
  let mainTotal = parseTime(mainInput.value), mainRemain = mainTotal, mainRunning=false, lastTick=0;
  let graceRemain = 0, inGrace=false;
  let mode='main'; // 'main' | 'prep' | 'reb' | 'cross'
  let prepRemain = parseTime(prepInput.value), cexRemain=parseTime(cexInput.value), rebRemain=parseTime(rebInput.value);

  // wake lock
  let wakeLock = null;
  async function requestWakeLock(){
    if('wakeLock' in navigator && !wakeLock){
      try{ wakeLock = await navigator.wakeLock.request('screen'); wakeLock.addEventListener('release', ()=>{ wakeLock = null }); }
      catch(e){ /* ignore */ }
    }
  }
  async function releaseWakeLock(){
    try{ if(wakeLock){ await wakeLock.release(); wakeLock = null } }catch(e){}
  }

  // ---------- helpers ----------
  function saveSettings(){
    const s={main:mainInput.value, first:firstInput.value, second:secondInput.value, yellow:yellowInput.value, red:redInput.value, grace:graceInput.value, prep:prepInput.value, cex:cexInput.value, reb:rebInput.value, spacing:spaceInput.value};
    localStorage.setItem('debateSettings', JSON.stringify(s));
  }
  function loadSettings(){
    try{ const s=JSON.parse(localStorage.getItem('debateSettings')||'null'); if(!s) return; mainInput.value=s.main; firstInput.value=s.first; secondInput.value=s.second; yellowInput.value=s.yellow; redInput.value=s.red; graceInput.value=s.grace; prepInput.value=s.prep; cexInput.value=s.cex; rebInput.value=s.reb; spaceInput.value=s.spacing; }catch(e){}
  }
  loadSettings();

  let firstBell = parseTime(firstInput.value), secondBell = parseTime(secondInput.value), spacing = +spaceInput.value || 100;
  let yellow=parseTime(yellowInput.value), red=parseTime(redInput.value), grace=parseTime(graceInput.value);

  function syncFromInputs(){
    mainTotal=parseTime(mainInput.value); firstBell=parseTime(firstInput.value); secondBell=parseTime(secondInput.value);
    yellow=parseTime(yellowInput.value); red=parseTime(redInput.value); grace=parseTime(graceInput.value); spacing=+spaceInput.value||100;
    prepRemain=parseTime(prepInput.value); cexRemain=parseTime(cexInput.value); rebRemain=parseTime(rebInput.value);
    if(mode==='main'){ mainRemain=Math.min(mainRemain, mainTotal); }
    updateMeta(); render(); syncOut();
    saveSettings();
  }

  $$('input.input').forEach(i=> i.addEventListener('change', ()=>{ syncFromInputs(); }));

  // ---------- Build full speaker sequence with: Round Prep first, then speech+preps (prep belongs to NEXT speaker) ----------
  function buildSequenceForPreset(presetName){
    const preset = PRESETS[presetName] || PRESETS.SIMSON;
    baseSpeakers = JSON.parse(JSON.stringify(preset.base)); // clone
    speakers = [];

    // Insert 20-minute round prep at the very beginning (if configured)
    const roundPrepDur = preset.settings.roundPrep || '00:00';
    if(parseTime(roundPrepDur) > 0){
      speakers.push({type:'prep', role:'Round Prep', side:'neutral', initials:'20m Prep', baseIndex:-1});
    }

    // For each base speaker, add speaker then a prep (except after last)
    for(let i=0;i<baseSpeakers.length;i++){
      const sp = baseSpeakers[i];
      speakers.push({type:'spk', role:sp.role, side:sp.side, initials:sp.initials, baseIndex:i});
      if(i < baseSpeakers.length-1){
        const next = baseSpeakers[i+1];
        speakers.push({type:'prep', role:'Prep', side:next.side, initials:'Prep', belongsToIndex:i+1});
      }
    }
    activeIdx = 0;
  }

  // ---------- Render speakers UI ----------
  function drawSpeakers(){
    spkBar.innerHTML='';
    speakers.forEach((s, idx)=>{
      const el = document.createElement('div');
      const sideClass = s.type==='prep' ? 'prep' : (s.side==='opp'?'opp':'prop');
      el.className = 'spk ' + sideClass + (idx===activeIdx? ' active':'') + (s.disabled? ' inactive':'');
      el.textContent = s.initials || s.role;
      el.title = s.role + (s.type==='prep' && s.role!=='Round Prep' ? ' — Prep for next speaker':'');
      el.draggable = s.type !== 'prep';
      el.addEventListener('click', ()=>{
        if(s.disabled) return; activeIdx = idx; applyForSpeaker(); drawSpeakers();
      });
      el.addEventListener('dblclick', ()=>{ if(s.type!=='spk') return; s.disabled = !s.disabled; drawSpeakers(); });
      el.addEventListener('dragstart', ev=>{ if(s.type!=='spk') ev.preventDefault(); else ev.dataTransfer.setData('text/plain', idx) });
      el.addEventListener('dragover', ev=>ev.preventDefault());
      el.addEventListener('drop', ev=>{
        ev.preventDefault();
        const from = +ev.dataTransfer.getData('text/plain');
        const to = idx;
        if(speakers[from].type!=='spk' || speakers[to].type!=='spk') return;
        const fromBase = speakers[from].baseIndex;
        const toBase = speakers[to].baseIndex;
        const a = baseSpeakers.splice(fromBase,1)[0];
        baseSpeakers.splice(toBase,0,a);
        buildSequenceForPreset(formatSelect.value);
        drawSpeakers();
      });
      spkBar.appendChild(el);
    });
  }

  // ---------- apply selected speaker (load the timer values and set mode) ----------
  function applyForSpeaker(){
    const s = speakers[activeIdx];
    if(!s) return;
    const preset = PRESETS[formatSelect.value] || PRESETS.SIMSON;

    inGrace = false; graceRemain = 0; // leaving any grace state when switching

    if(s.type==='prep'){
      mode='prep';
      const total = (s.role==='Round Prep') ? parseTime(preset.settings.roundPrep||'20:00') : parseTime(preset.settings.prep||prepInput.value);
      mainTotal = total; mainRemain = total;
      titleEl.textContent = s.role==='Round Prep' ? 'Round Prep' : `Prep — (${s.side==='prop'?'Prop':(s.side==='opp'?'Opp':'')})`;
    } else if(s.type==='spk'){
      const isReply = s.role.toLowerCase().includes('reply') || s.initials==='GR' || s.initials==='OR' || s.initials==='Pro FF' || s.initials==='Con FF';
      if(isReply){ mode='reb'; mainTotal = parseTime(rebInput.value); titleEl.textContent = `${s.role} — Reply/Rebuttal`; }
      else { mode='main'; mainTotal = parseTime(mainInput.value); titleEl.textContent = `${s.role} — Substantive`; }
      mainRemain = mainTotal;
    }
    mainRunning=false; startBtn.textContent='Start'; setStatus('idle'); updateMeta(); render(); syncOut(true);
  }

  // ---------- update meta (helper) ----------
  function updateMeta(){
    const s = speakers[activeIdx];
    let roleTxt = '';
    if(s){
      if(s.type==='prep'){
        roleTxt = s.role==='Round Prep' ? 'Round Prep' : `Prep for ${baseSpeakers[s.belongsToIndex]?.initials||''}`;
      } else {
        roleTxt = s.role;
      }
    }
    metaEl.textContent = roleTxt;

    // Interface color state (no emojis). Warn/Bad/Grace via body classes
    const left = mainRemain;
    const warn = left <= yellow && left > red && mode==='main' && !inGrace;
    const bad = left <= red && left > 0 && mode==='main' && !inGrace;
    if(inGrace) applyBodyState('state-grace');
    else if(bad) applyBodyState('state-bad');
    else if(warn) applyBodyState('state-warn');
    else applyBodyState(null);
  }

  // ---------- render main UI ----------
  function render(){
    if(!Number.isFinite(mainRemain)) mainRemain = 0;
    if(mainRemain < 0) mainRemain = 0;
    clockEl.textContent = inGrace ? fmt(graceRemain) : fmt(mainRemain);
    if(inGrace){
      const s = speakers[activeIdx];
      if(s && s.type==='spk'){
        titleEl.textContent = `${s.role} — Grace`;
      } else {
        titleEl.textContent = `Grace`;
      }
    }
    const raw = mainTotal > 0 ? (1 - (mainRemain / mainTotal)) : 0;
    const safePct = Number.isFinite(raw) ? clamp(raw, 0, 1) : 0;
    fillEl.style.transform = `scaleX(${safePct})`;
    const prepDen = parseTime(prepInput.value) || 1;
    const prepPct = clamp(1 - (prepRemain / prepDen), 0, 1);
    $('#prepFill').style.transform = `scaleX(${prepPct})`;
  }

  // ---------- bells and continuous grace ----------
  function startContinuousAfterGrace(){
    if(contBellInterval) return;
    contBellInterval = setInterval(()=> ding({type:'single'}), 250);
  }

  function triggerEndOfSpeech(){
    inGrace = true;
    mainRunning = true; // keep timer running during grace
    startBtn.textContent = 'Pause';
    graceRemain = parseTime(graceInput.value);
    if(formatSelect.value === 'SIMSON' && mode==='main'){
      ding({type:'single'});
      setTimeout(()=>ding({type:'single'}), spacing);
    } else {
      ding({type:'double'});
    }
    stopContinuous();
    applyBodyState('state-grace');
  }

  // ---------- main tick loop ----------
  function tick(ts){
    if(!lastTick) lastTick=ts; const dt = ts - lastTick; lastTick = ts;
    if(mainRunning){
      if(!inGrace){
        mainRemain = Math.max(0, mainRemain - dt);
        // bells: check when crossing thresholds (first/second)
        const elapsed = mainTotal - mainRemain;
        if(Math.abs(elapsed - firstBell) < dt/2) ding({type:'single'});
        if(Math.abs(elapsed - secondBell) < dt/2) ding({type:'single'});
        if(mainRemain === 0){
          mainRunning = false;
          triggerEndOfSpeech();
        }
      } else {
        graceRemain = Math.max(0, graceRemain - dt);
        if(graceRemain === 0){
          startContinuousAfterGrace();
        }
      }
      updateMeta(); syncOut();
    }
    render();
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // ---------- advance logic ----------
  function advanceToNextCard(){
    for(let i=1;i<=speakers.length;i++){
      const j = (activeIdx + i) % speakers.length;
      if(!speakers[j].disabled){ activeIdx = j; applyForSpeaker(); drawSpeakers(); break; }
    }
  }

  // ---------- Controls ----------
  function setStatus(t){ statusEl.textContent = t }
  startBtn.onclick = async ()=>{
    mainRunning = !mainRunning;
    startBtn.textContent = mainRunning ? 'Pause' : 'Start';
    setStatus(mainRunning ? 'running' : 'paused');
    stopContinuous();
    if(mainRunning) await requestWakeLock(); else await releaseWakeLock();
    syncOut();
  };
  resetBtn.onclick=async ()=>{
    inGrace = false;
    document.body.classList.remove('state-grace','state-warn','state-bad');
    mainRunning=false;
    startBtn.textContent='Start';
    mainRemain=mainTotal;
    graceRemain=0;
    stopContinuous();
    setStatus('idle');
    updateMeta();
    render();
    syncOut();
    await releaseWakeLock();
  };
  singleBtn.onclick=()=> ding({type:'single'});
  doubleBtn.onclick=()=>{ ding({type:'single'}); setTimeout(()=>ding({type:'single'}), spacing||100) };
  testContBtn.onclick=()=>{ stopContinuous(); document.body.classList.add('state-grace'); contBellInterval = setInterval(()=> ding({type:'single'}), 250); };
  stopBellBtn.onclick=()=>{ stopContinuous(); document.body.classList.remove('state-grace'); };

  // quick mini timers (prep/cex/reb)
  function makeMini(startBtn, resetBtn, clockEl, fillEl, getRemain, setRemain){
    let running=false, last=0, total=parseTime(clockEl.textContent)||60000;
    function draw(){ clockEl.textContent = fmt(getRemain()); const pct=clamp(1-(getRemain()/total),0,1); fillEl.style.transform=`scaleX(${pct})` }
    function raf(ts){ if(!last) last=ts; const dt=ts-last; last=ts; if(running){ setRemain(Math.max(0,getRemain()-dt)); if(getRemain()===0){ running=false; ding({type:'double'}) } draw() } requestAnimationFrame(raf) }
    requestAnimationFrame(raf);
    startBtn.onclick=()=>{ running=!running; startBtn.textContent=running?'Pause':'Start' };
    resetBtn.onclick=()=>{ running=false; startBtn.textContent='Start'; setRemain(total); draw() };
  }
  makeMini(prepStart, prepReset, prepClock, prepFill, ()=>prepRemain, v=>prepRemain = v);
  makeMini(cexStart, cexReset, cexClock, cexFill, ()=>cexRemain, v=>cexRemain=v);
  makeMini(rebStart, rebReset, rebClock, rebFill, ()=>rebRemain, v=>rebRemain=v);

  // ---------- scrubbing logic (paused-only) ----------
  let isScrubbing = false;
  function scrubTo(container, event){
  if(mainTotal <= 0) return;
  const rect = container.getBoundingClientRect();
  const clientX = event.touches ? event.touches[0].clientX : event.clientX;
  const x = clamp(clientX - rect.left, 0, rect.width);
  const rawPct = rect.width > 0 ? (x / rect.width) : 0;
  const pct = Number.isFinite(rawPct) ? clamp(rawPct, 0, 1) : 0;
  mainRemain = Math.round(mainTotal * (1 - pct));
  if(mainRemain === 0 && !inGrace){
    mainRunning = false;
    triggerEndOfSpeech();
    return;
  }
  updateMeta();
  render(true);
  syncOut();
}

  mainProgress.addEventListener('pointerdown', (e)=>{
    if(mainRunning) return; // only allow scrub when paused
    isScrubbing = true;
    mainProgress.setPointerCapture(e.pointerId);
    scrubTo(mainProgress, e);
  });
  mainProgress.addEventListener('pointermove', (e)=>{ if(!isScrubbing) return; scrubTo(mainProgress, e); });
  mainProgress.addEventListener('pointerup', (e)=>{ if(isScrubbing){ isScrubbing=false; try{ mainProgress.releasePointerCapture(e.pointerId);}catch(e){} }});
  mainProgress.addEventListener('pointercancel', ()=>{ isScrubbing=false; });

  // ---------- keyboard shortcuts ----------
  window.addEventListener('keydown',e=>{
    const k=e.key.toLowerCase();
    if(['input','textarea'].includes((document.activeElement||{}).tagName?.toLowerCase())) return;
    if(k===' '){ e.preventDefault(); startBtn.click() }
    else if(k==='r'){ resetBtn.click() }
    else if(k==='arrowright'){ $('#nextBtn').click() }
    else if(k==='arrowleft'){ $('#prevBtn').click() }
    else if(k==='1'){ singleBtn.click() }
    else if(k==='2'){ doubleBtn.click() }
    else if(k==='m'){ muteBtn.click() }
    else if(k==='d'){ themeBtn.click() }
    else if(k==='p'){ presenterBtn.click() }
    else if(k==='h'){ helpBtn.click() }
  });

  // ---------- prev/next UI ----------
  $('#nextBtn').onclick = ()=> { advanceToNextCard(); drawSpeakers(); };
  $('#prevBtn').onclick = ()=>{
    for(let i=1;i<=speakers.length;i++){
      const j=(activeIdx - i + speakers.length)%speakers.length;
      if(!speakers[j].disabled){ activeIdx=j; break; }
    }
    applyForSpeaker(); drawSpeakers();
  };

  $('#resetOrder').onclick = ()=>{ buildSequenceForPreset(formatSelect.value); drawSpeakers(); applyForSpeaker(); };

  // format change handler
  formatSelect.addEventListener('change', ()=>{
    buildSequenceForPreset(formatSelect.value);
    drawSpeakers();
    applyForSpeaker();
  });

  // prep input live update
  prepInput.addEventListener('change', ()=>{ if(mode==='prep'){ mainTotal = parseTime(prepInput.value); mainRemain = mainTotal; render(); } saveSettings(); });

  // ---------- Settings Panel Toggle ----------
  const settingsPanel = document.getElementById('settingsPanel');
  const toggleSettingsBtn = document.getElementById('toggleSettings');
  let settingsVisible = false;
  toggleSettingsBtn.textContent = 'Show';
  // ensure correct initial measured height
  requestAnimationFrame(()=>{ settingsPanel.style.maxHeight = '0px'; });
  toggleSettingsBtn.onclick = () => {
    settingsVisible = !settingsVisible;
    if(settingsVisible){
      settingsPanel.style.maxHeight = settingsPanel.scrollHeight + 'px';
      toggleSettingsBtn.textContent = 'Hide';
    } else {
      settingsPanel.style.maxHeight = '0px';
      toggleSettingsBtn.textContent = 'Show';
    }
  };

  // ---------- Quick Timers Panel Toggle ----------
  const quickTimersPanel = document.getElementById('quickTimersPanel');
  const toggleQuickTimersBtn = document.getElementById('toggleQuickTimers');
  let quickTimersVisible = false; // Hide by default
  
  // Set initial state (hidden)
  requestAnimationFrame(()=>{ 
    quickTimersPanel.style.maxHeight = '0px';
  });
  toggleQuickTimersBtn.textContent = 'Show Quick Timers';

  toggleQuickTimersBtn.onclick = () => {
    quickTimersVisible = !quickTimersVisible;
    if(quickTimersVisible){
      quickTimersPanel.style.maxHeight = quickTimersPanel.scrollHeight + 'px';
      toggleQuickTimersBtn.textContent = 'Hide Quick Timers';
    } else {
      quickTimersPanel.style.maxHeight = '0px';
      toggleQuickTimersBtn.textContent = 'Show Quick Timers';
    }
  };

  // ---------- Export / Import ----------
  const exportBtn = document.getElementById('exportBtn');
  const importBtn = document.getElementById('importBtn');
  const importFile = document.getElementById('importFile');

  exportBtn.onclick = () => {
    const state = {
      settings: JSON.parse(localStorage.getItem('debateSettings')||'{}'),
      speakers: baseSpeakers,
      activeIdx,
      theme: localStorage.getItem('debateTheme')||'light',
      preset: formatSelect.value
    };
    const blob = new Blob([JSON.stringify(state,null,2)],{type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'debate-settings.json';
    a.click();
  };

  importBtn.onclick = () => importFile.click();
  importFile.onchange = (e) => {
    const file = e.target.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try{
        const obj = JSON.parse(reader.result);
        if(obj.settings) localStorage.setItem('debateSettings', JSON.stringify(obj.settings));
        if(obj.theme) setDark(obj.theme==='dark');
        if(obj.preset && PRESETS[obj.preset]) formatSelect.value = obj.preset;
        if(obj.speakers){ baseSpeakers = obj.speakers; }
        if(typeof obj.activeIdx === 'number') activeIdx = obj.activeIdx;
        syncFromInputs();
        buildSequenceForPreset(formatSelect.value);
        drawSpeakers(); applyForSpeaker(); updateMeta();
      }catch(err){ console.warn('Import failed:', err); }
    };
    reader.readAsText(file);
  };

  // ---------- initial load ----------
  function init(){
    formatSelect.value = 'SIMSON';
    buildSequenceForPreset('SIMSON');
    drawSpeakers();
    applyForSpeaker();
    syncFromInputs();
    updateMeta();
  }
  init();

  // ---------- Presenter + Sync safety ----------
  setInterval(()=>{ syncOut(); }, 800);

  // ---------- Self-tests (basic) ----------
  try{
    console.assert(parseTime('0:30')===30000, 'parseTime 0:30 failed');
    console.assert(parseTime('1:30')===90000, 'parseTime 1:30 failed');
    // Additional tests
    console.assert(parseTime('20:00')===1200000, 'parseTime 20:00 failed');
    console.assert(PRESETS.SIMSON.settings.prep==='1:00', 'Simson prep should be 1:00');
    // Sequence starts with Round Prep for Simson
    buildSequenceForPreset('SIMSON');
    console.assert(speakers[0].type==='prep' && speakers[0].role==='Round Prep', 'First item should be Round Prep');
    // scaleX must receive 0..1
    (function(){ const v = clamp(1-(500/1000),0,1); const s = `scaleX(${v})`; console.assert(/^scaleX\((0(\.\d+)?|1(\.0+)?)\)$/.test(s), 'scaleX value format'); })();
    // Grace enters on end
    // inGrace=false; mainTotal=1000; mainRemain=0; mode='main'; triggerEndOfSpeech(); console.assert(inGrace===true && graceRemain===parseTime(graceInput.value), 'Grace should start with configured time');
  }catch(err){ console.warn('Self-tests warning:', err); }
})();
</script>
</body>
</html>






